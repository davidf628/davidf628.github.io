<!--

	- Draw x and f(x) using mathematical typesetting
	- Button with instructional alert box
	- Ability to add an open or closed circle at given value
	- change the textbox giving the x and y-values to anchor like was done in the linear regression applet
	- always keep the x-value on screen
		
	Would be nice:
	- if endpoints at infinity would update whenever the graph was rescaled or zoomed
	- Bounding box would automatically resize itself when the div size is changed
	
-->

<html>
<head>
	<meta charset="utf-8">  
		<link rel='stylesheet' type='text/css' href='./js/jsxgraph.css' />
		<script src='./js/jsxgraphcore.js' type='text/javascript'></script>
		<script src='./js/MathFunctions.js' type='text/javascript'></script>
	</meta>
</head>

<body>

<h1>Numerical Limits</h1>
f(x) = <input type="text" id="input_function" value="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x approaches = <input type="text" id="limit_value" value="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<input type="button" value="Update" onClick="update()">
</br></br>
<div>
<div id="jxgbox" class="jxgbox" style="width:720px; height:720px; float:left; resize: both"></div>
<div id="display" class="jxgbox" style="width:320px; height:720px; float:left"></div>
</div>

<script type='text/javascript'>

LEFT = 0;
RIGHT = 1;

X = 0;
Y = 1;
		
var board = JXG.JSXGraph.initBoard('jxgbox', {
		boundingbox: [-10,10,10,-10], 
      	showCopyright: false, 
      	showNavigation: true,
		keepaspectratio: false,
		axis: true,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: true,
            needshift: false,
            eps: 0.1
        }		
    });
		
var displayboard = JXG.JSXGraph.initBoard('display', {
		boundingbox: [0,10,12,0], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false	
    });
		
// Initialize curve so that we have something we can update
curves = [];
curves[0] = board.create('curve', [0, 0], 0, 0, { visible: false });
endpoints = [];
sequencepoints = [];

left_xvals = [];
left_yvals = [];

right_xvals = [];
right_yvals = [];

// Three dimensional array: left/right, x/y, points 0..3
texts = [];
texts[LEFT] = [];
texts[RIGHT] = [];
texts[LEFT][X] = [];
texts[LEFT][Y] = [];
texts[RIGHT][X] = [];
texts[RIGHT][Y] = [];

textoptions = { fontSize: 24 };

leftlabel = displayboard.create('text', [1, 9.5, 'Limit from the Left:'], textoptions);
leftxlabel = displayboard.create('text', [2, 8.75, 'x'], textoptions);
leftylabel = displayboard.create('text', [6, 8.75, 'f(x)'], textoptions);
leftline1 = displayboard.create('text', [2, 8.5, '------'], textoptions);
leftline2 = displayboard.create('text', [6, 8.5, '------'], textoptions);

texts[LEFT][X][0] = displayboard.create('text', [2, 8, ''], textoptions);
texts[LEFT][X][1] = displayboard.create('text', [2, 7.5, ''], textoptions);
texts[LEFT][X][2] = displayboard.create('text', [2, 7, ''], textoptions);
texts[LEFT][X][3] = displayboard.create('text', [2, 6.5, ''], textoptions);

texts[LEFT][Y][0] = displayboard.create('text', [6, 8, ''], textoptions);
texts[LEFT][Y][1] = displayboard.create('text', [6, 7.5, ''], textoptions);
texts[LEFT][Y][2] = displayboard.create('text', [6, 7, ''], textoptions);
texts[LEFT][Y][3] = displayboard.create('text', [6, 6.5, ''], textoptions);

rightlabel = displayboard.create('text', [1, 5.5, 'Limit from the Right:'], textoptions);
rightxlabel = displayboard.create('text', [2, 4.75, 'x'], textoptions);
rightylabel = displayboard.create('text', [6, 4.75, 'f(x)'], textoptions);
rightline1 = displayboard.create('text', [2, 4.5, '------'], textoptions);
rightline2 = displayboard.create('text', [6, 4.5, '------'], textoptions);

texts[RIGHT][X][0] = displayboard.create('text', [2, 4, ''], textoptions);
texts[RIGHT][X][1] = displayboard.create('text', [2, 3.5, ''], textoptions);
texts[RIGHT][X][2] = displayboard.create('text', [2, 3, ''], textoptions);
texts[RIGHT][X][3] = displayboard.create('text', [2, 2.5, ''], textoptions);

texts[RIGHT][Y][0] = displayboard.create('text', [6, 4, ''], textoptions);
texts[RIGHT][Y][1] = displayboard.create('text', [6, 3.5, ''], textoptions);
texts[RIGHT][Y][2] = displayboard.create('text', [6, 3, ''], textoptions);
texts[RIGHT][Y][3] = displayboard.create('text', [6, 2.5, ''], textoptions);

slider_horiz_zoom = displayboard.create('slider', [[1, 2], [7, 2], [-10, 1, 10]]);
horiz_zoom_label = displayboard.create('text', [9, 2, 'x zoom']);
horiz_zoom_level = 1;
slider_horiz_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_horiz_zoom.Value();
		if(horiz_zoom_level > newfactor) {
			orgbounds[0] = orgbounds[0] * 1.1;
			orgbounds[2] = orgbounds[2] * 1.1;
		} else {
			orgbounds[0] = orgbounds[0] / 1.1;
			orgbounds[2] = orgbounds[2] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		horiz_zoom_level = newfactor;
	});

slider_vert_zoom = displayboard.create('slider', [[1, 1.5], [7, 1.5], [-10, 1, 10]]);
vert_zoom_label = displayboard.create('text', [9, 1.5, 'y zoom']);
vert_zoom_level = 1;
slider_vert_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_vert_zoom.Value();
		if(vert_zoom_level > newfactor) {
			orgbounds[1] = orgbounds[1] * 1.1;
			orgbounds[3] = orgbounds[3] * 1.1;
		} else {
			orgbounds[1] = orgbounds[1] / 1.1;
			orgbounds[3] = orgbounds[3] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		vert_zoom_level = newfactor;
	});	
	
cb_function = JSXCheckBox(displayboard, 6, 0.5, 'Show Function', true, function() { update(); });
cb_sequence = JSXCheckBox(displayboard, 1, 0.5, 'Show Sequence', false, function() { update(); });

function setLLimitVisible(value) {
	lpoint_xaxis.setAttribute({ visible: value });
	lpoint_f.setAttribute({ visible: value });
	lpoint_yaxis.setAttribute({ visible: value });
	lline1.setAttribute({ visible: value });
	lline2.setAttribute({ visible: value });
	lx_label.setAttribute({ visible: value });
	ly_label.setAttribute({ visible: value });
}

function setRLimitVisible(value) {
	rpoint_xaxis.setAttribute({ visible: value });
	rpoint_f.setAttribute({ visible: value });
	rpoint_yaxis.setAttribute({ visible: value });
	rline1.setAttribute({ visible: value });
	rline2.setAttribute({ visible: value });
	rx_label.setAttribute({ visible: value });
	ry_label.setAttribute({ visible: value });
}

cb_llimit = JSXCheckBox(displayboard, 1, 1, 'Show Left Limit', true, function() { setLLimitVisible(cb_llimit.Value()); });
cb_rlimit = JSXCheckBox(displayboard, 6, 1, 'Show Right Limit', true, function() { setRLimitVisible(cb_rlimit.Value()); });

// Define all the points that will be used to show the limits

xaxis = board.create('line', [[0, 0], [1, 0]], { visible: false });
lpoint_xaxis = board.create('glider', [1, 0, xaxis], { name: 'x', withLabel: false, showInfobox: false }); 

lpoint_f = board.create('point', [
	function() { 
		return lpoint_xaxis.X(); 
	}, 
	function() { 
		var f = document.getElementById('input_function').value;
		if(f == '') { 
			return 0;
		} else {
			return evaluate(f, lpoint_xaxis.X()); 
		}
	}], { name: '(x, f(x))', withLabel: false, showInfobox: false });

lpoint_yaxis = board.create('point', [0, 
	function() { 
		var f = document.getElementById('input_function').value;
		if(f == '') { 
			return 0;
		} else {
			return evaluate(f, lpoint_xaxis.X()); 
		}
	}], { name: 'y', withLabel: false, showInfobox: false });
	
lline1 = board.create('segment', [lpoint_xaxis, lpoint_f], { color: 'red' });
lline2 = board.create('segment', [lpoint_yaxis, lpoint_f], { color: 'red' });
	
lx_label = board.create('text', [0, 0, function() { return 'x = ' + displayNumber(lpoint_xaxis.X()); }], { anchor: lpoint_xaxis, color: 'red', fontSize: 18 });	
ly_label = board.create('text', [0, 0, function() { return 'y = ' + displayNumber(lpoint_yaxis.Y()); }], { anchor: lpoint_yaxis, color: 'red', fontSize: 18 });	
	
rpoint_xaxis = board.create('glider', [0, 0, xaxis], { name: 'x', color: 'green', withLabel: false, showInfobox: false }); 
rpoint_f = board.create('point', [
	function() { 
		return rpoint_xaxis.X(); 
	}, 
	function() { 
		var f = document.getElementById('input_function').value;
		if(f == '') { 
			return 0;
		} else {
			return evaluate(f, rpoint_xaxis.X()); 
		}
	}], { name: '(x, f(x))', color: 'green', withLabel: false, showInfobox: false });

rpoint_yaxis = board.create('point', [0, 
	function() { 
		var f = document.getElementById('input_function').value;
		if(f == '') { 
			return 0;
		} else {
			return evaluate(f, rpoint_xaxis.X()); 
		}
	}], { name: 'y', color: 'green', withLabel: false, showInfobox: false });
	
rline1 = board.create('segment', [rpoint_xaxis, rpoint_f], { color: 'green' });
rline2 = board.create('segment', [rpoint_yaxis, rpoint_f], { color: 'green' });
	
rx_label = board.create('text', [0, 0, function() { return 'x = ' + displayNumber(rpoint_xaxis.X()); }], { anchor: rpoint_xaxis, color: 'green', fontSize: 18 });	
ry_label = board.create('text', [0, 0, function() { return 'y = ' + displayNumber(rpoint_yaxis.Y()); }], { anchor: rpoint_yaxis, color: 'green', fontSize: 18 });	
	
function evaluate_list(f, xlist) {
	if(f == '') {
		return '';
	} else {
		ylist = [];
		for(i = 0; i < xlist.length; i++) {
			ylist[i] = evaluate(f, xlist[i]);
		}
		return ylist;
	}
}

function updateChart(list, values) {
	if(values == '') {
		for(i = 0; i < list.length; i++) {
			list[i].setText('');
		}
	} else {
		for(i = 0; i < values.length; i++) {
			list[i].setText(displayNumber(values[i]));
		}
	}
}

function update() {

	orgbounds = board.getBoundingBox();
	width = document.getElementById('jxgbox').clientWidth;
	height = document.getElementById('jxgbox').clientHeight;

	board.resizeContainer(width, height);
	board.setBoundingBox(orgbounds, false);

	var f = document.getElementById('input_function').value;
	var fs = f.split(";");

	for(var i = 0; i < curves.length; i++) {
		board.removeObject(curves[i]);
	}
	
	for(var i = 0; i < endpoints.length; i++) {
		board.removeObject(endpoints[i]);
	}
	
	if(cb_function.Value()) {
		var tmpendpoints = [];
		for(var i = 0; i < fs.length; i++) {
			[curves[i], tmpendpoints] = plot_function(fs[i]);
			for(endpoint in tmpendpoints) {
				endpoints.push(endpoint);
			}
		}
	}
	
	for(var i = 0; i < sequencepoints.length; i++) {
		board.removeObject(sequencepoints[i]);
	}
	
	var limit_value = document.getElementById('limit_value').value;
	
	if(limit_value == 'infinity' || limit_value == 'inf') {
	
		left_xvals[0] = 10;
		left_xvals[1] = 100;
		left_xvals[2] = 1000;
		left_xvals[3] = 10000;
		
		left_yvals = evaluate_list(f, left_xvals);
		right_yvals = evaluate_list('', null);
		
		updateChart(texts[LEFT][X], left_xvals);
		updateChart(texts[LEFT][Y], left_yvals);
		updateChart(texts[RIGHT][X], '');
		updateChart(texts[RIGHT][Y], '');
				
	} else if(limit_value == '-infinity' || limit_value == '-inf') {
	
		right_xvals[0] = -10;
		right_xvals[1] = -100;
		right_xvals[2] = -1000;
		right_xvals[3] = -10000;
		
		right_yvals = evaluate_list(f, right_xvals);
		left_yvals = evaluate_list('', null);
		
		updateChart(texts[LEFT][X], '');
		updateChart(texts[LEFT][Y], '');
		updateChart(texts[RIGHT][X], right_xvals);
		updateChart(texts[RIGHT][Y], right_yvals);
		
	} else {
	
		a = parseInt(limit_value);
		left_xvals[0] = a - 0.1;
		left_xvals[1] = a - 0.01;
		left_xvals[2] = a - 0.001;;	
		left_xvals[3] = a - 0.0001;
		
		right_xvals[0] = a + 0.1;
		right_xvals[1] = a + 0.01;
		right_xvals[2] = a + 0.001;
		right_xvals[3] = a + 0.0001;
		
		left_yvals = evaluate_list(f, left_xvals);
		right_yvals = evaluate_list(f, right_xvals);
		
		updateChart(texts[LEFT][X], left_xvals);
		updateChart(texts[LEFT][Y], left_yvals);
		
		updateChart(texts[RIGHT][X], right_xvals);
		updateChart(texts[RIGHT][Y], right_yvals);

	}
	
	if(cb_sequence.Value()) {
		var bounds = board.getBoundingBox();
		var maxX = Math.floor(bounds[2]);
		for(var n = 1; n <= maxX; n++) {
			sequencepoints[n] = board.create('point', [n, evaluate(f, n)], { withLabel: false, color: 'orange' });
		}
	}
	
	board.update();	
		
}



</script>
</body>
</html>