<!--
	- Get Zoom Square functionality working
	- Allow user to move a line that makes a guess at the regression line
	- Allow user to move a point along the x-axis to simulate making a prediction based on the line
	- Allow for multiple types of regression (polynomial, sinus, exponential, etc.
	- The the value of p-value
-->

<html>
<head>
	<meta charset="utf-8">  
		<link rel='stylesheet' type='text/css' href='https://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css' />
		<script src='https://jsxgraph.uni-bayreuth.de/distrib/jsxgraphcore.js' type='text/javascript'></script>
		<script src='https://jsxgraph.uni-bayreuth.de/distrib/GeonextReader.js' type='text/javascript'></script>
		<script src='./js/MathFunctions.js' type='text/javascript'></script>
	</meta>
</head>

<body>

<h1>Linear Regression</h1>
<input type="button" value="Add Point" onClick="addpoint()">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<input type="button" value="Clear All Points" onClick="clearpoints()">
</br></br>

<div>
	<div id="jxgbox" class="jxgbox" style="width:720px; height:720px; float:left; resize: both"></div>
	<div id="display" class="jxgbox" style="width:320px; height:720px; float:left"></div>
</div>

<script type='text/javascript'>
		
var board = JXG.JSXGraph.initBoard('jxgbox', {
		boundingbox: [-1,10,10,-1], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: true,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1
        }		
    });
		
var displayboard = JXG.JSXGraph.initBoard('display', {
		boundingbox: [0,10,12,0], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false	
    });		
		
// Initialize variables so that we have something we can update
regressionLine = board.create('point', [0, 0], { visible: false });
points = [];
residualsOfRegression = [];
squaresOfRegression = [];
//residualsOfPrediction = [];
reg = '';

cb_showRegressionLine = displayboard.create('checkbox', [1, 8, 'Show Regression Line']);
cb_showResiduals = displayboard.create('checkbox', [1, 7.5, 'Show Residuals']);
cb_showSquares = displayboard.create('checkbox', [1, 7, 'Show Squares of Residuals']);
cb_showPrediction = displayboard.create('checkbox', [1, 6.5, 'Show Prediction']);
cb_showGuess = displayboard.create('checkbox', [1, 6, 'Show Estimated Regression Line']);

cb_showRegressionLine.rendNodeCheckbox.checked = true;
cb_showRegressionLine._value = true;

regression_txt = displayboard.create('text', [1, 5, 
	function() { 
		if(points.length > 2) {
			return 'y = ' + reg.getTerm();
		} else return 'No Equation.';
	}]);

correlation_txt = displayboard.create('text', [1, 4.5,
	function() {
		var txt = 'Correlation Coefficient: r = ';
		var x_data = [], y_data = [];
		
		for(var i = 0; i < points.length; i++) {
			x_data.push(points[i].X());
			y_data.push(points[i].Y());
		}
		
		var correl = correlation(x_data, y_data);
		if(correl == NaN) {
			txt += 'Undefined'
		} else txt += round(correl, 4);
		
		return txt;
	}]);

sqrresidualsum_txt = displayboard.create('text', [1, 4,
	function() {
		var txt = 'Sum of Squares of Residuals: ';
		var x_data = [], y_data = [];
		
		for(var i = 0; i < points.length; i++) {
			x_data.push(points[i].X());
			y_data.push(points[i].Y());
		}
		
		var sum = 0;
		if(points.length > 2) {
			for(var i = 0; i < points.length; i++) {
				dist = y_data[i] - reg(x_data[i]);
				sum += dist * dist;
			}
		} 
		
		return txt + round(sum, 2);
	}]);
	
/*residualsum_txt = displayboard.create('text', [1, 4,
	function() {
		var txt = 'Residual Sum: ';
		var x_data = [], y_data = [];
		
		for(var i = 0; i < points.length; i++) {
			x_data.push(points[i].X());
			y_data.push(points[i].Y());
		}
		
		var sum = 0;
		if(points.length > 2) {
			for(var i = 0; i < points.length; i++) {
				dist = y_data[i] - reg(x_data[i]);
				sum+= dist;
			}
		} 
		
		return txt + sum;
	}]);*/
	
function update() {

	board.suspendUpdate();
	
	var orgbounds = board.getBoundingBox();
	
	var width = document.getElementById('jxgbox').clientWidth;
	var height = document.getElementById('jxgbox').clientHeight;

	board.resizeContainer(width, height);
	board.setBoundingBox(orgbounds, false);

	if((points.length >= 2) && (cb_showRegressionLine.Value())) {
		board.removeObject(regressionLine);
		reg = JXG.Math.Numerics.regressionPolynomial(1, points);
		regressionLine = board.create('functiongraph', [reg]);
		
		if(cb_showResiduals.Value()) {
		
			while(residualsOfRegression.length != 0) {
				board.removeObject(residualsOfRegression[0]);
				residualsOfRegression.shift();
			}
		
			for(var i = 0; i < points.length; i++) {
				residualsOfRegression.push(board.create('segment', [
					[points[i].X(), points[i].Y()],
					[points[i].X(), reg(points[i].X())]], 
					{ strokeColor: '#ff00ff', 
					  dash: 2, 
					  strokeWidth: 1, 
					  fixed: true }));
			}
		
		}
		
		if(cb_showSquares.Value()) {
		
			while(squaresOfRegression.length != 0) {
				board.removeObject(squaresOfRegression[0]);
				squaresOfRegression.shift();
			}
		
			// Draw polygon 'squares'
			for(var i = 0; i < points.length; i++) {
				var reg_x = reg(points[i].X());
				var d = points[i].Y() - reg_x;
				squaresOfRegression.push(board.create('polygon', [
					[points[i].X(), reg_x],
					[points[i].X(), points[i].Y()],
					[points[i].X() + d, points[i].Y()], 
					[points[i].X() + d, reg_x]],
					{ strokeColor: '#ff00ff', 
					  dash: 1, 
					  strokeWidth: 1, 
					  fixed: true,
					  fillColor: '#ff00ff',
					  fillOpacity: 0.3,
					  vertices: { visible: false }, 
					  borders: { strokeColor: '#ff00ff', dash: 2 } }));
			}
		
		}
		
	}
	
	board.update();	
	displayboard.update();
		
}

function addpoint() {

	var orgbounds = board.getBoundingBox();
	
	var xmin = orgbounds[0];
	var ymin = orgbounds[3];
	var xmax = orgbounds[2];
	var ymax = orgbounds[1];

	var randomX = randomFloat(xmin + 1, xmax - 1);
	var randomY = randomFloat(ymin + 1, ymax - 1);
	
	var a = board.create('point', [randomX, randomY], { withLabel: false });
	a.on('drag', function() { update(); });
	points.push(a);
	
	update();
}

function clearpoints() {

	board.removeObject(regressionLine);
	
	while(points.length != 0) {
		board.removeObject(points[0]);
		points.shift();		
	}
	
	while(residualsOfRegression.length != 0) {
		board.removeObject(residualsOfRegression[0]);
		residualsOfRegression.shift();
	}
	
	update();
}

JXG.addEvent(cb_showRegressionLine.rendNodeCheckbox, 'change', 
	function() {
		regressionLine.setAttribute( { visible: !regressionLine.getAttribute('visible') });	
		if(cb_showResiduals.Value()) {
			for(var i = 0; i < residualsOfRegression.length; i++) {
				residualsOfRegression[i].setAttribute( { visible: regressionLine.getAttribute('visible') });	
			}
		}
		if(cb_showSquares.Value()) {
			for(var i = 0; i < squaresOfRegression.length; i++) {
				for(var j = 0; j < squaresOfRegression[i].borders.length; j++) {
					squaresOfRegression[i].borders[j].setAttribute( { visible: regressionLine.getAttribute('visible') } );
				}	
				squaresOfRegression[i].setAttribute( { visible: regressionLine.getAttribute('visible') });	
			}
		}
		board.update();		
    }, cb_showRegressionLine);

JXG.addEvent(cb_showResiduals.rendNodeCheckbox, 'change', 
	function() {
		if(cb_showRegressionLine.Value()) {
			for(var i = 0; i < residualsOfRegression.length; i++) {
				residualsOfRegression[i].setAttribute( { visible: !residualsOfRegression[i].getAttribute('visible') });	
			}
		}
		/*if(cb_showPrediction.Value()) {
			for(var i = 0; i < residualsOfPrediction.length; i++) {
				residualsOfPrediction[i].setAttribute( { visible: !residualsOfPrediction[i].getAttribute('visible') });	
			}
		}*/
		update();	
    }, cb_showResiduals);
	
JXG.addEvent(cb_showSquares.rendNodeCheckbox, 'change', 
	function() {
		if(cb_showRegressionLine.Value()) {
			for(var i = 0; i < squaresOfRegression.length; i++) {
				for(var j = 0; j < squaresOfRegression[i].borders.length; j++) {
					squaresOfRegression[i].borders[j].setAttribute( { visible: !squaresOfRegression[i].getAttribute('visible') } );
				}				
				squaresOfRegression[i].setAttribute( { visible: !squaresOfRegression[i].getAttribute('visible') });				
			}
		}
		/*if(cb_showPrediction.Value()) {
			for(var i = 0; i < residualsOfPrediction.length; i++) {
				residualsOfPrediction[i].setAttribute( { visible: !residualsOfPrediction[i].getAttribute('visible') });	
			}
		}*/
		update();	
    }, cb_showSquares);	
	
cb_ZoomSquare = displayboard.create('checkbox', [1, 9, 'Zoom Square']);

slider_horiz_zoom = displayboard.create('slider', [[1, 2], [7, 2], [-10, 1, 10]]);
horiz_zoom_label = displayboard.create('text', [9, 2, 'x zoom']);
horiz_zoom_level = 1;
slider_horiz_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_horiz_zoom.Value();
		if(horiz_zoom_level > newfactor) {
			orgbounds[0] = orgbounds[0] * 1.1;
			orgbounds[2] = orgbounds[2] * 1.1;
		} else {
			orgbounds[0] = orgbounds[0] / 1.1;
			orgbounds[2] = orgbounds[2] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		horiz_zoom_level = newfactor;
	});

slider_vert_zoom = displayboard.create('slider', [[1, 1.5], [7, 1.5], [-10, 1, 10]]);
vert_zoom_label = displayboard.create('text', [9, 1.5, 'y zoom']);
vert_zoom_level = 1;
slider_vert_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_vert_zoom.Value();
		if(vert_zoom_level > newfactor) {
			orgbounds[1] = orgbounds[1] * 1.1;
			orgbounds[3] = orgbounds[3] * 1.1;
		} else {
			orgbounds[1] = orgbounds[1] / 1.1;
			orgbounds[3] = orgbounds[3] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		vert_zoom_level = newfactor;
	});	

</script>
</body>
</html>