<!--

	- Draw x and f(x) using mathematical typesetting
	- Button with instructional alert box
	- Ability to add an open or closed circle at given value
	- change the textbox giving the x and y-values to anchor like was done in the linear regression applet
	- always keep the x-value on screen
		
	Would be nice:
	- if endpoints at infinity would update whenever the graph was rescaled or zoomed
	- Bounding box would automatically resize itself when the div size is changed
	
-->

<html>
<head>
	<meta charset="utf-8">  
		<link rel='stylesheet' type='text/css' href='./js/jsxgraph.css' />
		<script src='./js/jsxgraphcore.js' type='text/javascript'></script>
		<script src='./js/MathFunctions.js' type='text/javascript'></script>
		<script src='./js/math.min.js' type='text/javascript'></script>
		<script src='./js/helpers.js' type='text/javascript'></script>
	</meta>
</head>

<body>

<h1>Numerical Limits</h1>
f(x) = <input type="text" id="input_function" value="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x approaches:  <input type="text" id="limit_value" value="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<input type="button" value="Update" onClick="update()">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<input type="button" value="Toggle Fullscreen" onClick="fullscreen()"></br></br>
Set Left Limit: x = <input type="text" id="left_value" value="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set Right Limit: x = <input type="text" id="right_value" value="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<input type="button" value="Set Limit Values" onClick="setlimitvalues()">
</br></br>
<div>
<div id="jxgbox" class="jxgbox" style="width:720px; height:720px; float:left; resize: both"></div>
<div id="display" class="jxgbox" style="width:320px; height:720px; float:left"></div>
</div>

<script type='text/javascript'>

LEFT = 0;
RIGHT = 1;

X = 0;
Y = 1;
		
var board = JXG.JSXGraph.initBoard('jxgbox', {
		boundingbox: [-10,10,10,-10], 
      	showCopyright: false, 
      	showNavigation: true,
		keepaspectratio: false,
		axis: true,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: true,
            needshift: false,
            eps: 0.1
        }		
    });
		
var displayboard = JXG.JSXGraph.initBoard('display', {
		boundingbox: [0,10,12,0], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		pan: { enabled: false },
		zoom: { enabled: false }
    });
		
// Initialize curve so that we have something we can update
curves = [];
for(var i = 0; i < 10; i++) {
	curves[i] = board.create('curve', [0, 0], 0, 0, { visible: false });
}

// Initialize endpoints so we have values we can update
endpoints = [];
for(var i = 0; i < 30; i++) {
	endpoints[i] = board.create('point', [0, 0], { size: 3, withLabel: false, visible: false, fixed: true });
}

// Initialize holes so we have points to use
holes = [];
for(var i = 0; i < 10; i++) {
	holes[i] = board.create('point', [0, 0], { size: 3, withLabel: false, visible: false, fixed: true });
}

// These are used when we want to look at a limit sequence
sequencepoints = [];
seriespoints = [];

left_xvals = [];
left_yvals = [];

right_xvals = [];
right_yvals = [];

// Three dimensional array: left/right, x/y, points 0..3
texts = [];
texts[LEFT] = [];
texts[RIGHT] = [];
texts[LEFT][X] = [];
texts[LEFT][Y] = [];
texts[RIGHT][X] = [];
texts[RIGHT][Y] = [];

textoptions = { fontSize: 24, fixed: true };

leftlabel = displayboard.create('text', [1, 9.5, 'Limit from the Left:'], textoptions);
leftxlabel = displayboard.create('text', [2, 9, 'x'], textoptions);
leftylabel = displayboard.create('text', [6, 9, 'f(x)'], textoptions);
leftline1 = displayboard.create('text', [2, 8.75, '------'], textoptions);
leftline2 = displayboard.create('text', [6, 8.75, '------'], textoptions);

texts[LEFT][X][0] = displayboard.create('text', [2, 8.25, ''], textoptions);
texts[LEFT][X][1] = displayboard.create('text', [2, 7.75, ''], textoptions);
texts[LEFT][X][2] = displayboard.create('text', [2, 7.25, ''], textoptions);
texts[LEFT][X][3] = displayboard.create('text', [2, 6.75, ''], textoptions);

texts[LEFT][Y][0] = displayboard.create('text', [6, 8.25, ''], textoptions);
texts[LEFT][Y][1] = displayboard.create('text', [6, 7.75, ''], textoptions);
texts[LEFT][Y][2] = displayboard.create('text', [6, 7.25, ''], textoptions);
texts[LEFT][Y][3] = displayboard.create('text', [6, 6.75, ''], textoptions);

rightlabel = displayboard.create('text', [1, 6, 'Limit from the Right:'], textoptions);
rightxlabel = displayboard.create('text', [2, 5.5, 'x'], textoptions);
rightylabel = displayboard.create('text', [6, 5.5, 'f(x)'], textoptions);
rightline1 = displayboard.create('text', [2, 5.25, '------'], textoptions);
rightline2 = displayboard.create('text', [6, 5.25, '------'], textoptions);

texts[RIGHT][X][0] = displayboard.create('text', [2, 4.75, ''], textoptions);
texts[RIGHT][X][1] = displayboard.create('text', [2, 4.25, ''], textoptions);
texts[RIGHT][X][2] = displayboard.create('text', [2, 3.75, ''], textoptions);
texts[RIGHT][X][3] = displayboard.create('text', [2, 3.25, ''], textoptions);

texts[RIGHT][Y][0] = displayboard.create('text', [6, 4.75, ''], textoptions);
texts[RIGHT][Y][1] = displayboard.create('text', [6, 4.25, ''], textoptions);
texts[RIGHT][Y][2] = displayboard.create('text', [6, 3.75, ''], textoptions);
texts[RIGHT][Y][3] = displayboard.create('text', [6, 3.25, ''], textoptions);

slider_horiz_zoom = displayboard.create('slider', [[1, 2.5], [7, 2.5], [-10, 1, 10]]);
horiz_zoom_label = displayboard.create('text', [9, 2.5, 'x zoom'], { fixed: true });
horiz_zoom_level = 1;
slider_horiz_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_horiz_zoom.Value();
		if(horiz_zoom_level > newfactor) {
			orgbounds[0] = orgbounds[0] * 1.1;
			orgbounds[2] = orgbounds[2] * 1.1;
		} else {
			orgbounds[0] = orgbounds[0] / 1.1;
			orgbounds[2] = orgbounds[2] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		horiz_zoom_level = newfactor;
	});

slider_vert_zoom = displayboard.create('slider', [[1, 2], [7, 2], [-10, 1, 10]]);
vert_zoom_label = displayboard.create('text', [9, 2, 'y zoom'], { fixed: true });
vert_zoom_level = 1;
slider_vert_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_vert_zoom.Value();
		if(vert_zoom_level > newfactor) {
			orgbounds[1] = orgbounds[1] * 1.1;
			orgbounds[3] = orgbounds[3] * 1.1;
		} else {
			orgbounds[1] = orgbounds[1] / 1.1;
			orgbounds[3] = orgbounds[3] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		vert_zoom_level = newfactor;
	});	

function setLLimitVisible(value) {
	lpoint_xaxis.setAttribute( { visible: value } );
	lpoint_f.setAttribute( { visible: value } );
	lpoint_yaxis.setAttribute( { visible: value } );
	lline1.setAttribute({ visible: value });
	lline2.setAttribute({ visible: value });
	lx_label.setAttribute({ visible: value });
	ly_label.setAttribute({ visible: value });
}

function setRLimitVisible(value) {
	rpoint_xaxis.setAttribute({ visible: value });
	rpoint_f.setAttribute({ visible: value });
	rpoint_yaxis.setAttribute({ visible: value });
	rline1.setAttribute({ visible: value });
	rline2.setAttribute({ visible: value });
	rx_label.setAttribute({ visible: value });
	ry_label.setAttribute({ visible: value });
}

cb_llimit = JSXCheckbox(displayboard, 1, 1.5, 'Show Left Limit', false, function() { setLLimitVisible(cb_llimit.Value()); });
cb_rlimit = JSXCheckbox(displayboard, 6, 1.5, 'Show Right Limit', false, function() { setRLimitVisible(cb_rlimit.Value()); });

// Define all the points that will be used to show the limits

xaxis = board.create('line', [[0, 0], [1, 0]], { visible: false });
lpoint_xaxis = board.create('glider', [1, 0, xaxis], { name: 'x', withLabel: false, showInfobox: false }); 

lpoint_f = board.create('point', [
	function() { 
		return lpoint_xaxis.X(); 
	}, 
	function() { 
		var f = document.getElementById('input_function').value;
		if(f == '') { 
			return 0;
		} else {
			

			
			return evaluate(f, lpoint_xaxis.X()); 
		}
	}], { name: '(x, f(x))', withLabel: false, showInfobox: false });

lpoint_yaxis = board.create('point', [0, 
	function() { 
		var f = document.getElementById('input_function').value;
		if(f == '') { 
			return 0;
		} else {
			return evaluate(f, lpoint_xaxis.X()); 
		}
	}], { name: 'y', withLabel: false, showInfobox: false });
	
lline1 = board.create('segment', [lpoint_xaxis, lpoint_f], { color: 'red' });
lline2 = board.create('segment', [lpoint_yaxis, lpoint_f], { color: 'red' });
	
lx_label = board.create('text', [0, 0, function() { return 'x = ' + displayNumber(lpoint_xaxis.X()); }], { anchor: lpoint_xaxis, color: 'red', fontSize: 18 });	
ly_label = board.create('text', [0, 0, function() { return 'y = ' + displayNumber(lpoint_yaxis.Y()); }], { anchor: lpoint_yaxis, color: 'red', fontSize: 18 });	
	
rpoint_xaxis = board.create('glider', [0, 0, xaxis], { name: 'x', color: 'green', withLabel: false, showInfobox: false }); 
rpoint_f = board.create('point', [
	function() { 
		return rpoint_xaxis.X(); 
	}, 
	function() { 
		var f = document.getElementById('input_function').value;
		if(f == '') { 
			return 0;
		} else {
			return evaluate(f, rpoint_xaxis.X()); 
		}
	}], { name: '(x, f(x))', color: 'green', withLabel: false, showInfobox: false });

rpoint_yaxis = board.create('point', [0, 
	function() { 
		var f = document.getElementById('input_function').value;
		if(f == '') { 
			return 0;
		} else {
			return evaluate(f, rpoint_xaxis.X()); 
		}
	}], { name: 'y', color: 'green', withLabel: false, showInfobox: false });
	
rline1 = board.create('segment', [rpoint_xaxis, rpoint_f], { color: 'green' });
rline2 = board.create('segment', [rpoint_yaxis, rpoint_f], { color: 'green' });
	
rx_label = board.create('text', [0, 0, function() { return 'x = ' + displayNumber(rpoint_xaxis.X()); }], { anchor: rpoint_xaxis, color: 'green', fontSize: 18 });	
ry_label = board.create('text', [0, 0, function() { return 'y = ' + displayNumber(rpoint_yaxis.Y()); }], { anchor: rpoint_yaxis, color: 'green', fontSize: 18 });	
	
setLLimitVisible(false);
setRLimitVisible(false);	
	
function evaluatelist(f, xlist) {
	if(f == '') {
		return '';
	} else {
		ylist = [];
		for(i = 0; i < xlist.length; i++) {
			ylist[i] = evaluate(f, xlist[i]);
		}
		return ylist;
	}
}

function updateChart(list, values) {
	if(values == '') {
		for(i = 0; i < list.length; i++) {
			list[i].setText('');
		}
	} else {
		for(i = 0; i < values.length; i++) {
			list[i].setText(displayNumber(values[i]));
		}
	}
}

function update() {

	orgbounds = board.getBoundingBox();
	width = document.getElementById('jxgbox').clientWidth;
	height = document.getElementById('jxgbox').clientHeight;

	var window = JSXGetBounds(board);

	board.resizeContainer(width, height);
	board.setBoundingBox(orgbounds, false);

	var f = document.getElementById('input_function').value;
	var fs = f.split(";");
	
	var tmpendpoints = [];
	for(var i = 0; i < fs.length; i++) {
		var interval = getInterval(fs[i]);
		if(interval != '') {
			fs[i] = removeInterval(fs[i]);
		}
		plot_function(curves[i], fs[i], 
			window.xmin, window.xmax, { 
				lowerendpoint: endpoints[2*i],
				upperendpoint: endpoints[2*i+1],
				hole: holes[i],
				interval: interval	
			});
		curves[i].setAttribute( { visible: true } );
	}
	
	var limit_value = document.getElementById('limit_value').value;
	
	if(limit_value == 'infinity' || limit_value == 'inf') {
	
		left_xvals[0] = 10;
		left_xvals[1] = 100;
		left_xvals[2] = 1000;
		left_xvals[3] = 10000;
		
		left_yvals = evaluatelist(f, left_xvals);
		right_yvals = evaluatelist('', null);
		
		updateChart(texts[LEFT][X], left_xvals);
		updateChart(texts[LEFT][Y], left_yvals);
		updateChart(texts[RIGHT][X], '');
		updateChart(texts[RIGHT][Y], '');
				
	} else if(limit_value == '-infinity' || limit_value == '-inf') {
	
		right_xvals[0] = -10;
		right_xvals[1] = -100;
		right_xvals[2] = -1000;
		right_xvals[3] = -10000;
		
		right_yvals = evaluatelist(f, right_xvals);
		left_yvals = evaluatelist('', null);
		
		updateChart(texts[LEFT][X], '');
		updateChart(texts[LEFT][Y], '');
		updateChart(texts[RIGHT][X], right_xvals);
		updateChart(texts[RIGHT][Y], right_yvals);
		
	} else {
	
		a = parseInt(limit_value);
		left_xvals[0] = a - 0.1;
		left_xvals[1] = a - 0.01;
		left_xvals[2] = a - 0.001;;	
		left_xvals[3] = a - 0.0001;
		
		right_xvals[0] = a + 0.1;
		right_xvals[1] = a + 0.01;
		right_xvals[2] = a + 0.001;
		right_xvals[3] = a + 0.0001;
		
		left_yvals = evaluatelist(f, left_xvals);
		right_yvals = evaluatelist(f, right_xvals);
		
		updateChart(texts[LEFT][X], left_xvals);
		updateChart(texts[LEFT][Y], left_yvals);
		
		updateChart(texts[RIGHT][X], right_xvals);
		updateChart(texts[RIGHT][Y], right_yvals);

	}
	
	board.update();	
		
}

function setlimitvalues() {
	var lx = document.getElementById('left_value').value;
	var rx = document.getElementById('right_value').value;
	if(lx != '') {
		lpoint_xaxis.moveTo([lx, 0]);
	}
	if(rx != '') {
		rpoint_xaxis.moveTo([rx, 0]);
	}
}

</script>
</body>
</html>