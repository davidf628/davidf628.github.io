<!DOCTYPE html>
<html lang = "en-US">

<head>

	<title>Statistics Calculator</title>
	<meta charset="utf-8">  
	
	<link rel='stylesheet' type='text/css' href='./js/jsxgraph.css' />
	<script src='./js/jsxgraphcore.js' type='text/javascript'></script>
	<script src='./js/MathFunctions.js' type='text/javascript'></script>
	<script src='./js/helpers.js' type='text/javascript'></script>
	
	<style>
		body {
			font-family: Arial;
		}
		
		/* Style the tab */
		.tab {
			overflow: hidden;
			border: 1px solid #ccc;
			background-color: #f1f1f1;
		}
		
		/* Style the buttons that are used to open the tab content */
		.tab button {
			background-color: inherit;
			float: left;
			border: none;
			outline: none;
			cursor: pointer;
			padding: 14px 16px;
			transition: 0.3s;
		}
		
		/* Change background color of buttons on hover */
		.tab button:hover {
			background-color: #ddd;
		}
		
		/* Create an active/current tablink class */
		.tab button.active {
			background-color: #ccc;
		}
		
		/* Style the tab content */
		.tabcontent {
			display: none;
			padding: 6px 12px;
			border: 1px solid #ccc;
			border-top: none;
		}
		
	</style>
	
</head>

<body>

<h1>Statistics Calculator</h1>


<!-- Tab links -->
<div class="tab">
	<button class="tablinks" id="defaultOpen" onclick="openTool(event, 'standard_normal')">Normal</button>
	<button class="tablinks" onclick="openTool(event, 't-distribution')">Student's T</button>
</div>

<!-- Tab content -->
<div id="standard_normal" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="t-distribution" class="jxgbox" style="width:540px; height:540px;"></div>

<script>
function openTool(evt, tool) {
	// Declare all variables
	var i, tabcontent, tablinks;

	// Get all elements with class="tabcontent" and hide them
	tabcontent = document.getElementsByClassName("jxgbox");
	for (i = 0; i < tabcontent.length; i++) {
		tabcontent[i].style.display = "none";
	}

	// Get all elements with class="tablinks" and remove the class "active"
	tablinks = document.getElementsByClassName("tablinks");
	for (i = 0; i < tablinks.length; i++) {
		tablinks[i].className = tablinks[i].className.replace(" active", "");
	}

	// Show the current tab, and add an "active" class to the button that opened the tab
	document.getElementById(tool).style.display = "block";
	evt.currentTarget.className += " active";
}
document.getElementById("defaultOpen").click();
</script>


<script>
	// Define global variables

	var shadeParam = { 
		color: '#0000FF', 
		fillOpacity: 0.4, 
		withLabel: false,
		fixed: true,
		highlight: false
	};
	
	var PTYPE = 'between';
	
</script>


<script>

var board_normal = JXG.JSXGraph.initBoard('standard_normal', {
		boundingbox: [-4,0.5,4,-0.5], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },	
		pan: {
			enabled: false
		}
    });

mean_n = 0;
stdev_n = 1;

function zScore(x) {
	return (x - mean_n) / stdev_n;
}
			
function xValue(z) {
	return mean_n + z * stdev_n;
}			
			
normal_curve = board_normal.create('functiongraph', [function(x) { return normalpdf(zScore(x)); }], 
	{ strokeWidth: 3, fixed: true, 	highlight: false });
	
hidden_axis = board_normal.create('line', [[0, 0], [1, 0]], { visible: false });

x_axis = board_normal.create('axis', [[0, 0], [1, 0]], 
	{ ticks: { visible: false } });
	
z1 = board_normal.create('glider', [-2, 0, x_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
z1.on('drag', 
	function() { 
		x1.rendNodeInput.value = z1.X().toFixed(2);
		prob.rendNodeInput.value = currentProbability(zScore(z1.X()), zScore(z2.X()));
	}
);

z2 = board_normal.create('glider', [2, 0, x_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
z2.on('drag', 
	function() { 
		x2.rendNodeInput.value = z2.X().toFixed(2);
		prob.rendNodeInput.value = currentProbability(zScore(z1.X()), zScore(z2.X()));
	}
);

ticks_n = [];
labels_n = [];
for (var i = -3; i <= 3; i++) {
	ticks_n[i + 3] = board_normal.create('segment', [[i,.01], [i,-0.01]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
	labels_n[i + 3] = board_normal.create('text', [i-.05, -0.02, i], { fixed: true, highlight: false });
}

// input variables

mean = board_normal.create('input', [1.3, 0.38, '0', '&mu; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true });
stdev = board_normal.create('input', [1.3, 0.3, '1', '&sigma; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true });

x1 = board_normal.create('input', [-3.5, -0.32, '-2', 'P( '], { fontSize: 18, cssStyle: 'width: 100px ', frozen: true });
x2 = board_normal.create('input', 
		[-1.3, -0.32, '2', ' < <i>X</i> < '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true });
		
prob = board_normal.create('input', [1.3, -0.32, '0.9500', ') = '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, disabled: true });

calc_normal = board_normal.create('button', [1.5, -0.42, 'Calculate',
	function () {
	
		if(isChecked(cb_area)) {
			if(!isNaN(x1.Value())) {
				z1.moveTo([x1.Value(), 0]);
			}
	
			if(!isNaN(x2.Value())) {
				z2.moveTo([x2.Value(), 0]);
			}
	
			prob.rendNodeInput.value = currentProbability(zScore(x1.Value()), zScore(x2.Value()));
		
		} else {
			if(!isNaN(prob.Value())) {
			
				if(PTYPE == 'left') {
					var z = xValue(invnorm(prob.Value()));
					z2.moveTo([z, 0]);
					x2.rendNodeInput.value = z;
				} else if(PTYPE == 'right') {
					var z = xValue(invnorm(1 - prob.Value()));
					z1.moveTo([z, 0]);
					x1.rendNodeInput.value = z;
				}
			
			}
		}
}], { frozen: true });


function updateAxisLabels() {
	
	for(var i = -3; i <= 3; i++) {
		ticks_n[i + 3].point1.moveTo([xValue(i), 0.01]);
		ticks_n[i + 3].point2.moveTo([xValue(i), -0.01]);
		labels_n[i + 3].setText(xValue(i));
		labels_n[i + 3].setCoords([xValue(i), -0.02]);
	}
	
}

update_normal = board_normal.create('button', [2.5, 0.22, 'Update', 
	
	// If a new mean and standard deviation are provided, then we need to:
	//   - change the bounds on the x-axis
	//   - set the global mean_n and stdev_n variables
	//   - reset the positions of z1 and z2 on the x-axis so that they are accessible again
	
	function() {
		var cur_z1 = zScore(z1.X());
		var cur_z2 = zScore(z2.X());
		mean_n = Number(mean.Value());
		stdev_n = Number(stdev.Value());
		var x_min = xValue(-4);
		var x_max = xValue(4);
		//JSXSetBounds(board_normal, { xmin: x_min, xmax: x_max }, false);
		board_normal.setBoundingBox([x_min, 0.5, x_max, -0.5]);
		z1.moveTo([xValue(cur_z1), 0]);
		z2.moveTo([xValue(cur_z2), 0]);
		x1.rendNodeInput.value = xValue(cur_z1);
		x2.rendNodeInput.value = xValue(cur_z2);
		prob.rendNodeInput.value = currentProbability(cur_z1, cur_z2);
		updateAxisLabels();
		
	}
	
], { frozen: true });


shadedregionleft = board_normal.create('integral', 
	[[ function() { return xValue(-10000); }, function() { return z2.X(); }], normal_curve], shadeParam);
shadedregionleft.setAttribute({ visible: PTYPE == 'left' ? true : false });
shadedregionleft.curveLeft.setAttribute( { visible: false } );
shadedregionleft.curveRight.setAttribute( { visible: false } );

shadedregionright = board_normal.create('integral', 
	[[ function() { return z1.X(); }, function() { return xValue(10000); }], normal_curve], shadeParam);
shadedregionright.setAttribute({ visible: PTYPE == 'right' ? true : false });
shadedregionright.curveLeft.setAttribute( { visible: false } );
shadedregionright.curveRight.setAttribute( { visible: false } );

shadedregionbetween = board_normal.create('integral', 
	[[ function() { return z1.X(); }, function() { return z2.X(); }], normal_curve], shadeParam);
shadedregionbetween.setAttribute({ visible: PTYPE == 'between' ? true : false });
shadedregionbetween.curveLeft.setAttribute( { visible: false } );
shadedregionbetween.curveRight.setAttribute( { visible: false } );

cb_area = JSXCheckbox(board_normal, 1, -0.1, 'Calculate Area', true,
	function() {
		setCheckbox(cb_area, true);
		setCheckbox(cb_xvalue, false);
		
		cb_between.setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		cb_left.setAttribute( { disabled: false });
		cb_right.setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		
		prob.setAttribute( { disabled: true });
		
				
	}, { fontSize: 18, frozen: true });

cb_xvalue = JSXCheckbox(board_normal, 1, -0.16, 'Calculate x-Value', false,
	function() {
		setCheckbox(cb_xvalue, true);
		setCheckbox(cb_area, false);
		
		cb_between.setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		cb_left.setAttribute( { disabled: false });
		cb_right.setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		setCheckbox(cb_left, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_right, false);
		
		z1.setAttribute({ visible: false });
		z2.setAttribute({ visible: true });
		
		shadedregionleft.setAttribute({ visible: true });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1.rendNodeInput.value = '-Infinity';
		x1.setAttribute({ disabled: true });
	
		x2.rendNodeInput.value = z2.X().toFixed(2);
		x2.setAttribute({ disabled: false });
		
		prob.setAttribute({ disabled: false });
		
		PTYPE = 'left';
		
		
	}, { fontSize: 18, frozen: true });

cb_between = JSXCheckbox(board_normal, -3.6, -0.1, 'P(a < x < b)', true, 
	function() {
		setCheckbox(cb_between, true);
		setCheckbox(cb_left, false);
		setCheckbox(cb_right, false);

		shadedregionleft.setAttribute({ visible: false });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: true });
			
		z1.setAttribute({ visible: true });
		z2.setAttribute({ visible: true });
		
		x1.rendNodeInput.value = z1.X().toFixed(2);
		x1.setAttribute({ disabled: false });
		
		x2.rendNodeInput.value = z2.X().toFixed(2);
		x2.setAttribute({ disabled: false });
		
		prob.setAttribute({ disabled: true });
		
		PTYPE = 'between';
			
	}, { fontSize: 18, frozen: true });

cb_left = JSXCheckbox(board_normal, -3.6, -0.16, 'P(x < b)', false,
	function() {
		setCheckbox(cb_left, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_right, false);
		
		z1.setAttribute({ visible: false });
		z2.setAttribute({ visible: true });
		
		shadedregionleft.setAttribute({ visible: true });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1.rendNodeInput.value = '-Infinity';
		x1.setAttribute({ disabled: true });
	
		x2.rendNodeInput.value = z2.X().toFixed(2);
		x2.setAttribute({ disabled: false });
		
		prob.setAttribute({ disabled: true });
		
		PTYPE = 'left';
		
	}, { fontSize: 18, frozen: true });

cb_right = JSXCheckbox(board_normal, -3.6, -0.22, 'P(x > a)', false,
	function() {
		setCheckbox(cb_right, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_left, false);
		
		z1.setAttribute({ visible: true });
		z2.setAttribute({ visible: false });
		
		shadedregionleft.setAttribute({ visible: false });
		shadedregionright.setAttribute({ visible: true });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1.rendNodeInput.value = z1.X().toFixed(2);
		x1.setAttribute({ disabled: false });
		
		x2.rendNodeInput.value = '-Infinity';
		x2.setAttribute({ disabled: true });
		
		prob.setAttribute({ disabled: true });
		
		PTYPE = 'right';
	
	}, { fontSize: 18, frozen: true });


function currentProbability(x1, x2) { 
	
	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	
	if(cb_between.Value()) { 
		return Math.abs(normalcdf(x2) - normalcdf(x1)).toFixed(4);
	} else if(cb_left.Value()) {
		return normalcdf(x2).toFixed(4);
	} else if(cb_right.Value()) {
		return (1 - normalcdf(x1)).toFixed(4);
	} 

}

function changebounds() {

	var orgbounds = board_normal.getBoundingBox();
	var width = document.getElementById('standard_normal').clientWidth;
	var height = document.getElementById('standard_normal').clientHeight;

	board_normal.resizeContainer(width, height);
	board_normal.setBoundingBox(orgbounds, false);

	board_normal.update();	
		
}

board_normal.on('up', function() { changebounds() });



</script>


<script type='text/javascript'>
		
var board = JXG.JSXGraph.initBoard('t-distribution', {
		boundingbox: [-4,0.6,4,-0.2], 
      	showCopyright: false, 
      	showNavigation: true,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: true,
            needshift: false,
            eps: 0.1
        }		
    });
		
/*var displayboard = JXG.JSXGraph.initBoard('display', {
		boundingbox: [0,10,12,0], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false	
    });		
		
JXG.Options.board.minimizeReflow = 'all';		

BETWEEN = 0;  LEFT = 1;  RIGHT = 2;   TWOTAIL = 3;

df_txt = displayboard.create('text', [1, 3, 'Degrees of Freedom:']);	
df = displayboard.create('slider', [[1, 2.5], [7, 2.5], [1, 10, 68]], 
	{ snapwidth: 1,
	  precision: 0 });
df.on('drag', 
	function() {
		// automatically update the t_dist curve
		board.update();
	});
		
		
normal_curve = board.create('functiongraph', [ 
	function(x) { 
		return normalpdf(x); 
	} ], 
	{ 
		strokeWidth: 3, 
		fixed: true, 
		highlight: false 
	});
	
t_curve = board.create('functiongraph', [
	function(x) { 
		return tpdf(x, df.Value());
	}],
	{
		strokeWidth: 3,
		fixed: true,
		strokeColor: '#00bb00'
	});
	
hidden_axis = board.create('line', [[0, 0], [1, 0]], { visible: false });
x_axis = board.create('axis', [[0, 0], [1, 0]], 
	{ ticks: { majorHeight: 10, drawZero: true }});

cb = [];

cb[BETWEEN] = displayboard.create('checkbox', [1, 6, 'Between']);
cb[LEFT] = displayboard.create('checkbox', [1, 5.5, 'Left tailed']);
cb[RIGHT] = displayboard.create('checkbox', [1, 5, 'Right tailed']);
cb[TWOTAIL] = displayboard.create('checkbox', [1, 4.5, 'Two tailed']);

// Set the calculation to find the area between two z-scores by default
cb[BETWEEN].rendNodeCheckbox.checked = true;
cb[BETWEEN]._value = true;

// Just default stuff
probability = board.create('point', [0, 0], { visible: false });
z_area = board.create('point', [0, 0], { visible: false });
t_area = board.create('point', [0, 0], { visible: false });
z1_txt = board.create('point', [0, 0], { visible: false });
z2_txt = board.create('point', [0, 0], { visible: false });

function setupstuff() {

	board.removeObject(probability);
	displayboard.removeObject(z_area);
	displayboard.removeObject(t_area);
	displayboard.removeObject(z1_txt);
	displayboard.removeObject(z2_txt);


	probability = board.create('integral', [[
		function() { return z1.X(); }, 
		function() { return z2.X(); }], 
		t_curve], 
		{ 
			color: '#00ff00', 
			fillOpacity: 0.3, 
			withLabel: false,
			fixed: true,
			highlight: false 
		});
	probability.curveLeft.setAttribute( { visible: false } );
	probability.curveRight.setAttribute( { visible: false } );

	z_area = displayboard.create('text', [1, 8, 
		function() { 
			return 'Area = ' + currentZProbability(z1.X(), z2.X()); 
		}], { fontSize: 18 });
		
	t_area = displayboard.create('text', [1, 7.5, 
		function() { 
			return 'Area = ' + currentTProbability(z1.X(), z2.X(), df.Value()); 
		}], { fontSize: 18 });	
		
	z1_txt = displayboard.create('text', [2, 7, 
		function() { 
			if(z1.X() < -9.9) {
				return 'z1 = -&#x221e;';
			} else if(z1.X() > 9.9) {
				return 'z1 = +&#x221e;';
			} else return 'z1 = ' + z1.X().toFixed(2); 
		}], { fontSize: 18 });

	z2_txt = displayboard.create('text', [2, 6.5, 
		function() { 
			if(z2.X() < -9.9) {
				return 'z2 = -&#x221e;';
			} else if(z2.X() > 9.9) {
				return 'z2 = +&#x221e;';
			} else
			return 'z2 = ' + z2.X().toFixed(2); 
		}], { fontSize: 18 });

}

z1 = board.create('glider', [-2, 0, hidden_axis], { name: 'z1' });
z1.on('drag', 
	function() { 
		displayboard.update(); 
	});

z2 = board.create('glider', [2, 0, hidden_axis], { name: 'z2' });
z2.on('drag', 
	function() { 
		displayboard.update(); 
	}); 
	
setupstuff();

function currentZProbability(x1, x2) { 
	if(cb[BETWEEN].Value()) { 
		return Math.abs(normalcdf(x2) - normalcdf(x1)).toFixed(4);
	} else if(cb[LEFT].Value()) {
		return normalcdf(x2).toFixed(4);
	} else if(cb[RIGHT].Value()) {
		return (1 - normalcdf(x1)).toFixed(4);
	} else if(cb[TWOTAIL].Value()) {
	return (1 - Math.abs(normalcdf(x2) - normalcdf(x1))).toFixed(4);
	}
}

function currentTProbability(x1, x2, df) { 
	if(cb[BETWEEN].Value()) { 
		return Math.abs(tcdf(x2, df) - tcdf(x1, df)).toFixed(4);
	} else if(cb[LEFT].Value()) {
		return tcdf(x2, df).toFixed(4);
	} else if(cb[RIGHT].Value()) {
		return (1 - tcdf(x1, df)).toFixed(4);
	} else if(cb[TWOTAIL].Value()) {
	return (1 - Math.abs(tcdf(x2, df) - tcdf(x1, df))).toFixed(4);
	}
}

function update() {

	var orgbounds = board.getBoundingBox();
	var width = document.getElementById('jxgbox').clientWidth;
	var height = document.getElementById('jxgbox').clientHeight;

	board.resizeContainer(width, height);
	board.setBoundingBox(orgbounds, false);

	board.update();	
		
}

cb_ZoomSquare = displayboard.create('checkbox', [1, 9, 'Zoom Square']);

slider_horiz_zoom = displayboard.create('slider', [[1, 2], [7, 2], [-10, 1, 10]]);
horiz_zoom_label = displayboard.create('text', [9, 2, 'x zoom']);
horiz_zoom_level = 1;
slider_horiz_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_horiz_zoom.Value();
		if(horiz_zoom_level > newfactor) {
			orgbounds[0] = orgbounds[0] * 1.1;
			orgbounds[2] = orgbounds[2] * 1.1;
		} else {
			orgbounds[0] = orgbounds[0] / 1.1;
			orgbounds[2] = orgbounds[2] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		horiz_zoom_level = newfactor;
	});

slider_vert_zoom = displayboard.create('slider', [[1, 1.5], [7, 1.5], [-10, 1, 10]]);
vert_zoom_label = displayboard.create('text', [9, 1.5, 'y zoom']);
vert_zoom_level = 1;
slider_vert_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_vert_zoom.Value();
		if(vert_zoom_level > newfactor) {
			orgbounds[1] = orgbounds[1] * 1.1;
			orgbounds[3] = orgbounds[3] * 1.1;
		} else {
			orgbounds[1] = orgbounds[1] / 1.1;
			orgbounds[3] = orgbounds[3] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		vert_zoom_level = newfactor;
	});	

// All the things that have to do with checkboxes

function setcbtrue(box) {
	cb[BETWEEN].rendNodeCheckbox.checked = false;
	cb[LEFT].rendNodeCheckbox.checked = false;
	cb[RIGHT].rendNodeCheckbox.checked = false;
	cb[TWOTAIL].rendNodeCheckbox.checked = false;
	cb[BETWEEN]._value = false;
	cb[LEFT]._value = false;
	cb[RIGHT]._value = false;
	cb[TWOTAIL]._value = false;
	cb[box].rendNodeCheckbox.checked = true;
	cb[box]._value = true;
}

JXG.addEvent(cb[BETWEEN].rendNodeCheckbox, 'change', 
	function() {
		setcbtrue(BETWEEN);
		
		board.removeObject(z1);
		board.removeObject(z2);
		
		z1 = board.create('glider', [-2, 0, hidden_axis], { name: 'z1' });
		z1.on('drag', function() { displayboard.update(); });

		z2 = board.create('glider', [2, 0, hidden_axis], { name: 'z2' });
		z2.on('drag', function() { displayboard.update(); }); 
		
		setupstuff();
		
		board.update();
		displayboard.update();
		
    }, cb[BETWEEN]);
	
JXG.addEvent(cb[LEFT].rendNodeCheckbox, 'change', 
	function() {
		setcbtrue(LEFT);

		board.removeObject(z1);
		board.removeObject(z2);

		z1 = board.create('glider', [-10, 0, hidden_axis], { name: 'z1', visible: false });
		z1.on('drag', function() { displayboard.update(); });

		z2 = board.create('glider', [2, 0, hidden_axis], { name: 'z2' });
		z2.on('drag', function() { displayboard.update(); }); 
		
		setupstuff();

		board.update();
		displayboard.update();
    }, cb[LEFT]);	

JXG.addEvent(cb[RIGHT].rendNodeCheckbox, 'change', 
	function() {
		setcbtrue(RIGHT);

		board.removeObject(z1);
		board.removeObject(z2);

		z1 = board.create('glider', [-2, 0, hidden_axis], { name: 'z1' });
		z1.on('drag', function() { displayboard.update(); });

		z2 = board.create('glider', [10, 0, hidden_axis], { name: 'z2', visible: false });
		z2.on('drag', function() { displayboard.update(); }); 
		
		setupstuff();

		board.update();
		displayboard.update();
    }, cb[RIGHT]);	

JXG.addEvent(cb[TWOTAIL].rendNodeCheckbox, 'change', 
	function() {
		setcbtrue(TWOTAIL);

		board.removeObject(z1);
		board.removeObject(z2);

		z1 = board.create('glider', [-2, 0, hidden_axis], { name: 'z1' });
		z1.on('drag', function() { displayboard.update(); });

		z2 = board.create('glider', [2, 0, hidden_axis], { name: 'z2' });
		z2.on('drag', function() { displayboard.update(); }); 
		
		setupstuff();

		board.update();
		displayboard.update();
    }, cb[TWOTAIL]);		*/
	
</script>


</body>
</html>