<!DOCTYPE html>
<html lang = "en-US">

<!--

TODO:

  - Update distributions to calculate from all input boxes
  - Make all input boxes able to do input
  - remove display texts in F and Chi-2 Distributions
  - Update normal and t distribution to remove boxes for P( x < a ) and P (x > a)
  - switch to math.eval() instead of Math.eval()

  - fix dropdown menus to show up below the menu bar
  - add extra output to confidence intervals
  - Do error checking in all areas
  - add 'about' button and 'help' button to calc screen

-->

<head>

	<title>Statistics Calculator</title>
	<meta charset="utf-8">

	<link rel='stylesheet' type='text/css' href='./js/jsxgraph.css' />
	<script src='./js/jsxgraphcore.js' type='text/javascript'></script>
	<script src='./js/MathFunctions.js' type='text/javascript'></script>
	<script src='./js/math.min.js' type='text/javascript'></script>
	<script src='./js/helpers.js' type='text/javascript'></script>
	<script src="./js/jstat.min.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	<style>
		body {
			font-family: Arial;
		}

		/* Style the tab */
		.tab {
			overflow: hidden;
			border: 1px solid #ccc;
			background-color: #f1f1f1;
			width: 540px;
		}

		/* Style the buttons that are used to open the tab content */
		.tab button {
			background-color: inherit;
			float: left;
			border: none;
			outline: none;
			cursor: pointer;
			padding: 14px 10px;
			transition: 0.3s;
			text-decoration: none;
		}

		/* Change background color of buttons on hover */
		.tab button:hover {
			background-color: #ddd;
		}

		/* Create an active/current tablink class */
		.tab button.active {
			background-color: #ccc;
		}

		/* Style the tab content */
		.tabcontent {
			display: none;
			padding: 6px 12px;
			border: 1px solid #ccc;
			border-top: none;
		}

		.dropdown {
			float: left;
			overflow: hidden;
		}

		.dropdown .dropbtn {
			border: none;
			outline: none;
			color: black;
			padding: 14px 16px;
			background-color: inherit;
			font-family: inherit;
			margin: 0;
		}

		.dropdown-content {
			display: none;
			position: absolute;
			background-color: #f9f9f9;
			min-width: 160px;
			box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
			z-index: 10;
		}

		.dropdown-content button {
			float: none;
			color: black;
			padding: 12px 16px;
			text-decoration: none;
			display: block;
			text-align: left;
		}

		.dropdown-content button:hover {
			background-color: #ddd;
		}

		.dropdown:hover .dropdown-content {
			display: block;
		}

		.btn-group input {
			background-color: #e1e1e1; /* Green background */
			border: 1px solid black; /* Green border */
			color: black; /* White text */
			padding: 10px 6px; /* Some padding */
			cursor: pointer; /* Pointer/hand icon */
			width: 50%; /* Set a width if needed */
			display: block; /* Make the buttons appear below each other */
			text-align:center
		}

		.btn-group button {
			background-color: #4CAF50; /* Green background */
			border: 1px solid green; /* Green border */
			color: white; /* White text */
			padding: 10px 24px; /* Some padding */
			cursor: pointer; /* Pointer/hand icon */
			width: 50%; /* Set a width if needed */
			display: block; /* Make the buttons appear below each other */
		}

		.btn-group button:not(:last-child) {
			border-bottom: none; /* Prevent double borders */
		}

		/* Add a background color on hover */
		.btn-group button:hover {
			background-color: #3e8e41;
		}

	</style>

</head>

<body>

<h1>Statistics Calculator</h1>


<!-- Tab links -->
<div class="tab">
	<button class="tablinks" id="defaultOpen" onclick="openTool(event, 'calculation')">Calc</button>
	<button class="tablinks" onclick="openTool(event, 'list-editor')">List Editor</button>
	<div class="dropdown">
			<button class="dropbtn">Distributions<i class="fa fa-caret-down"></i></button>
			<div class="dropdown-content">
				<button class="tablinks" onclick="openTool(event, 'standard_normal')">Normal</button>
				<button class="tablinks" onclick="openTool(event, 't-distribution')">Student's T</button>
				<button class="tablinks" onclick="openTool(event, 'chi-distribution')">&Chi;<sup>2</sup></button>
				<button class="tablinks" onclick="openTool(event, 'f-distribution')">F</button>
				<button class="tablinks" onclick="openTool(event, 'binomial-distribution')">Binomial</button>
			</div>
		</div>
	<div class="dropdown">
		<button class="dropbtn">Estimates<i class="fa fa-caret-down"></i></button>
		<div class="dropdown-content">
			<button class="tablinks" onclick="openTool(event, 'z-interval')">Z Confidence Interval of the Mean</button>
			<button class="tablinks" onclick="openTool(event, 't-interval')">T Confidence Interval of the Mean</button>
			<button class="tablinks" onclick="openTool(event, 'prop-interval')">Z Confidence Interval for a Proportion</button>
			<button class="tablinks" onclick="openTool(event, 'z-int_2samp')">Z Confidence Interval of Two Means</button>
			<button class="tablinks" onclick="openTool(event, 't-int_2samp')">T Confidence Interval of Two Means</button>
			<button class="tablinks" onclick="openTool(event, 'prop-int_2samp')">Z Confidence Interval of Two Proportions</button>
		</div>
	</div>
	<div class="dropdown">
		<button class="dropbtn">Tests<i class="fa fa-caret-down"></i></button>
		<div class="dropdown-content">
			<button class="tablinks" onclick="openTool(event, 'z-test')">Z Test of a Mean</button>
			<button class="tablinks" onclick="openTool(event, 't-test')">T Test of a Mean</button>
			<button class="tablinks" onclick="openTool(event, 'prop-test')">Z Test of a Proportion</button>
			<button class="tablinks" onclick="openTool(event, 'z-test_2samp')">Z Test of Two Means</button>
			<button class="tablinks" onclick="openTool(event, 't-test_2samp')">T Test of Two Means</button>
			<button class="tablinks" onclick="openTool(event, 'prop-test_2samp')">Z Test of Two Proportions</button>
		</div>
	</div>
</div>

<!-- Tab content -->
<div id="standard_normal" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="t-distribution" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="chi-distribution" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="f-distribution" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="binomial-distribution" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="calculation" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="list-editor" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="z-interval" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="t-interval" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="prop-interval" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="z-int_2samp" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="t-int_2samp" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="prop-int_2samp" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="z-test" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="t-test" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="prop-test" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="z-test_2samp" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="t-test_2samp" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="prop-test_2samp" class="jxgbox" style="width:540px; height:540px;"></div>

<script>
function openTool(evt, tool) {
	// Declare all variables
	var i, tabcontent, tablinks;

	// Get all elements with class="tabcontent" and hide them
	tabcontent = document.getElementsByClassName("jxgbox");
	for (i = 0; i < tabcontent.length; i++) {
		tabcontent[i].style.display = "none";
	}

	tabcontent = document.getElementsByClassName("btn-group");
	for (i = 0; i < tabcontent.length; i++) {
		tabcontent[i].style.display = "none";
	}

	// Get all elements with class="tablinks" and remove the class "active"
	tablinks = document.getElementsByClassName("tablinks");
	for (i = 0; i < tablinks.length; i++) {
		tablinks[i].className = tablinks[i].className.replace(" active", "");
	}

	// Show the current tab, and add an "active" class to the button that opened the tab
	document.getElementById(tool).style.display = "block";
	evt.currentTarget.className += " active";
}
document.getElementById("defaultOpen").click();
</script>


<script>
	// Define global variables

	var shadeParam = {
		color: '#0000FF',
		fillOpacity: 0.4,
		withLabel: false,
		fixed: true,
		highlight: false,
		curveLeft: { visible: false },
		curveRight: { visible: false },
	};

	var textParam = {
		fontSize: 18,
		frozen: true,
		fixed: true,
		highlight: false,
		anchorY: 'top'
	};

	var inputParam = {
		fontSize: 18,
		cssStyle: 'width: 100px',
		frozen: true,
		fixed: true,
		anchorY: 'top'
	}

	var buttonParam = {
		frozen: true,
		anchorY: 'top'
	}

	var PTYPE = 'between';

	var BETWEEN = 0;
	var LEFT = 1;
	var RIGHT = 2;
	var EQUAL = 3;

	var LEFTTAIL = 0;
	var RIGHTTAIL = 1;
	var TWOTAIL = 2;

	var MAXLISTSIZE = 50;

	var PRECISION = 9;

</script>


<!--////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////// List Editor /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var list_board = JXG.JSXGraph.initBoard('list-editor', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: true,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: true
		}
    });

var list_title1 = list_board.create('text', [1.5, 9.5, 'L1'], { fixed: true, fontSize: 18 });
var list_title2 = list_board.create('text', [3.5, 9.5, 'L2'], { fixed: true, fontSize: 18 });
var list_title2 = list_board.create('text', [5.5, 9.5, 'L3'], { fixed: true, fontSize: 18 });

var list_clear_button1 = list_board.create('button', [7.5, 8, 'Clear L1',
	function() {
		for(var i = 0; i < list1_data.length; i++) {
			list1_data[i].rendNodeInput.value = "";
		}
	}]);

var list_clear_button2 = list_board.create('button', [7.5, 7.5, 'Clear L2',
	function() {
		for(var i = 0; i < list2_data.length; i++) {
			list2_data[i].rendNodeInput.value = '';
		}
	}]);

var list_clear_button2 = list_board.create('button', [7.5, 7, 'Clear L3',
	function() {
		for(var i = 0; i < list2_data.length; i++) {
			list3_data[i].rendNodeInput.value = '';
		}
	}]);

var list_formula = list_board.create('input', [7.5, 5.5, '', ''], { fontSize: 18, cssStyle: 'width: 100px', fixed: true });
list_formula.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		list_calculate();
	}
};

var list_calculate_button = list_board.create('button', [7.5, 4.5, 'Apply Formula', function() { list_calculate(); }], { fixed : true });

function list_calculate() {

	var formula = list_formula.rendNodeInput.value.toLowerCase();

	if (formula.startsWith('l1')) {

		var parts = formula.split('=');
		for(var i = 0; i < list1_data.length; i++) {
			if (list2_data[i].rendNodeInput.value !== '') {
				var val2 = evalstr(list2_data[i].rendNodeInput.value);
				var val3 = evalstr(list3_data[i].rendNodeInput.value);
				var scope = { l2: val2, l3: val3 };
				list1_data[i].rendNodeInput.value = round(math.eval(formula, scope), PRECISION);
			}
		}

	} else if (formula.startsWith('l2')) {

		var parts = formula.split('=');
		for(var i = 0; i < list2_data.length; i++) {
			if (list1_data[i].rendNodeInput.value !== '') {
				var val1 = evalstr(list1_data[i].rendNodeInput.value);
				var val3 = evalstr(list3_data[i].rendNodeInput.value);
				var scope = { l1: val1, l3: val3 };
				list2_data[i].rendNodeInput.value = round(math.eval(formula, scope), PRECISION);
			}
		} 
	} else if (formula.startsWith('l3')) {

		var parts = formula.split('=');
		for(var i = 0; i < list3_data.length; i++) {
			if (list1_data[i].rendNodeInput.value !== '') {
				var val1 = evalstr(list1_data[i].rendNodeInput.value);
				var val2 = evalstr(list2_data[i].rendNodeInput.value);
				var scope = { l1: val1, l2: val2 };
				list3_data[i].rendNodeInput.value = round(math.eval(formula, scope), PRECISION);
			}
		}

	} else {
		alert('Error in list formula. The formula must begin with L1=, L2=, or L3= ');
	}

}

var list1_data = [];
var list2_data = [];
var list3_data = [];

// These are done in groups to make the tab order more sensible
for (var i = 0; i < MAXLISTSIZE; i++) {
	list1_data[i] = list_board.create('input', [0.5, 9 - i * 0.5, '', ''],
			{ cssStyle: 'width: 100px', fixed: true, fontSize: 18 });
}

for(var i = 0; i < MAXLISTSIZE; i++) {
	list2_data[i] = list_board.create('input', [2.5, 9 - i * 0.5, '', ''],
			{ cssStyle: 'width: 100px', fixed: true, fontSize: 18 });
}

for(var i = 0; i < MAXLISTSIZE; i++) {
	list3_data[i] = list_board.create('input', [4.5, 9 - i * 0.5, '', ''],
			{ cssStyle: 'width: 100px', fixed: true, fontSize: 18 });
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	//////////////////// Confidence Interval for the Mean (Normal) /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var zint_board = JXG.JSXGraph.initBoard('z-interval', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
			enabled: false
		},
		pan: {
			enabled: false
		}
    });

var zint_mean = zint_board.create('input', [0.5, 9, '', '<i>x&#772;</i> = '], inputParam);
zint_mean.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint_docalc(); } };

var zint_stdev = zint_board.create('input', [0.5, 8, '', '<i>&sigma;</i> = '], inputParam);
zint_stdev.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint_docalc(); } };

var zint_n = zint_board.create('input', [0.5, 7, '', '<i>n</i> = '], inputParam);
zint_n.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint_docalc(); } };

var zint_list = zint_board.create('input', [0.5, 6, 'L1', 'List: '], inputParam);
zint_list.setAttribute( { disabled: true, strokeColor: 'lightgray' });
zint_list.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint_docalc(); } };

var zint_c = zint_board.create('input', [0.5, 5, '', '<i>c</i> = '], inputParam);
zint_c.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint_docalc(); } };

var zint_interval = zint_board.create('text', [0.5, 4, ''], textParam);

var zint_cb_stats = JSXCheckbox(zint_board, 6, 8, 'Input from Stats', true,
	function() {
		setCheckbox(zint_cb_stats, true);
		setCheckbox(zint_cb_data, false);
		zint_list.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		zint_mean.setAttribute({ disabled: false, strokeColor: 'black' });
		zint_n.setAttribute({ disabled: false, strokeColor: 'black' });
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var zint_cb_data = JSXCheckbox(zint_board, 6, 7, 'Input from Data', false,
	function() {
		setCheckbox(zint_cb_stats, false);
		setCheckbox(zint_cb_data, true);
		zint_list.setAttribute({ disabled: false, strokeColor: 'black' });
		zint_mean.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		zint_n.setAttribute({ disabled: true, strokeColor: 'lightgray' });
	}, { fontSize: 18, anchorY: 'top', frozen: true });

var zint_calculate = zint_board.create('button', [6, 6, 'Calculate',
	function() { zint_docalc(); }], buttonParam);

function zint_docalc() {

	var c = evalstr(zint_c.rendNodeInput.value);
	var stdev = evalstr(zint_stdev.rendNodeInput.value);
	var n = 0, mean = 0;

	if(zint_cb_stats.Value()) {
		n = evalstr(zint_n.rendNodeInput.value);
		mean = evalstr(zint_mean.rendNodeInput.value);
	} else {
		var list = zint_list.rendNodeInput.value;
		if (list.includes(',')) {
			var lists = list.split(',');
			var xdata = getRawData(getListByName(lists[0]));
			var fdata = getRawData(getListByName(lists[1]));
			n = xdata.length;
			mean = stats.wmean(xdata, fdata);
		} else {
			xdata = getRawData(getListByName(list));
			mean = stats.mean(xdata);
			n = xdata.length
		}
	}

	if (isNaN(c) || isNaN(n) || isNaN(mean) || isNaN(stdev)) {
		zint_interval.setText('Oops! All inupt values must be either numeric or<br/>'
			+ '&nbsp;&nbsp;&nbsp;mathematical expressions that evalaute to numbers.<br/><br/>'
			+ 'One or more value is either missing or invalid.');
	} else if (n <= 0) {
		zint_interval.setText('Oops! The sample size, <i>n</i>, must be greater than zero.');
	} else if ((c < 0) || (c >= 1)) {
		zint_interval.setText('Oops! The level of confidence, <i>c</i>, must be a value<br/>'
			+ '&nbsp;&nbsp;&nbsp; greater than or equal to zero and less than one.');
	} else {

		var z = Math.abs(jStat.normal.inv((1 - c) / 2, 0, 1));
		var me = z * stdev / sqrt(n);
		var lb = mean - me;
		var ub = mean + me;

		zint_interval.setText(
			'(' + round(lb, PRECISION) + ', '
			+ round(ub, PRECISION) + ')<br/>'
			+ 'z<sub>c</sub> = ' + round(z, PRECISION) + '<br/>'
			+ 'E = ' + round(me, PRECISION) + '<br/><br/>'
			+ 'x&#772; = ' + round(mean, PRECISION) + '<br/>'
			+ '&sigma; = ' + round(stdev, PRECISION) + '<br/>'
			+ 'n = ' + n);
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	///////////////////////// Confidence Interval for the Mean (T) /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var tint_board = JXG.JSXGraph.initBoard('t-interval', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var tint_mean = tint_board.create('input', [0.5, 9, '', '<i>x&#772;</i> = '], inputParam);
tint_mean.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint_docalc(); } };

var tint_stdev = tint_board.create('input', [0.5, 8, '', '<i>s</i> = '], inputParam);
tint_stdev.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint_docalc(); } };

var tint_n = tint_board.create('input', [0.5, 7, '', '<i>n</i> = '], inputParam);
tint_n.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint_docalc(); } };

var tint_list = tint_board.create('input', [0.5, 6, 'L1', 'List: '], inputParam);
tint_list.setAttribute({ disabled: true, strokeColor: 'lightgray' });
tint_list.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint_docalc(); } };

var tint_c = tint_board.create('input', [0.5, 5, '', '<i>c</i> = '], inputParam);
tint_c.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint_docalc(); } };

var tint_interval = tint_board.create('text', [0.5, 4, ''], textParam);

var tint_cb_stats = JSXCheckbox(tint_board, 6, 8, 'Input from Stats', true,
	function() {
		setCheckbox(tint_cb_stats, true);
		setCheckbox(tint_cb_data, false);
		tint_list.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		tint_mean.setAttribute({ disabled: false, strokeColor: 'black' });
		tint_stdev.setAttribute({ disabled: false, strokeColor: 'black' });
		tint_n.setAttribute({ disabled: false, strokeColor: 'black' });
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var tint_cb_data = JSXCheckbox(tint_board, 6, 7, 'Input from Data', false,
	function() {
		setCheckbox(tint_cb_stats, false);
		setCheckbox(tint_cb_data, true);
		tint_list.setAttribute({ disabled: false, strokeColor: 'black' });
		tint_mean.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		tint_n.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		tint_stdev.setAttribute({ disabled: true, strokeColor: 'lightgray' });
	}, { fontSize: 18, anchorY: 'top', frozen: true });

var tint_calculate_button = tint_board.create('button', [6, 6, 'Calculate',
	function() { tint_docalc(); }], buttonParam);

function tint_docalc() {

	var c = evalstr(tint_c.rendNodeInput.value);
	var n = 0, stdev = 0, mean = 0;

	if(tint_cb_stats.Value()) {
		n = evalstr(tint_n.rendNodeInput.value);
		mean = evalstr(tint_mean.rendNodeInput.value);
		stdev = evalstr(tint_stdev.rendNodeInput.value);
	} else {
		var list = tint_list.rendNodeInput.value;
		if (list.includes(',')) {
			var lists = list.split(',');
			var xdata = getRawData(getListByName(lists[0]));
			var fdata = getRawData(getListByName(lists[1]));
			n = xdata.length;
			mean = stats.wmean(xdata, fdata);
			std = stats.wstdev(xdata, fdata);
		} else {
			xdata = getRawData(getListByName(list));
			mean = stats.mean(xdata);
			stdev = stats.stdev(xdata);
			n = xdata.length
		}
	}

	if(isNaN(c) || isNaN(n) || isNaN(mean) || isNaN(stdev)) {
		tint_interval.setText('Oops! All inupt values must be either numeric or<br/>'
			+ '&nbsp;&nbsp;&nbsp;mathematical expressions that evalaute to numbers.<br/><br/>'
			+ 'One or more value is either missing or invalid.');
	} else if (n <= 0) {
		tint_interval.setText('Oops! The sample size, <i>n</i>, must be greater than zero.');
	} else if ((c < 0) || (c >= 1)) {
		tint_interval.setText('Oops! The level of confidence, <i>c</i>, must be a value<br/>'
			+ '&nbsp;&nbsp;&nbsp; greater than or equal to zero and less than one.');
	} else {
		var t = Math.abs(jStat.studentt.inv((1 - c) / 2, n - 1));
		var me = t * stdev / sqrt(n);
		var lb = mean - me;
		var ub = mean + me;

		tint_interval.setText(
			'(' + round(lb, PRECISION) + ', '
			+ round(ub, PRECISION) + ')<br/>'
			+ 't<sub>c</sub> = ' + round(t, PRECISION) + '<br/>'
			+ 'E = ' + round(me, PRECISION) + '<br/><br/>'
			+ 'x&#772; = ' + round(mean, PRECISION) + '<br/>'
			+ 's = ' + round(stdev, PRECISION) + '<br/>'
			+ 'n = ' + n);
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	///////////////////////// Confidence Interval for a Proportion /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var pint_board = JXG.JSXGraph.initBoard('prop-interval', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var pint_x = pint_board.create('input', [0.5, 9, '', '<i>x</i> = '], inputParam);
pint_x.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { pint_docalc(); } };

var pint_n = pint_board.create('input', [0.5, 8, '', '<i>n</i> = '], inputParam);
pint_n.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { pint_docalc(); } };

var pint_c = pint_board.create('input', [0.5, 7, '', '<i>c</i> = '], inputParam);
pint_c.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { pint_docalc(); } };

var pint_interval = pint_board.create('text', [0.5, 6, ''], textParam);

var pint_calculate = pint_board.create('button', [6, 8, 'Calculate',
	function() { pint_docalc(); }], buttonParam);

function pint_docalc() {

	var c = evalstr(pint_c.rendNodeInput.value);
	var x = evalstr(pint_x.rendNodeInput.value);
	var n = evalstr(pint_n.rendNodeInput.value);
	var p = x / n;
	var q = 1 - p;

	var z = Math.abs(jStat.normal.inv((1 - c) / 2, 0, 1));
	var me = z * sqrt(p * q / n);
	var lb = p - me;
	var ub = p + me;

	if(n < x) {
		pint_interval.setText('Oops! The sample size <i>n</i> must be larger than <i>x</i>.');
	} else if ((c < 0) || (c > 1)) {
		pint_interval.setText('Oops! The level of confidence, <i>c</i>, must be a value<br/>'
			+ '&nbsp;&nbsp;&nbsp; greater than or equal to zero and less than one.');
	} else if (isNaN(c) || isNaN(x) || isNaN(n)) {
		pint_interval.setText('One or more input values is not a number,<br/>&nbsp;&nbsp;&nbsp;please check your input.');
	} else {
		pint_interval.setText(
			'(' + round(lb, PRECISION)
			+ ', ' + round(ub, PRECISION) + ')<br/>'
			+ 'z<sub>c</sub> = ' + round(z, PRECISION) + '<br/><br/>'
			+ 'p&#770; = ' + round(p, PRECISION) + '<br/>'
			+ 'E = ' + round(me, PRECISION));
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	/////////////////// Confidence Interval for Two Means (Normal) /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var zint2_board = JXG.JSXGraph.initBoard('z-int_2samp', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var zint2_mean1 = zint2_board.create('input', [0.5, 9, '', '<i>x&#772;<sub>1</sub></i> = '], inputParam);
zint2_mean1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_std1 = zint2_board.create('input', [0.5, 8, '', '<i>&sigma;<sub>1</sub></i> = '], inputParam);
zint2_std1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_n1 = zint2_board.create('input', [0.5, 7, '', '<i>n<sub>1</sub></i> = '], inputParam);
zint2_n1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_list1 = zint2_board.create('input', [0.5, 6, 'L1', '<i>List<sub>1</sub></i>: '], inputParam);
zint2_list1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
zint2_list1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_mean2 = zint2_board.create('input', [4, 9, '', '<i>x&#772;<sub>2</sub></i> = '], inputParam);
zint2_mean2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_std2 = zint2_board.create('input', [4, 8, '', '<i>&sigma;<sub>2</sub></i> = '], inputParam);
zint2_std2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_n2 = zint2_board.create('input', [4, 7, '', '<i>n<sub>2</sub></i> = '], inputParam);
zint2_n2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_list2 = zint2_board.create('input', [4, 6, 'L2', '<i>List<sub>2</sub></i>: '], inputParam);
zint2_list2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
zint2_list2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_c = zint2_board.create('input', [0.5, 5, '', '<i>c</i> = '], inputParam);
zint2_c.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { zint2_docalc(); } };

var zint2_interval = zint2_board.create('text', [0.5, 4, ''], textParam);

var zint2_cb_stats = JSXCheckbox(zint2_board, 7.5, 8.5, 'Statistics', true,
	function() {
		setCheckbox(zint2_cb_stats, true);
		setCheckbox(zint2_cb_data, false);
		zint2_list1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		zint2_mean1.setAttribute({ disabled: false, strokeColor: 'black' });
		zint2_n1.setAttribute({ disabled: false, strokeColor: 'black' });
		zint2_list2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		zint2_mean2.setAttribute({ disabled: false, strokeColor: 'black' });
		zint2_n2.setAttribute({ disabled: false, strokeColor: 'black' });
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var zint2_cb_data = JSXCheckbox(zint2_board, 7.5, 8, 'Data', false,
	function() {
		setCheckbox(zint2_cb_stats, false);
		setCheckbox(zint2_cb_data, true);
		zint2_list1.setAttribute({ disabled: false, strokeColor: 'black' });
		zint2_mean1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		zint2_n1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		zint2_list2.setAttribute({ disabled: false, strokeColor: 'black' });
		zint2_mean2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		zint2_n2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
	}, { fontSize: 18, anchorY: 'top', frozen: true });

var zint2_calculate = zint2_board.create('button', [7.5, 7, 'Calculate',
	function() { zint2_docalc(); }], buttonParam);

function zint2_docalc() {

	var c = evalstr(zint2_c.rendNodeInput.value);
	var std1 = evalstr(zint2_std1.rendNodeInput.value);
	var std2 = evalstr(zint2_std2.rendNodeInput.value);
	var n1 = Number.NaN, n2 = Number.NaN, mean1 = Number.NaN, mean2 = Number.NaN;
	var listerror = false;

	if(zint2_cb_stats.Value()) {
		n1 = evalstr(zint2_n1.rendNodeInput.value);
		mean1 = evalstr(zint2_mean1.rendNodeInput.value);
		n2 = evalstr(zint2_n2.rendNodeInput.value);
		mean2 = evalstr(zint2_mean2.rendNodeInput.value);
	} else {
		var list1 = zint2_list1.rendNodeInput.value;
		var list2 = zint2_list2.rendNodeInput.value;
		var xdata1 = getRawData(getListByName(list1));
		var xdata2 = getRawData(getListByName(list2));
		if((xdata1 !== undefined) && (xdata2 !== undefined)) {
			n1 = xdata1.length;
			n2 = xdata2.length;
			mean1 = stats.mean(xdata1);
			mean2 = stats.mean(xdata2);
		} else {
			listerror = true;
		}
	}

	if(isNaN(c) || isNaN(std1) || isNaN(std2) || isNaN(n1) || isNaN(n2) || isNaN(mean1) || isNaN(mean2)) {
		if(listerror) {
			zint2_interval.setText('One of your lists was not found,<br/>&nbsp;&nbsp;&nbsp;try using L1 or L2 as the name of your lists.');
		} else {
			zint2_interval.setText('One or more input variables is blank or invalid.<br/>&nbsp;&nbsp;&nbsp;Please check your input.');
		}
	} else if (n1 < 0 || n2 < 0) {
		zint2_interval.setText('Oops! The sample sizes must be positive numbers.');
	} else if (c < 0 || c >= 1) {
		zint2_interval.setText('Oops! The level of confidence, <i>c</i>, must be a value<br/>'
			+ '&nbsp;&nbsp;&nbsp; greater than or equal to zero and less than one.');
	} else {

		var z = Math.abs(jStat.normal.inv((1 - c) / 2, 0, 1));
		var me = z * sqrt( sqr(std1) / n1 + sqr(std2) / n2);
		var center = mean1 - mean2;
		var lb = center - me;
		var ub = center + me;

		zint2_interval.setText(
			'(' + round(lb, PRECISION) + ', '
			+ round(ub, PRECISION) + ')<br/><br/>'
			+ 'z<sub>c</sub> = ' + round(z, PRECISION) + '<br/>'
			+ 'E = ' + round(me, PRECISION) + '<br/><br/>'
			+ '<table>'
			+ '<tr>'
			+ '<td style="width:160px"><i>x&#772;<sub>1</sub></i> = ' + round(mean1, PRECISION) + '</td>'
			+ '<td style="width:160px"><i>&sigma;<sub>1</sub></i> = ' + round(std1, PRECISION) + '</td>'
			+ '<td><i>n<sub>1</sub></i> = ' + n1 + '</td>'
			+ '</tr>'
			+ '<tr>'
			+ '<td><i>x&#772;<sub>2</sub></i> = ' + round(mean2, PRECISION) + '</td>'
			+ '<td><i>&sigma;<sub>2</sub></i> = ' + round(std2, PRECISION) + '</td>'
			+ '<td><i>n<sub>2</sub></i> = ' + n2 + '</td>'
			+ '</tr>'
			+ '<tr>'
			+ '<td><i>x&#772;<sub>1</sub></i> - <i>x&#772;<sub>2</sub></i> = ' + round(center, PRECISION) + '</td>'
			+ '</tr>'
			+ '</table>'
		);
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	//////////////////////// Confidence Interval for Two Means (T) /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var tint2_board = JXG.JSXGraph.initBoard('t-int_2samp', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });


var tint2_mean1 = tint2_board.create('input', [0.5, 9, '', '<i>x&#772;<sub>1</sub></i> = '], inputParam);
tint2_mean1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_std1 = tint2_board.create('input', [0.5, 8, '', '<i>s<sub>1</sub></i> = '], inputParam);
tint2_std1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_n1 = tint2_board.create('input', [0.5, 7, '', '<i>n<sub>1</sub></i> = '], inputParam);
tint2_n1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_list1 = tint2_board.create('input', [0.5, 6, 'L1', '<i>List<sub>1</sub></i>: '], inputParam);
tint2_list1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
tint2_list1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_mean2 = tint2_board.create('input', [4, 9, '', '<i>x&#772;<sub>2</sub></i> = '], inputParam);
tint2_mean2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_std2 = tint2_board.create('input', [4, 8, '', '<i>s<sub>2</sub></i> = '], inputParam);
tint2_std2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_n2 = tint2_board.create('input', [4, 7, '', '<i>n<sub>2</sub></i> = '], inputParam);
tint2_n2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_list2 = tint2_board.create('input', [4, 6, 'L2', '<i>List<sub>2</sub></i>: '], inputParam);
tint2_list2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
tint2_list2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_c = tint2_board.create('input', [0.5, 5, '', '<i>c</i> = '], inputParam);
tint2_c.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { tint2_docalc(); } };

var tint2_interval = tint2_board.create('text', [0.5, 4, ''], textParam);

var tint2_cb_pooled = JSXCheckbox(tint2_board, 4, 5, 'Pooled Variance', false,
	function() {
		toggleCheckbox(tint2_cb_pooled);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var tint2_cb_stats = JSXCheckbox(tint2_board, 7.5, 8.5, 'Statistics', true,
	function() {
		setCheckbox(tint2_cb_stats, true);
		setCheckbox(tint2_cb_data, false);

		tint2_list1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		tint2_list2.setAttribute({ disabled: true, strokeColor: 'lightgray' });

		tint2_mean1.setAttribute({ disabled: false, strokeColor: 'black' });
		tint2_std1.setAttribute({ disabled: false, strokeColor: 'black' });
		tint2_n1.setAttribute({ disabled: false, strokeColor: 'black' });

		tint2_mean2.setAttribute({ disabled: false, strokeColor: 'black' });
		tint2_std2.setAttribute({ disabled: false, strokeColor: 'black' });
		tint2_n2.setAttribute({ disabled: false, strokeColor: 'black' });
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var tint2_cb_data = JSXCheckbox(tint2_board, 7.5, 8, 'Data', false,
	function() {
		setCheckbox(tint2_cb_stats, false);
		setCheckbox(tint2_cb_data, true);

		tint2_list1.setAttribute({ disabled: false, strokeColor: 'black' });
		tint2_list2.setAttribute({ disabled: false, strokeColor: 'black' });

		tint2_mean1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		tint2_std1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		tint2_n1.setAttribute({ disabled: true, strokeColor: 'lightgray' });

		tint2_mean2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		tint2_std2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		tint2_n2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
	}, { fontSize: 18, anchorY: 'top', frozen: true });

var tint2_calculate = tint2_board.create('button', [7.5, 7, 'Calculate',
	function() { tint2_docalc(); }], { frozen: true, anchorY: 'top' });

function tint2_docalc() {

	var c = evalstr(tint2_c.rendNodeInput.value);
	var mean1 = NaN, std1 = NaN, n1 = NaN;
	var mean2 = NaN, std2 = NaN, n2 = NaN;
	var listerror = false;

	if(tint2_cb_stats.Value()) {
		mean1 = evalstr(tint2_mean1.rendNodeInput.value);
		std1 = evalstr(tint2_std1.rendNodeInput.value);
		n1 = evalstr(tint2_n1.rendNodeInput.value);
		mean2 = evalstr(tint2_mean2.rendNodeInput.value);
		std2 = evalstr(tint2_std2.rendNodeInput.value);
		n2 = evalstr(tint2_n2.rendNodeInput.value);
	} else {
		var list1 = tint2_list1.rendNodeInput.value;
		var list2 = tint2_list2.rendNodeInput.value;
		var xdata1 = getRawData(getListByName(list1));
		var xdata2 = getRawData(getListByName(list2));
		if((xdata1 !== undefined) && (xdata2 !== undefined)) {
			n1 = xdata1.length;
			n2 = xdata2.length;
			mean1 = stats.mean(xdata1);
			mean2 = stats.mean(xdata2);
			std1 = stats.stdev(xdata1);
			std2 = stats.stdev(xdata2);
		} else {
			listerror = true;
		}
	}

	var serr, df = 0;
	if (isChecked(tint2_cb_pooled)) {
		df = n1 + n2 - 2;
		var pooledsd = sqrt( ((n1 - 1) * sqr(std1) + (n2 - 1) * sqr(std2)) / df);
		serr = sqrt( sqr(pooledsd) / n1 + sqr(pooledsd) / n2);
	} else {
		serr = sqrt( sqr(std1) / n1 + sqr(std2) / n2);
		var num = sqr( sqr(std1) / n1 + sqr(std2) / n2 );
		var denom1 = (1 / (n1 - 1)) * sqr( sqr(std1) / n1 );
		var denom2 = (1 / (n2 - 1)) * sqr( sqr(std2) / n2 );
		df = num / (denom1 + denom2);
	}

	if(isNaN(c) || isNaN(std1) || isNaN(std2) || isNaN(n1) || isNaN(n2) || isNaN(mean1) || isNaN(mean2) || isNaN(df) || isNaN(serr)) {
		if(listerror) {
			tint2_interval.setText('One of your lists was not found,<br/>&nbsp;&nbsp;&nbsp;try using L1 or L2 as the name of your lists.');
		} else {
			tint2_interval.setText('One or more input variables is blank or invalid.<br/>&nbsp;&nbsp;&nbsp;Please check your input.');
		}
	} else if (n1 <= 1 || n2 <= 1) {
		tint2_interval.setText('Oops! The sample sizes must be greater than one.');
	} else if (c < 0 || c >= 1) {
		tint2_interval.setText('Oops! The level of confidence, <i>c</i>, must be a value<br/>'
			+ '&nbsp;&nbsp;&nbsp; greater than or equal to zero and less than one.');
	} else {

		var t = Math.abs(jStat.studentt.inv((1 - c) / 2, df));
		var me = t * serr;
		var center = mean1 - mean2;
		var lb = center - me;
		var ub = center + me;

		tint2_interval.setText(
			'(' + round(lb, PRECISION) + ', '
			+ round(ub, PRECISION) + ')<br/><br/>'
			+ '<i>t<sub>c</sub></i> = ' + round(t, PRECISION) + '&nbsp;&nbsp;&nbsp;&nbsp;' 
			+ '<i>df</i> = ' + round(df, PRECISION)	+ '<br/>'
			+ '<i>E</i> = ' + round(me, PRECISION) + '<br/><br/>'
			+ '<table>'
			+ '<tr>'
			+ '<td style="width:160px"><i>x&#772;<sub>1</sub></i> = ' + round(mean1, PRECISION) + '</td>'
			+ '<td style="width:160px"><i>s<sub>1</sub></i> = ' + round(std1, PRECISION) + '</td>'
			+ '<td><i>n<sub>1</sub></i> = ' + n1 + '</td>'
			+ '</tr>'
			+ '<tr>'
			+ '<td><i>x&#772;<sub>2</sub></i> = ' + round(mean2, PRECISION) + '</td>'
			+ '<td><i>s<sub>2</sub></i> = ' + round(std2, PRECISION) + '</td>'
			+ '<td><i>n<sub>2</sub></i> = ' + n2 + '</td>'
			+ '</tr>'
			+ '<td><i>x&#772;<sub>1</sub></i> - <i>x&#772;<sub>2</sub></i> = ' + round(center, PRECISION) + '</td>' 
			+ '<tr>'
			+ '</table>'
		);
	}

}

</script>

<!--////////////////////////////////////////////////////////////////////////
	////////////////////// Confidence Interval for Two Proportions /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var pint2_board = JXG.JSXGraph.initBoard('prop-int_2samp', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var pint2_x1 = pint2_board.create('input', [0.5, 8, '', 'x<sub>1</sub> = '], inputParam);
pint2_x1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { pint2_docalc(); } };

var pint2_n1 = pint2_board.create('input', [0.5, 7, '', 'n<sub>1</sub> = '], inputParam);
pint2_n1.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { pint2_docalc(); } };

var pint2_x2 = pint2_board.create('input', [5, 8, '', 'x<sub>2</sub> = '], inputParam);
pint2_x2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { pint2_docalc(); } };

var pint2_n2 = pint2_board.create('input', [5, 7, '', 'n<sub>2</sub> = '], inputParam);
pint2_n2.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { pint2_docalc(); } };

var pint2_c = pint2_board.create('input', [0.5, 6, '', 'c = '], inputParam);
pint2_c.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { pint2_docalc(); } };

var pint2_interval = pint2_board.create('text', [0.5, 5, ''], textParam);

var pint2_calculate = pint2_board.create('button', [6, 5.8, 'Calculate',
	function() { pint2_docalc(); }], { frozen: true, anchorY: 'top' });

function pint2_docalc() {

	var c = evalstr(pint2_c.rendNodeInput.value);

	var x1 = evalstr(pint2_x1.rendNodeInput.value);
	var n1 = evalstr(pint2_n1.rendNodeInput.value);
	var x2 = evalstr(pint2_x2.rendNodeInput.value);
	var n2 = evalstr(pint2_n2.rendNodeInput.value);
	
	if (isNaN(c) || isNaN(x1) || isNaN(n1) || isNaN(x2) || isNaN(n2)) {
		pint2_interval.setText('One or more input variables is blank or invalid.<br/>&nbsp;&nbsp;&nbsp;Please check your input.');
	} else if (n1 < x1 || n2 < x2) {
		pint2_interval.setText('Oops! The sample size, <i>n</i>, must be greater than<br/>&nbsp;&nbsp;&nbsp;or equal to <i>x</i>.');
	} else if (n1 <= 0 || n2 <= 0) {
		pint2_interval.setText('Oops! The sample size, <i>n</i>, must be larger than zero.');
	} else if (x1 < 0 || x2 < 0) {
		pint2_interval.setText('Oops! The value of <i>x</i>, must be between 0 and <i>n</i>.');
	} else {
	
		var p1 = x1 / n1;
		var p2 = x2 / n2;

		var serr = sqrt( p1 * (1 - p1) / n1 + p2 * (1 - p2) / n2 );

		var z = Math.abs(jStat.normal.inv((1 - c) / 2, 0, 1));
		var me = z * serr;
		var center = x1 / n1 - x2 / n2;
		var lb = center - me;
		var ub = center + me;

		pint2_interval.setText(
			'(' + round(lb, PRECISION)
			+ ', ' + round(ub, PRECISION) + ')<br/>'
			+ 'z<sub>c</sub> = ' + round(z, PRECISION) + '<br/><br/>'
			+ 'p&#770;<sub>1</sub> = ' + round(x1 / n1, PRECISION) + '<br/>'
			+ 'p&#770;<sub>2</sub> = ' + round(x2 / n2, PRECISION) + '<br/><br/>'
			+ 'p&#770;<sub>1</sub> - p&#770;<sub>2</sub> = ' + round(center, PRECISION) + '<br/>'
			+ 'E = ' + round(me, PRECISION));
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	///////////////////////////////////// Test for a Mean (Normal) /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var ztest_board = JXG.JSXGraph.initBoard('z-test', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var ztest_mu = ztest_board.create('input', [0.5, 9, '', 'Null Hypothesis: <i>&mu;</i> = '], inputParam);
ztest_mu.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ztest_docalc(); } };

var ztest_alt = ztest_board.create('text', [0.5, 8, 'Alternative Hypothesis:'], textParam);

var ztest_cb_ne = JSXCheckbox(ztest_board, 4, 8, '&ne;', true,
	function() {
		setCheckbox(ztest_cb_ne, true);
		setCheckbox(ztest_cb_lt, false);
		setCheckbox(ztest_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ztest_cb_lt = JSXCheckbox(ztest_board, 5, 8, '&lt;', false,
	function() {
		setCheckbox(ztest_cb_ne, false);
		setCheckbox(ztest_cb_lt, true);
		setCheckbox(ztest_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ztest_cb_gt = JSXCheckbox(ztest_board, 6, 8, '&gt;', false,
	function() {
		setCheckbox(ztest_cb_ne, false);
		setCheckbox(ztest_cb_lt, false);
		setCheckbox(ztest_cb_gt, true);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ztest_mean = ztest_board.create('input', [0.5, 7, '', '<i>x&#772;</i> = '], inputParam);
ztest_mean.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ztest_docalc(); } };

var ztest_std = ztest_board.create('input', [0.5, 6, '', '<i>&sigma;</i> = '], inputParam);
ztest_std.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ztest_docalc(); } };

var ztest_n = ztest_board.create('input', [0.5, 5, '', '<i>n</i> = '], inputParam);
ztest_n.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ztest_docalc(); } };

var ztest_list = ztest_board.create('input', [0.5, 4, 'L1', '<i>List:</i> '], inputParam);
ztest_list.setAttribute({ disabled: true, strokeColor: 'lightgray' });
ztest_list.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ztest_docalc(); } };

var ztest_output = ztest_board.create('text', [0.5, 3, ''], textParam);

var ztest_cb_stats = JSXCheckbox(ztest_board, 6, 7, 'Input from Stats', true,
	function() {
		setCheckbox(ztest_cb_stats, true);
		setCheckbox(ztest_cb_data, false);
		ztest_list.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ztest_mean.setAttribute({ disabled: false, strokeColor: 'black' });
		ztest_n.setAttribute({ disabled: false, strokeColor: 'black' });
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ztest_cb_data = JSXCheckbox(ztest_board, 6, 6, 'Input from Data', false,
	function() {
		setCheckbox(ztest_cb_stats, false);
		setCheckbox(ztest_cb_data, true);
		ztest_list.setAttribute({ disabled: false, strokeColor: 'black' });
		ztest_mean.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ztest_n.setAttribute({ disabled: true, strokeColor: 'lightgray' });
	}, { fontSize: 18, anchorY: 'top', frozen: true });

var ztest_calculate = ztest_board.create('button', [6, 5, 'Calculate',
	function() { ztest_docalc(); }], buttonParam);

function ztest_docalc() {

	var std = evalstr(ztest_std.rendNodeInput.value);
	var mu = evalstr(ztest_mu.rendNodeInput.value);
	var p = NaN, n = NaN, mean = NaN;

	if(ztest_cb_stats.Value()) {
		n = evalstr(ztest_n.rendNodeInput.value);
		mean = evalstr(ztest_mean.rendNodeInput.value);
	} else {
		var list = ztest_list.rendNodeInput.value;
		var xdata = getRawData(getListByName(list));
		n = xdata.length;
		mean = stats.mean(xdata);
	}

	if(isNaN(mu) || isNaN(mean) || isNaN(std) || isNaN(n)) {
		ztest_output.setText('One or more input variables is blank or invalid.<br/>&nbsp;&nbsp;&nbsp;Please check your input.');		
	} else if (n <= 0) {
		ztest_output.setText('Oops! The sample size, <i>n</i> must be greater than zero.');
	} else {

		var z = (mean - mu) / (std / sqrt(n));

		if(isChecked(ztest_cb_ne)) {
			p = 2 * jStat.normal.cdf(-Math.abs(z), 0, 1);
		} else if(isChecked(ztest_cb_lt)) {
			p = jStat.normal.cdf(z, 0, 1);
		} else {
			p = 1 - jStat.normal.cdf(z, 0, 1);
		}
	
		ztest_output.setText(
			'<i>z</i> = ' + round(z, PRECISION) + '<br/>'
			+ '<i>p</i> = ' + round(p, PRECISION) + '<br/><br/>'
			+ '<i>x&#772;</i> = ' + round(mean, PRECISION) + '<br/>'
			+ '<i>&sigma;</i> = ' + round(std, PRECISION) + '<br/>'
			+ '<i>n</i> = ' + n);
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////// Test for a Mean (T) /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var ttest_board = JXG.JSXGraph.initBoard('t-test', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var ttest_mu = ttest_board.create('input', [0.5, 9, '', 'Null Hypothesis: <i>&mu;</i> = '], inputParam);
ttest_mu.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ttest_docalc(); } };

var ttest_alt = ttest_board.create('text', [0.5, 8, 'Alternative Hypothesis:'], textParam);

var ttest_cb_ne = JSXCheckbox(ttest_board, 4, 8, '&ne;', true,
	function() {
		setCheckbox(ttest_cb_ne, true);
		setCheckbox(ttest_cb_lt, false);
		setCheckbox(ttest_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ttest_cb_lt = JSXCheckbox(ttest_board, 5, 8, '&lt;', false,
	function() {
		setCheckbox(ttest_cb_ne, false);
		setCheckbox(ttest_cb_lt, true);
		setCheckbox(ttest_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ttest_cb_gt = JSXCheckbox(ttest_board, 6, 8, '&gt;', false,
	function() {
		setCheckbox(ttest_cb_ne, false);
		setCheckbox(ttest_cb_lt, false);
		setCheckbox(ttest_cb_gt, true);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ttest_mean = ttest_board.create('input', [0.5, 7, '', '<i>x&#772;</i> = '], inputParam);
ttest_mean.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ttest_docalc(); } };

var ttest_std = ttest_board.create('input', [0.5, 6, '', 's = '], inputParam);
ttest_std.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ttest_docalc(); } };

var ttest_n = ttest_board.create('input', [0.5, 5, '', 'n = '], inputParam);
ttest_n.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ttest_docalc(); } };

var ttest_list = ttest_board.create('input', [0.5, 4, 'L1', 'List: '], inputParam);
ttest_list.setAttribute({ disabled: true, strokeColor: 'lightgray' });
ttest_list.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ttest_docalc(); } };

var ttest_output = ttest_board.create('text', [0.5, 3, ''], textParam);

var ttest_cb_stats = JSXCheckbox(ttest_board, 6, 7, 'Input from Stats', true,
	function() {
		setCheckbox(ttest_cb_stats, true);
		setCheckbox(ttest_cb_data, false);
		ttest_list.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest_mean.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest_n.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest_std.setAttribute({ disabled: false, strokeColor: 'black' });
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ttest_cb_data = JSXCheckbox(ttest_board, 6, 6, 'Input from Data', false,
	function() {
		setCheckbox(ttest_cb_stats, false);
		setCheckbox(ttest_cb_data, true);
		ttest_list.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest_mean.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest_n.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest_std.setAttribute({ disabled: true, strokeColor: 'lightgray' });
	}, { fontSize: 18, anchorY: 'top', frozen: true });

var ttest_calculate = ttest_board.create('button', [6, 5, 'Calculate',
	function() { ttest_docalc(); }], buttonParam);

function ttest_docalc() {

	var mu = evalstr(ttest_mu.rendNodeInput.value);
	var p = NaN, std = NaN, n = NaN, mean = NaN;

	if(ttest_cb_stats.Value()) {
		n = evalstr(ttest_n.rendNodeInput.value);
		mean = evalstr(ttest_mean.rendNodeInput.value);
		std = evalstr(ttest_std.rendNodeInput.value);
	} else {
		var list = tint_list.rendNodeInput.value;
		if (list.includes(',')) {
			var lists = list.split(',');
			var xdata = getRawData(getListByName(lists[0]));
			var fdata = getRawData(getListByName(lists[1]));
			n = xdata.length;
			mean = stats.wmean(xdata, fdata);
			std = stats.wstdev(xdata, fdata);
		} else {
			xdata = getRawData(getListByName(list));
			mean = stats.mean(xdata);
			std = stats.stdev(xdata);
			n = xdata.length
		}
	}

	if (isNaN(mu) || isNaN(mean) || isNaN(std) || isNaN(n)) {
		ttest_output.setText('One or more input variables is blank or invalid.<br/>&nbsp;&nbsp;&nbsp;Please check your input.');		
	} else if (n <= 1) {
		ttest_output.setText('Oops! The sample size, <i>n</i> must be greater than one.');
	} else {

		var t = (mean - mu) / (std / sqrt(n));

		if(isChecked(ttest_cb_ne)) {
			p = 2 * jStat.studentt.cdf(-Math.abs(t), n - 1);
		} else if(isChecked(ttest_cb_lt)) {
			p = jStat.studentt.cdf(t, n - 1);
		} else {
			p = 1 - jStat.studentt.cdf(t, n - 1);
		}

		ttest_output.setText('<i>t</i> = '
			+ round(t, PRECISION) + '<br/>'
			+ '<i>p</i> = ' + round(p, PRECISION) + '<br/><br/>'
			+ '<i>x&#772;</i> = ' + round(mean, PRECISION) + '<br/>'
			+ '<i>s</i> = ' + round(std, PRECISION) + '<br/>'
			+ '<i>n</i> = ' + n);
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////// Test for a Proportion /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var ptest_board = JXG.JSXGraph.initBoard('prop-test', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var ptest_p = ptest_board.create('input', [0.5, 9, '', 'Null Hypothesis: <i>p</i> = '], inputParam);
ptest_p.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ptest_docalc(); } };

var ptest_alt = ptest_board.create('text', [0.5, 8, 'Alternative Hypothesis:'], textParam);

var ptest_cb_ne = JSXCheckbox(ptest_board, 4, 8, '&ne;', true,
	function() {
		setCheckbox(ptest_cb_ne, true);
		setCheckbox(ptest_cb_lt, false);
		setCheckbox(ptest_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ptest_cb_lt = JSXCheckbox(ptest_board, 5, 8, '&lt;', false,
	function() {
		setCheckbox(ptest_cb_ne, false);
		setCheckbox(ptest_cb_lt, true);
		setCheckbox(ptest_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ptest_cb_gt = JSXCheckbox(ptest_board, 6, 8, '&gt;', false,
	function() {
		setCheckbox(ptest_cb_ne, false);
		setCheckbox(ptest_cb_lt, false);
		setCheckbox(ptest_cb_gt, true);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ptest_x = ptest_board.create('input', [0.5, 7, '', '<i>x</i> = '], inputParam);
ptest_x.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ptest_docalc(); } };

var ptest_n = ptest_board.create('input', [0.5, 6, '', 'n = '], inputParam);
ptest_n.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { ptest_docalc(); } };

var ptest_output = ptest_board.create('text', [1, 4.5, ''], textParam);

var ptest_calculate = ptest_board.create('button', [6, 6, 'Calculate',
	function() { ptest_docalc(); }], buttonParam);

function ptest_docalc() {

	var p0 = evalstr(ptest_p.rendNodeInput.value);
	var x = NaN, n = NaN, pval = NaN, phat = NaN;

	n = evalstr(ptest_n.rendNodeInput.value);
	x = evalstr(ptest_x.rendNodeInput.value);
	
	if(isNaN(p0) || isNaN(x) || isNaN(n)) {
		ptest_output.setText('One or more input variables is blank or invalid.<br/>&nbsp;&nbsp;&nbsp;Please check your input.');	
	} else if(x > n) {
		ptest_output.setText("Oops! The sample size, <i>n</i>, must be larger than <i>x</i>.");
	} else {
	
		phat = x / n;

		var z = (phat - p0) / sqrt(p0 * (1 - p0) / n);

		if(isChecked(ptest_cb_ne)) {
			pval = 2 * jStat.normal.cdf(-Math.abs(z), 0, 1);
		} else if(isChecked(ptest_cb_lt)) {
			pval = jStat.normal.cdf(z, 0, 1);
		} else {
			pval = 1 - jStat.normal.cdf(z, 0, 1);
		}

		ptest_output.setText(
			'<i>p&#770;</i> = ' + round(phat, PRECISION) + '<br/><br/>'
			+ '<i>z</i> = ' + round(z, PRECISION) + '<br/>'
			+ '<i>p</i> = ' + round(pval, PRECISION));
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
	////////////////////////////////// Test for Two Means (Normal) /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var ztest2_board = JXG.JSXGraph.initBoard('z-test_2samp', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var ztest2_alt = ztest2_board.create('text', [0.5, 9, 'Alternative Hypothesis:'],
		{ fixed :true, frozen: true, anchorY: 'top', fontSize: 18 });
var ztest2_cb_ne = JSXCheckbox(ztest2_board, 4, 9, '&ne;', true,
	function() {
		setCheckbox(ztest2_cb_ne, true);
		setCheckbox(ztest2_cb_lt, false);
		setCheckbox(ztest2_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ztest2_cb_lt = JSXCheckbox(ztest2_board, 5, 9, '&lt;', false,
	function() {
		setCheckbox(ztest2_cb_ne, false);
		setCheckbox(ztest2_cb_lt, true);
		setCheckbox(ztest2_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ztest2_cb_gt = JSXCheckbox(ztest2_board, 6, 9, '&gt;', false,
	function() {
		setCheckbox(ztest2_cb_ne, false);
		setCheckbox(ztest2_cb_lt, false);
		setCheckbox(ztest2_cb_gt, true);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ztest2_std1 = ztest2_board.create('input', [0.5, 8, '', '&sigma;<sub>1</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ztest2_mean1 = ztest2_board.create('input', [0.5, 7, '', 'x&#772;<sub>1</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ztest2_n1 = ztest2_board.create('input', [0.5, 6, '', 'n<sub>1</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ztest2_list1 = ztest2_board.create('input', [0.5, 5, 'L1', 'List<sub>1</sub>: '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18, strokeColor: 'lightgray' });
ztest2_list1.setAttribute({ disabled: true });

var ztest2_std2 = ztest2_board.create('input', [5.5, 8, '', '&sigma;<sub>2</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ztest2_mean2 = ztest2_board.create('input', [5.5, 7, '', 'x&#772;<sub>2</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ztest2_n2 = ztest2_board.create('input', [5.5, 6, '', 'n<sub>2</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ztest2_list2 = ztest2_board.create('input', [5.5, 5, 'L2', 'List<sub>2</sub>: '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18, strokeColor: 'lightgray' });
ztest2_list2.setAttribute({ disabled: true });

var ztest2_output = ztest2_board.create('text', [1, 3, ''],
		{ fixed :true, frozen: true, anchorY: 'top', fontSize: 18 });

var ztest2_cb_stats = JSXCheckbox(ztest2_board, 0.5, 4, 'Input from Stats', true,
	function() {
		setCheckbox(ztest2_cb_stats, true);
		setCheckbox(ztest2_cb_data, false);
		ztest2_list1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ztest2_mean1.setAttribute({ disabled: false, strokeColor: 'black' });
		ztest2_n1.setAttribute({ disabled: false, strokeColor: 'black' });
		ztest2_list2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ztest2_mean2.setAttribute({ disabled: false, strokeColor: 'black' });
		ztest2_n2.setAttribute({ disabled: false, strokeColor: 'black' });
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ztest2_cb_data = JSXCheckbox(ztest2_board, 5, 4, 'Input from Data', false,
	function() {
		setCheckbox(ztest2_cb_stats, false);
		setCheckbox(ztest2_cb_data, true);
		ztest2_list1.setAttribute({ disabled: false, strokeColor: 'black' });
		ztest2_mean1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ztest2_n1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ztest2_list2.setAttribute({ disabled: false, strokeColor: 'black' });
		ztest2_mean2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ztest2_n2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
	}, { fontSize: 18, anchorY: 'top', frozen: true });

var ztest2_calculate = ztest2_board.create('button', [7, 3, 'Calculate',

	function() {

		var std1 = Number(ztest2_std1.rendNodeInput.value);
		var std2 = Number(ztest2_std2.rendNodeInput.value);
		var mean1, mean2, n1, n2 = 0;

		if(ztest2_cb_stats.Value()) {
			n1 = Number(ztest2_n1.rendNodeInput.value);
			n2 = Number(ztest2_n2.rendNodeInput.value);
			mean1 = Number(ztest2_mean1.rendNodeInput.value);
			mean2 = Number(ztest2_mean2.rendNodeInput.value);
		} else {
			var list1 = ztest2_list1.rendNodeInput.value;
			var list2 = ztest2_list2.rendNodeInput.value;
			var xdata1 = getRawData(list1);
			var xdata2 = getRawData(list2);
			n1 = xdata1.length;
			n2 = xdata2.length;
			mean1 = stats.mean(xdata1);
			mean2 = stats.mean(xdata2);
		}

		var z = (mean1 - mean2) / sqrt( sqr(std1) / n1 + sqr(std2 / n2) );

		if(isChecked(ztest2_cb_ne)) {
			p = 2 * jStat.normal.cdf(-Math.abs(z), 0, 1);
		} else if(isChecked(ztest2_cb_lt)) {
			p = jStat.normal.cdf(z, 0, 1);
		} else {
			p = 1 - jStat.normal.cdf(z, 0, 1);
		}

		ztest2_output.setText('z = ' + z + '<br/>p-value = ' + p);

	}

], { frozen: true, anchorY: 'top' });

</script>

<!--////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////// Test for Two Means (T) /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var ttest2_board = JXG.JSXGraph.initBoard('t-test_2samp', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var ttest2_alt = ttest2_board.create('text', [0.5, 9, 'Alternative Hypothesis:'],
		{ fixed :true, frozen: true, anchorY: 'top', fontSize: 18 });
var ttest2_cb_ne = JSXCheckbox(ttest2_board, 4, 9, '&ne;', true,
	function() {
		setCheckbox(ttest2_cb_ne, true);
		setCheckbox(ttest2_cb_lt, false);
		setCheckbox(ttest2_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ttest2_cb_lt = JSXCheckbox(ttest2_board, 5, 9, '&lt;', false,
	function() {
		setCheckbox(ttest2_cb_ne, false);
		setCheckbox(ttest2_cb_lt, true);
		setCheckbox(ttest2_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ttest2_cb_gt = JSXCheckbox(ttest2_board, 6, 9, '&gt;', false,
	function() {
		setCheckbox(ttest2_cb_ne, false);
		setCheckbox(ttest2_cb_lt, false);
		setCheckbox(ttest2_cb_gt, true);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ttest2_std1 = ttest2_board.create('input', [0.5, 8, '', 's<sub>1</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ttest2_mean1 = ttest2_board.create('input', [0.5, 7, '', 'x&#772;<sub>1</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ttest2_n1 = ttest2_board.create('input', [0.5, 6, '', 'n<sub>1</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ttest2_list1 = ttest2_board.create('input', [0.5, 5, 'L1', 'List<sub>1</sub>: '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18, strokeColor: 'lightgray' });
ttest2_list1.setAttribute({ disabled: true });

var ttest2_std2 = ttest2_board.create('input', [5.5, 8, '', 's<sub>2</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ttest2_mean2 = ttest2_board.create('input', [5.5, 7, '', 'x&#772;<sub>2</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ttest2_n2 = ttest2_board.create('input', [5.5, 6, '', 'n<sub>2</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ttest2_list2 = ttest2_board.create('input', [5.5, 5, 'L2', 'List<sub>2</sub>: '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18, strokeColor: 'lightgray' });
ttest2_list2.setAttribute({ disabled: true });

var ttest2_cb_pooled = JSXCheckbox(ttest2_board, 0.5, 3, 'Pooled Variance', false,
	function() {
		toggleCheckbox(ttest2_cb_pooled);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ttest2_output = ttest2_board.create('text', [1, 2, ''],
		{ fixed :true, frozen: true, anchorY: 'top', fontSize: 18 });

var ttest2_cb_stats = JSXCheckbox(ttest2_board, 0.5, 4, 'Input from Stats', true,
	function() {
		setCheckbox(ttest2_cb_stats, true);
		setCheckbox(ttest2_cb_data, false);
		ttest2_list1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest2_mean1.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest2_n1.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest2_std1.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest2_list2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest2_mean2.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest2_n2.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest2_std2.setAttribute({ disabled: false, strokeColor: 'black' });
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ttest2_cb_data = JSXCheckbox(ttest2_board, 5, 4, 'Input from Data', false,
	function() {
		setCheckbox(ttest2_cb_stats, false);
		setCheckbox(ttest2_cb_data, true);
		ttest2_list1.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest2_mean1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest2_n1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest2_std1.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest2_list2.setAttribute({ disabled: false, strokeColor: 'black' });
		ttest2_mean2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest2_n2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
		ttest2_std2.setAttribute({ disabled: true, strokeColor: 'lightgray' });
	}, { fontSize: 18, anchorY: 'top', frozen: true });

var ttest2_calculate = ttest2_board.create('button', [7, 3, 'Calculate',

	function() {

		var pval, mean1, mean2, n1, n2, std1, std2 = 0;

		if(ttest2_cb_stats.Value()) {
			n1 = Number(ttest2_n1.rendNodeInput.value);
			n2 = Number(ttest2_n2.rendNodeInput.value);
			mean1 = Number(ttest2_mean1.rendNodeInput.value);
			mean2 = Number(ttest2_mean2.rendNodeInput.value);
			std1 = Number(ttest2_std1.rendNodeInput.value);
			std2 = Number(ttest2_std2.rendNodeInput.value);
		} else {
			var list1 = ttest2_list1.rendNodeInput.value;
			var list2 = ttest2_list2.rendNodeInput.value;
			var xdata1 = getRawData(getListByName(list1));
			var xdata2 = getRawData(getListByName(list2));
			n1 = xdata1.length;
			n2 = xdata2.length;
			mean1 = stats.mean(xdata1);
			mean2 = stats.mean(xdata2);
			std1 = stats.stdev(xdata1);
			std2 = stats.stdev(xdata2);
		}

		var serr, df = 0;
		if (isChecked(ttest2_cb_pooled)) {
			df = n1 + n2 - 2;
			var pooledsd = sqrt( ((n1 - 1) * sqr(std1) + (n2 - 1) * sqr(std2)) / df);
			serr = sqrt( sqr(pooledsd) / n1 + sqr(pooledsd) / n2);
		} else {
			serr = sqrt( sqr(std1) / n1 + sqr(std2) / n2);
			var num = sqr( sqr(std1) / n1 + sqr(std2) / n2 );
			var denom1 = (1 / (n1 - 1)) * sqr( sqr(std1) / n1 );
			var denom2 = (1 / (n2 - 1)) * sqr( sqr(std2) / n2 );
			df = num / (denom1 + denom2);
		}

		var t = (mean1 - mean2) / serr;

		if(isChecked(ttest2_cb_ne)) {
			pval = 2 * jStat.studentt.cdf(-Math.abs(t), df);
		} else if(isChecked(ttest2_cb_lt)) {
			pval = jStat.studentt.cdf(t, df);
		} else {
			pval = 1 - jStat.studentt.cdf(t, df);
		}

		ttest2_output.setText('df = ' + df + '<br/>t = ' + t + '<br/>p-value = ' + pval);

	}

], { frozen: true, anchorY: 'top' });

</script>

<!--////////////////////////////////////////////////////////////////////////
	///////////////////////////////////// Test for Two Proportions /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

var ptest2_board = JXG.JSXGraph.initBoard('prop-test_2samp', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });

var ptest2_alt = ptest2_board.create('text', [0.5, 9, 'Alternative Hypothesis:'],
		{ fixed :true, frozen: true, anchorY: 'top', fontSize: 18 });
var ptest2_cb_ne = JSXCheckbox(ptest2_board, 4, 9, '&ne;', true,
	function() {
		setCheckbox(ptest2_cb_ne, true);
		setCheckbox(ptest2_cb_lt, false);
		setCheckbox(ptest2_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ptest2_cb_lt = JSXCheckbox(ptest2_board, 5, 9, '&lt;', false,
	function() {
		setCheckbox(ptest2_cb_ne, false);
		setCheckbox(ptest2_cb_lt, true);
		setCheckbox(ptest2_cb_gt, false);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});
var ptest2_cb_gt = JSXCheckbox(ptest2_board, 6, 9, '&gt;', false,
	function() {
		setCheckbox(ptest2_cb_ne, false);
		setCheckbox(ptest2_cb_lt, false);
		setCheckbox(ptest2_cb_gt, true);
	}, { fontSize: 18, frozen: true, anchorY: 'top'});

var ptest2_x1 = ptest2_board.create('input', [0.5, 8, '', 'x<sub>1</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ptest2_n1 = ptest2_board.create('input', [0.5, 7, '', 'n<sub>1</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });

var ptest2_x2 = ptest2_board.create('input', [5.5, 8, '', 'x<sub>2</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });
var ptest2_n2 = ptest2_board.create('input', [5.5, 7, '', 'n<sub>2</sub> = '],
		{ cssStyle: 'width: 100px', fixed: true, anchorY: 'top', frozen: true, fontSize: 18 });

var ptest2_output = ptest2_board.create('text', [1, 3, ''],
		{ fixed :true, frozen: true, anchorY: 'top', fontSize: 18 });

var ptest2_calculate = ptest2_board.create('button', [7, 3, 'Calculate',

	function() {

		var x1 = Number(ptest2_x1.rendNodeInput.value);
		var n1 = Number(ptest2_n1.rendNodeInput.value);
		var x2 = Number(ptest2_x2.rendNodeInput.value);
		var n2 = Number(ptest2_n2.rendNodeInput.value);
		var p1 = x1 / n1;
		var p2 = x2 / n2;

		var p = (x1 + x2) / (n1 + n2);
		var z = (p1 - p2) / sqrt( p * (1 - p) / n1 + p * (1 - p) / n2 );;

		if(isChecked(ptest2_cb_ne)) {
			p = 2 * jStat.normal.cdf(-Math.abs(z), 0, 1);
		} else if(isChecked(ptest2_cb_lt)) {
			p = jStat.normal.cdf(z, 0, 1);
		} else {
			p = 1 - jStat.normal.cdf(z, 0, 1);
		}

		ptest2_output.setText('z = ' + z + '<br/>p-value = ' + p);

	}

], { frozen: true, anchorY: 'top' });

</script>


<!--////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////// Calculation /////////
	////////////////////////////////////////////////////////////////////////-->


<script>

var calc_board = JXG.JSXGraph.initBoard('calculation', {
		boundingbox: [0,10,10,0],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });

var calc_text = calc_board.create('text', [0.35, 9.25, 'Enter an expression to evaluate:'], { fontSize: 18, frozen: true, fixed: true });
var calc_input = calc_board.create('input', [0.35, 8.5, '', ''], { fontSize: 18, cssStyle: 'width: 480px', frozen: true, fixed: true });
calc_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		calc_calculate();
	}
};

var calc_button = calc_board.create('button', [8, 9.25, 'Calculate', function() { calc_calculate(); }], { frozen: true, fixed : true });
var calc_clear_button = calc_board.create('button', [7.75, 7.5, 'Clear',
	function() {
		calc_input.rendNodeInput.value = '';
	}]);

var calc_output = calc_board.create('text', [1, 7.5, '='], { anchorY: 'top', fontSize: 24, frozen: true, fixed: true });

function calc_calculate() {

	var expression = calc_input.rendNodeInput.value;
	var weightedstats = false;

	// check to see if we are doing some statistics
	if (expression.includes('1-var_stats')) {
		expression = expression.replace('1-var_stats', '');
		expression = expression.replace('(', '');
		expression = expression.replace(')', '');
		expression = expression.replace(/ /g, '');
		exression = expression.trim();
		// Determine if we are in weighted mode or not
		if (expression.includes(',')) {
			weightedstats = true;
			var lists = expression.split(',');
			var xdata = getRawData(getListByName(lists[0]));
			var fdata = getRawData(getListByName(lists[1]));
			var n = stats.wn(xdata, fdata);
			var mean = round(stats.wmean(xdata, fdata), PRECISION);
			var s = round(stats.wstdev(xdata, fdata), PRECISION);
			var sigma = round(stats.wstdevp(xdata, fdata), PRECISION);
			var sum = stats.wsum(xdata, fdata);
			var sumofsqr = stats.wsumofsqr(xdata, fdata);
			var min = stats.wmin(xdata, fdata);
			var q1 = stats.wq1(xdata, fdata);
			var median = stats.wmedian(xdata, fdata);
			var q3 = stats.wq3(xdata, fdata);
			var max = stats.wmax(xdata, fdata);
			calc_output.setText('n = ' + n + '<br>x&#772; = ' + mean + '<br>s = ' + s +
				'<br>&sigma; = ' + sigma + '<br>&Sigma;x = ' + sum + '<br>&Sigma;x<sup>2</sup> = ' +
				sumofsqr + '<br>Minimum = ' + min + '<br>Q1 = ' + q1 + '<br>Median = ' + median +
				'<br>Q3 = ' + q3 + '<br>Maximum = ' + max);
		} else {
			var xdata = getRawData(getListByName(expression));
			var n = xdata.length;
			var mean = round(stats.mean(xdata), PRECISION);
			var s = round(stats.stdev(xdata), PRECISION);
			var sigma = round(stats.stdevp(xdata), PRECISION);
			var sum = stats.sum(xdata);
			var sumofsqr = stats.sumofsqr(xdata);
			var min = stats.min(xdata);
			var q1 = stats.q1(xdata);
			var median = stats.median(xdata);
			var q3 = stats.q3(xdata);
			var max = stats.max(xdata);
			calc_output.setText('n = ' + n + '<br>x&#772; = ' + mean + '<br>s = ' + s +
				'<br>&sigma; = ' + sigma + '<br>&Sigma;x = ' + sum + '<br>&Sigma;x<sup>2</sup> = ' +
				sumofsqr + '<br>Minimum = ' + min + '<br>Q1 = ' + q1 + '<br>Median = ' + median +
				'<br>Q3 = ' + q3 + '<br>Maximum = ' + max);
		}
	} else if (expression.includes('lin_reg')) {
		expression = expression.replace('lin_reg', '');
		expression = expression.replace('(', '');
		expression = expression.replace(')', '');
		expression = expression.replace(/ /g, '');
		exression = expression.trim();
		var lists = expression.split(',');
		var xdata = getRawData(getListByName(lists[0]));
		var ydata = getRawData(getListByName(lists[1]));
		var r = round(stats.correlation(xdata, ydata), PRECISION);
		var rsqr = round(sqr(r), PRECISION);
		var reg = stats.linreg(xdata, ydata);
		var m = round(reg[0], PRECISION);
		var b = round(reg[1], PRECISION);
			calc_output.setText(
				'a = ' + m +
				'<br>b = ' + b +
				'<br>r<sup>2</sup> = ' + rsqr +
				'<br>r = ' + r);
	} else {
		// If not, just evaluate the expression
		var v = round(math.eval(expression), PRECISION);
		calc_output.setText(' = ' + v);
	}

}

var calc_1varstats = calc_board.create('button', [7, 6.5, 'Single Var Stats',
		function() {
			calc_input.rendNodeInput.value = calc_input.rendNodeInput.value + '1-var_stats(';
		}], { frozen: true, fixed: true });

var calc_1varstats = calc_board.create('button', [7, 5.5, 'Linear Regression',
		function() {
			calc_input.rendNodeInput.value = calc_input.rendNodeInput.value + 'lin_reg(';
		}], { frozen: true, fixed: true });

var calc_1varstats = calc_board.create('button', [7, 4.5, 'Combination',
		function() {
			calc_input.rendNodeInput.value = calc_input.rendNodeInput.value + 'combinations(';
		}], { frozen: true, fixed: true });

var calc_1varstats = calc_board.create('button', [7, 3.5, 'Permutation',
		function() {
			calc_input.rendNodeInput.value = calc_input.rendNodeInput.value + 'permutations(';
		}], { frozen: true, fixed: true });

var calc_1varstats = calc_board.create('button', [7, 2.5, 'Factorial',
		function() {
			calc_input.rendNodeInput.value = calc_input.rendNodeInput.value + '!';
		}], { frozen: true, fixed: true });

var calc_about = calc_board.create('button', [7, 1, 'About',
		function() {
			alert('Statistics Calculator<br/>created by David Flenner<br/>copyright 2020<br/>'
				  + 'This program is free software: you can redistribute it and/or'
				  + 'modify it under the terms of the GNU General Public License as published by'
				  + 'the Free Software Foundation, either version 3 of the License, or'
				  + 'any later version.'
				  + 'This program is distributed in the hope that it will be useful,'
				  + 'but WITHOUT ANY WARRANTY; without even the implied warranty of'
				  + 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the'
				  + 'GNU General Public License for more details.'
				  + 'You should have received a copy of the GNU General Public License'
				  + 'along with this program.  If not, see <https://www.gnu.org/licenses/>.'
				  + 'Dependencies:'
				  + 'JSX Graph - https://jsxgraph.uni-bayreuth.de/wp/index.html'
				  + 'math.js - https://mathjs.org/'
				  + 'jStat - https://jstat.github.io/');
		}], { frozen: true, fixed: true });

function getListByName(listname) {
	listname = listname.trim();
	listname = listname.toLowerCase();
	if(listname == "l1") {
		return list1_data;
	} else if(listname == "l2") {
		return list2_data;
	} else if(listname == "l3") {
		return list3_data;
	} else return undefined;
}

function getRawData(list_data) {
	if(list_data == undefined) {
		return undefined;
	} else {
		var raw_data = [];
		for (var i = 0; i < list_data.length; i++) {
			var data = list_data[i].rendNodeInput.value;
			if (data !== '') {
				var val = math.eval(data);
				raw_data.push(val);
			}
		}
		return raw_data;
	}
}

</script>

<script>

var normal_board = JXG.JSXGraph.initBoard('standard_normal', {
		boundingbox: [-4,0.48,4,-0.48],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });

var normal_mean = 0;
var normal_stdev = 1;

function zScore(x) {
	return (x - normal_mean) / normal_stdev;
}

function xValue(z) {
	return normal_mean + z * normal_stdev;
}

var normal_curve = normal_board.create('functiongraph', [function(x) { return jStat.normal.pdf(x, normal_mean, normal_stdev); }],
	{ strokeWidth: 3, fixed: true, 	highlight: false });

var normal_axis = normal_board.create('axis', [[0, 0], [1, 0]],	{ ticks: { visible: false } });

var normal_ticks = [];
var normal_axislabels = [];
for (var i = -3; i <= 3; i++) {
	normal_ticks[i + 3] = normal_board.create('segment', [[i,.01], [i,-0.01]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
	normal_axislabels[i + 3] = normal_board.create('text', [i-.05, -0.02, i], { fixed: true, highlight: false });
}

var normal_x1 = normal_board.create('glider', [-2, 0, normal_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
normal_x1.on('drag',
	function() {
		normal_x1_input.rendNodeInput.value = normal_x1.X().toFixed(2);
		normal_prob_input.rendNodeInput.value = normal_cprob(normal_x1.X(), normal_x2.X());
	}
);

var normal_x2 = normal_board.create('glider', [2, 0, normal_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
normal_x2.on('drag',
	function() {
		normal_x2_input.rendNodeInput.value = normal_x2.X().toFixed(2);
		if(normal_cb_xvalue.Value() && normal_cb_between.Value()) {
			var old_z = zScore(normal_x2.X());
			var new_x = xValue(-old_z);
			normal_x1.moveTo([new_x,0]);
			normal_x1_input.rendNodeInput.value = new_x.toFixed(2);
		}
		normal_prob_input.rendNodeInput.value = normal_cprob(normal_x1.X(), normal_x2.X());
	}
);

var shadedregionleft = normal_board.create('integral',
	[[ function() { return xValue(-10000); }, function() { return normal_x2.X(); }], normal_curve], shadeParam);
shadedregionleft.setAttribute({ visible: false });

var shadedregionright = normal_board.create('integral',
	[[ function() { return normal_x1.X(); }, function() { return xValue(10000); }], normal_curve], shadeParam);
shadedregionright.setAttribute({ visible: false });

var shadedregionbetween = normal_board.create('integral',
	[[ function() { return normal_x1.X(); }, function() { return normal_x2.X(); }], normal_curve], shadeParam);

// input variables

var normal_mean_input = normal_board.create('input', [1.3, 0.38, '0', '&mu; = '], inputParam);
var normal_stdev_input = normal_board.create('input', [1.3, 0.3, '1', '&sigma; = '], inputParam);

var normal_update = normal_board.create('button', [2.5, 0.22, 'Update',

	// If a new mean and standard deviation are provided, then we need to:
	//   - change the bounds on the x-axis
	//   - set the global normal_mean and normal_stdev variables
	//   - reset the positions of normal_x1 and normal_x2 on the x-axis so that they are accessible again

	function() {
		var cur_z1 = zScore(normal_x1.X());
		var cur_z2 = zScore(normal_x2.X());
		normal_mean = Number(normal_mean_input.Value());
		normal_stdev = Number(eval(normal_stdev_input.Value()));
		var x_min = xValue(-4);
		var x_max = xValue(4);
		var y_min = (-0.4 / normal_stdev) * 1.2;
		var y_max = (0.4 / normal_stdev) * 1.2;
		normal_board.setBoundingBox([x_min, y_max, x_max, y_min]);
		var new_x1 = xValue(cur_z1);
		var new_x2 = xValue(cur_z2);
		normal_x1.moveTo([new_x1, 0]);
		normal_x2.moveTo([new_x2, 0]);
		normal_x1_input.rendNodeInput.value = new_x1;
		normal_x2_input.rendNodeInput.value = new_x2;
		normal_prob_input.rendNodeInput.value = normal_cprob(new_x1, new_x2);
		normal_updateAxisLabels(y_max);
	}

], { frozen: true });

var normal_cb_between = JSXCheckbox(normal_board, -3.6, -0.1, 'P(a < x < b)', true,
	function() {
		setCheckbox(normal_cb_between, true);
		setCheckbox(normal_cb_left, false);
		setCheckbox(normal_cb_right, false);

		shadedregionleft.setAttribute({ visible: false });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: true });

		// Make sure x-values are within bounds and valid:
		if(typeof(normal_x1.X()) !== 'number' || abs(zScore(normal_x2.X())) > 3.5) {
			normal_x1.moveTo([xValue(-2), 0]);
		}
		if(typeof(normal_x2.X()) !== 'number' || abs(zScore(normal_x2.X())) > 3.5) {
			normal_x2.moveTo([xValue(2), 0]);
		}

		if(normal_cb_area.Value()) {

			normal_x1.setAttribute({ visible: true });
			normal_x2.setAttribute({ visible: true });

			normal_x1_input.rendNodeInput.value = normal_x1.X().toFixed(2);
			normal_x2_input.rendNodeInput.value = normal_x2.X().toFixed(2);

			normal_x1_input.setAttribute({ disabled: false });
			normal_x2_input.setAttribute({ disabled: false });

			normal_prob_input.setAttribute({ disabled: true });

		} else if(normal_cb_xvalue.Value()) {

			normal_x1.setAttribute({ visible: false });
			normal_x2.setAttribute({ visible: true });

			var old_z = zScore(normal_x2.X());
			var new_x = xValue(-old_z);

			normal_x1.moveTo([new_x, 0]);

			normal_x1_input.rendNodeInput.value = new_x.toFixed(2);
			normal_x2_input.rendNodeInput.value = normal_x2.X().toFixed(2);

			normal_x1_input.setAttribute({ disabled: true });
			normal_x2_input.setAttribute({ disabled: true });
			normal_prob_input.setAttribute({ disabled: false });

		}

		PTYPE = 'between';

	}, { fontSize: 18, frozen: true });

var normal_cb_left = JSXCheckbox(normal_board, -3.6, -0.16, 'P(x < b)', false,
	function() {
		setCheckbox(normal_cb_left, true);
		setCheckbox(normal_cb_between, false);
		setCheckbox(normal_cb_right, false);

		shadedregionleft.setAttribute({ visible: true });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: false });

		if(typeof(normal_x2.X()) !== 'number' || abs(zScore(normal_x2.X())) > 3.5) {
			normal_x2.moveTo([xValue(2), 0]);
		}

		normal_x1.setAttribute({ visible: false });
		normal_x2.setAttribute({ visible: true });

		normal_x1_input.rendNodeInput.value = '-Infinity';
		normal_x2_input.rendNodeInput.value = normal_x2.X().toFixed(2);
		PTYPE = 'left';

		if(normal_cb_area.Value()) {
			normal_x1_input.setAttribute({ disabled: true });
			normal_x2_input.setAttribute({ disabled: false });
			normal_prob_input.setAttribute({ disabled: true });

		} else {
			normal_x1_input.setAttribute({ disabled: true });
			normal_x2_input.setAttribute({ disabled: true });
			normal_prob_input.setAttribute({ disabled: false });
		}

	}, { fontSize: 18, frozen: true });

var normal_cb_right = JSXCheckbox(normal_board, -3.6, -0.22, 'P(x > a)', false,
	function() {

		setCheckbox(normal_cb_right, true);
		setCheckbox(normal_cb_between, false);
		setCheckbox(normal_cb_left, false);

		shadedregionleft.setAttribute({ visible: false });
		shadedregionright.setAttribute({ visible: true });
		shadedregionbetween.setAttribute({ visible: false });

		if(typeof(normal_x1.X()) !== 'number') {
			normal_x1.moveTo([xValue(-2), 0]);
		}

		normal_x1.setAttribute({ visible: true });
		normal_x2.setAttribute({ visible: false });

		normal_x1_input.rendNodeInput.value = normal_x1.X().toFixed(2);
		normal_x2_input.rendNodeInput.value = 'Infinity';
		PTYPE = 'right';

		if(normal_cb_area.Value()) {
			normal_x1_input.setAttribute({ disabled: false });
			normal_x2_input.setAttribute({ disabled: true });
			normal_prob_input.setAttribute({ disabled: true });
		} else {
			normal_x1_input.setAttribute({ disabled: true });
			normal_x2_input.setAttribute({ disabled: true });
			normal_prob_input.setAttribute({ disabled: false });
		}

	}, { fontSize: 18, frozen: true });

var normal_cb_area = JSXCheckbox(normal_board, 1, -0.1, 'Calculate Area', true,
	function() {
		setCheckbox(normal_cb_area, true);
		setCheckbox(normal_cb_xvalue, false);

		normal_cb_between.setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		normal_cb_left.setAttribute( { disabled: false, strokeColor: 'black', highlight: true });
		normal_cb_right.setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });

		normal_prob_input.setAttribute( { disabled: true });
		if(normal_cb_left.Value()) {
			normal_x1_input.setAttribute( { disabled: true });
			normal_x2_input.setAttribute( { disabled: false });
		} else if(normal_cb_right.Value()) {
			normal_x1_input.setAttribute( { disabled: false });
			normal_x2_input.setAttribute( { disabled: true });
		} else if(normal_cb_between.Value()) {
			normal_x1_input.setAttribute( { disabled: false });
			normal_x2_input.setAttribute( { disabled: false });
			normal_x1.setAttribute( { visible: true });
		}


	}, { fontSize: 18, frozen: true });

var normal_cb_xvalue = JSXCheckbox(normal_board, 1, -0.16, 'Calculate x-Value', false,
	function() {
		setCheckbox(normal_cb_xvalue, true);
		setCheckbox(normal_cb_area, false);

		if(normal_cb_left.Value()) {
			normal_x1_input.rendNodeInput.value = '-Infinity';
			normal_x2_input.rendNodeInput.value = normal_x2.X().toFixed(2);
		} else if(normal_cb_right.Value()) {
			normal_x1_input.rendNodeInput.value = normal_x1.X().toFixed(2);
			normal_x2_input.rendNodeInput.value = 'Infinity';
		} else if(normal_cb_between.Value()) {
			normal_x1.setAttribute({ visible: false });
		}

		normal_x1_input.setAttribute({ disabled: true });
		normal_x2_input.setAttribute({ disabled: true });
		normal_prob_input.setAttribute({ disabled: false });

		PTYPE = 'left';


	}, { fontSize: 18, frozen: true });

var normal_x1_input = normal_board.create('input', [-3.5, -0.32, '-2', 'P( '], inputParam);
normal_x1_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		normal_docalc();
	}
};
var normal_x2_input = normal_board.create('input', [-1.3, -0.32, '2', ' < <i>X</i> < '], inputParam);
normal_x2_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		normal_docalc();
	}
};

var normal_prob_input = normal_board.create('input', [1.3, -0.32, '0.9500', ') = '], inputParam);
normal_prob_input.setAttribute( { disabled: true } );
normal_prob_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		normal_docalc();
	}
};

var normal_calc = normal_board.create('button', [1.5, -0.42, 'Calculate', function() { normal_docalc() }], { frozen: true });

function normal_docalc() {
	if(isChecked(normal_cb_area)) {

		if(!isNaN(normal_x1_input.Value())) {
			normal_x1.moveTo([normal_x1_input.Value(), 0]);
		}

		if(!isNaN(normal_x2_input.Value())) {
			normal_x2.moveTo([normal_x2_input.Value(), 0]);
		}

		normal_prob_input.rendNodeInput.value = normal_cprob(normal_x1_input.Value(), normal_x2_input.Value());

	} else { // inverse calculation
		if(!isNaN(normal_prob_input.Value())) {
			if(normal_cb_left.Value()) {
				var x = jStat.normal.inv(normal_prob_input.Value(), normal_mean, normal_stdev);
				normal_x2.moveTo([x, 0]);
				normal_x2_input.rendNodeInput.value = x;
			} else if(normal_cb_right.Value()) {
				var x = jStat.normal.inv(1 - normal_prob_input.Value(), normal_mean, normal_stdev);
				normal_x1.moveTo([x, 0]);
				normal_x1_input.rendNodeInput.value = x;
			} else { // between
				var z = jStat.normal.inv((1 - normal_prob_input.Value()) / 2, 0, 1);
				normal_x1.moveTo([xValue(z), 0]);
				normal_x1_input.rendNodeInput.value = xValue(z);
				normal_x2.moveTo([xValue(-z), 0]);
				normal_x2_input.rendNodeInput.value = xValue(-z);
			}
		}
	}
	normal_board.update();
}


function normal_updateAxisLabels(y_max) {

	for(var i = -3; i <= 3; i++) {
		normal_ticks[i + 3].point1.moveTo([xValue(i), 0.02 * y_max]);
		normal_ticks[i + 3].point2.moveTo([xValue(i), -0.02 * y_max]);
		normal_axislabels[i + 3].setText(xValue(i));
		normal_axislabels[i + 3].setCoords([xValue(i), -0.06 * y_max]);
	}

}

function normal_cprob(x1, x2) {

	var m = normal_mean;
	var s = normal_stdev;

	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}

	if(normal_cb_between.Value()) {
		return round(abs(jStat.normal.cdf(x2, m, s) - jStat.normal.cdf(x1, m, s)), PRECISION);
	} else if(normal_cb_left.Value()) {
		return round(jStat.normal.cdf(x2, m, s), PRECISION);
	} else if(normal_cb_right.Value()) {
		return round(1 - jStat.normal.cdf(x1, m, s), PRECISION);
	}

}


</script>


<script type='text/javascript'>

var t_board = JXG.JSXGraph.initBoard('t-distribution', {
		boundingbox: [-4,0.5,4,-0.5],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });

var t_mean = 0;
var t_stdev = 1;
var t_df = 10;

function tScore(x) {
	return (x - t_mean) / t_stdev;
}

function t_xval(t) {
	return t_mean + t * t_stdev;
}

var t_curve = t_board.create('functiongraph', [function(x) { return jStat.studentt.pdf(tScore(x), t_df); }],
	{ strokeWidth: 3, fixed: true, 	highlight: false });

var t_axis = t_board.create('line', [[0, 0], [1, 0]], { strokeColor: 'black', strokeWidth: 1, highlight: false, fixed: true, frozen: true });

var t1 = t_board.create('glider', [-2, 0, t_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
t1.on('drag',
	function() {
		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_prob_input.rendNodeInput.value = currentTProbability(t1.X(), t2.X(), t_df);
	}
);

var t2 = t_board.create('glider', [2, 0, t_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
t2.on('drag',
	function() {
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		if (t_cb_xvalue.Value() && t_cb[BETWEEN].Value()) {
			var old_t = tScore(t2.X());
			var new_x = t_xval(-old_t);
			t1.moveTo([new_x, 0]);
			t_x1_input.rendNodeInput.value = new_x.toFixed(2);
		}
		t_prob_input.rendNodeInput.value = currentTProbability(t1.X(), t2.X(), t_df);
	}
);

var t_shadeleft = t_board.create('integral',
	[[ function() { return t_xval(-10000); }, function() { return t2.X(); }], t_curve], shadeParam);
t_shadeleft.setAttribute({ visible: false });

var t_shaderight = t_board.create('integral',
	[[ function() { return t1.X(); }, function() { return t_xval(10000); }], t_curve], shadeParam);
t_shaderight.setAttribute({ visible: false });

var t_shadebetween = t_board.create('integral',
	[[ function() { return t1.X(); }, function() { return t2.X(); }], t_curve], shadeParam);

var t_ticks = [];
var t_labels = [];
for (var i = -3; i <= 3; i++) {
	t_ticks[i + 3] = t_board.create('segment', [[i,.01], [i,-0.01]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
	t_labels[i + 3] = t_board.create('text', [i-.05, -0.02, i], { fixed: true, highlight: false });
}

// input variables

var t_df_input = t_board.create('input', [1.3, 0.45, t_df, 'df = '], inputParam);
t_df_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		t_docalc();
	}
};
var t_mean_input = t_board.create('input', [1.3, 0.38, t_mean, '&mu; = '], inputParam);
t_mean_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		t_docalc();
	}
};
var t_stdev_input = t_board.create('input', [1.3, 0.3, t_stdev, '&sigma; = '], inputParam);
t_stdev_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		t_docalc();
	}
};

var t_update_button = t_board.create('button', [2.5, 0.22, 'Update', function() { t_docalc(); } ], { frozen: true });

var t_cb = [];

t_cb[BETWEEN] = JSXCheckbox(t_board, -3.6, -0.1, 'P(a < x < b)', true,
	function() {
		set_t_cbtrue(BETWEEN);

		t_shadeleft.setAttribute({ visible: false });
		t_shaderight.setAttribute({ visible: false });
		t_shadebetween.setAttribute({ visible: true });

		t1.setAttribute({ visible: true });
		t2.setAttribute({ visible: true });

		if (t_cb_area.Value()) {
			t_x1_input.setAttribute({ disabled: false });
			t_x2_input.setAttribute({ disabled: false });
			t_prob_input.setAttribute({ disabled: true });
		} else if(t_cb_xvalue.Value()) {
			t_x1_input.setAttribute({ disabled: true });
			t_x2_input.setAttribute({ disabled: true });
			t_prob_input.setAttribute({ disabled: false });
			t1.setAttribute({ visible: false });
		}

		// Replace with full update function
		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_prob_input.rendNodeInput.value = currentTProbability(t1.X(), t2.X(), t_df);


	}, { fontSize: 18, frozen: true });

t_cb[LEFT] = JSXCheckbox(t_board, -3.6, -0.16, 'P(x < b)', false,
	function() {
		set_t_cbtrue(LEFT);

		t_shadeleft.setAttribute({ visible: true });
		t_shaderight.setAttribute({ visible: false });
		t_shadebetween.setAttribute({ visible: false });

		t1.setAttribute({ visible: false });
		t2.setAttribute({ visible: true });

		if (t_cb_area.Value()) {
			t_x1_input.setAttribute({ disabled: true });
			t_x2_input.setAttribute({ disabled: false });
			t_prob_input.setAttribute({ disabled: true });
		} else if(t_cb_xvalue.Value()) {
			t_x1_input.setAttribute({ disabled: true });
			t_x2_input.setAttribute({ disabled: true });
			t_prob_input.setAttribute({ disabled: false });
		}

		t_x1_input.rendNodeInput.value = '-Infinity';
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_prob_input.rendNodeInput.value = currentTProbability(Number.NEGATIVE_INFINITY, t2.X(), t_df);

	}, { fontSize: 18, frozen: true });

t_cb[RIGHT] = JSXCheckbox(t_board, -3.6, -0.22, 'P(x > a)', false,
	function() {
		set_t_cbtrue(RIGHT);

		t_shadeleft.setAttribute({ visible: false });
		t_shaderight.setAttribute({ visible: true });
		t_shadebetween.setAttribute({ visible: false });

		t1.setAttribute({ visible: true });
		t2.setAttribute({ visible: false });

		if (t_cb_area.Value()) {
			t_x1_input.setAttribute({ disabled: false });
			t_x2_input.setAttribute({ disabled: true });
			t_prob_input.setAttribute({ disabled: true });
		} else if(t_cb_xvalue.Value()) {
			t_x1_input.setAttribute({ disabled: true });
			t_x2_input.setAttribute({ disabled: true });
			t_prob_input.setAttribute({ disabled: false });
		}

		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_x2_input.rendNodeInput.value = 'Infinity';
		t_prob_input.rendNodeInput.value = currentTProbability(t1.X(), Number.POSITIVE_INFINITY, t_df);

	}, { fontSize: 18, frozen: true });

var t_cb_area = JSXCheckbox(t_board, 1, -0.1, 'Calculate Area', true,
	function() {
		setCheckbox(t_cb_area, true);
		setCheckbox(t_cb_xvalue, false);

		t1.setAttribute({ visible: true });

		if (t_cb[BETWEEN].Value()) {

			t_x1_input.setAttribute({ disabled: false });
			t_x2_input.setAttribute({ disabled: false });
			t_prob_input.setAttribute({ disabled: true });

			t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
			t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
			t_prob_input.rendNodeInput.value = currentTProbability(t1.X(), t2.X(), t_df);

		} else if (t_cb[LEFT].Value()) {

			t_x1_input.setAttribute({ disabled: true });
			t_x2_input.setAttribute({ disabled: false });
			t_prob_input.setAttribute({ disabled: true });

			t_x1_input.rendNodeInput.value = '-Infinity';
			t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
			t_prob_input.rendNodeInput.value = currentTProbability(Number.NEGATIVE_INFINITY, t2.X(), t_df);

		} else if (t_cb[RIGHT].Value()) {

			t_x1_input.setAttribute({ disabled: false });
			t_x2_input.setAttribute({ disabled: true });
			t_prob_input.setAttribute({ disabled: true });

			t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
			t_x2_input.rendNodeInput.value = 'Infinity';
			t_prob_input.rendNodeInput.value = currentTProbability(t1.X(), Number.POSITIVE_INFINITY, t_df);

		}


	}, { fontSize: 18, frozen: true });

var t_cb_xvalue = JSXCheckbox(t_board, 1, -0.16, 'Calculate x-Value', false,
	function() {
		setCheckbox(t_cb_xvalue, true);
		setCheckbox(t_cb_area, false);

		t1.setAttribute({ visible: true });

		if (t_cb[BETWEEN].Value()) {

			t_x1_input.setAttribute({ disabled: true });
			t_x2_input.setAttribute({ disabled: true });
			t_prob_input.setAttribute({ disabled: false });
			t1.setAttribute({ visible: false });

			t_x1_input.rendNodeInput.value = t_xval(-tScore(t2.X())).toFixed(2);
			t1.moveTo([t_xval(-tScore(t2.X())), 0]);
			t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
			t_prob_input.rendNodeInput.value = currentTProbability(t1.X(), t2.X(), t_df);

		} else if (t_cb[LEFT].Value()) {

			t_x1_input.setAttribute({ disabled: true });
			t_x2_input.setAttribute({ disabled: true });
			t_prob_input.setAttribute({ disabled: false });

			t_x1_input.rendNodeInput.value = '-Infinity';
			t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
			t_prob_input.rendNodeInput.value = currentTProbability(Number.NEGATIVE_INFINITY, t2.X(), t_df);

		} else if (t_cb[RIGHT].Value()) {

			t_x1_input.setAttribute({ disabled: true });
			t_x2_input.setAttribute({ disabled: true });
			t_prob_input.setAttribute({ disabled: false });

			t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
			t_x2_input.rendNodeInput.value = 'Infinity';
			t_prob_input.rendNodeInput.value = currentTProbability(t1.X(), Number.POSITIVE_INFINITY, t_df);

		}

		t_board.update();

	}, { fontSize: 18, frozen: true });

var t_x1_input = t_board.create('input', [-3.5, -0.32, '-2', 'P( '], inputParam);
t_x1_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		t_docalc();
	}
};

var t_x2_input = t_board.create('input', [-1.3, -0.32, '2', ' < <i>X</i> < '], inputParam);
t_x2_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		t_docalc();
	}
};

var t_prob_input = t_board.create('input', [1.3, -0.32, '0.9500', ') = '], inputParam);
t_prob_input.setAttribute({ disabled: true });
t_prob_input.rendNodeInput.onkeypress = function(e) {
	if(e.which == 13) {
		t_docalc();
	}
};

// Buttons

var t_calc_button = t_board.create('button', [1.5, -0.42, 'Calculate', function() { t_docalc(); }], { frozen: true });

function t_docalc() {

	// Check to see if updates to the distribution need to be made first
	if ((t_df_input.Value() != t_df) || (t_mean_input.Value() != t_mean) || (t_stdev_input.Value() != t_stdev)) {

		// Preserve current positions of the input points on the x-axis
		var cur_z1 = tScore(t1.X());
		var cur_z2 = tScore(t2.X());

		// Retreive new mean, stdev, df
		t_mean = Number(t_mean_input.Value());
		t_stdev = Number(eval(t_stdev_input.Value()));
		t_df = Number(t_df_input.rendNodeInput.value);

		// Reset board bounds
		var x_min = t_xval(-4);
		var x_max = t_xval(4);
		t_board.setBoundingBox([x_min, 0.5, x_max, -0.5]);

		// Reposition the points
		var new_t1 = t_xval(cur_z1);
		var new_t2 = t_xval(cur_z2);
		t1.moveTo([new_t1, 0]);
		t2.moveTo([new_t2, 0]);

		t_x1_input.rendNodeInput.value = new_t1;
		t_x2_input.rendNodeInput.value = new_t2;

		t_prob_input.rendNodeInput.value = currentTProbability(new_t1, new_t2, t_df);
		updateTAxisLabels();

	}

	if(t_cb_area.Value()) {
		if(!isNaN(t_x1_input.Value())) {
			t1.moveTo([t_x1_input.Value(), 0]);
		}

		if(!isNaN(t_x2_input.Value())) {
			t2.moveTo([t_x2_input.Value(), 0]);
		}

		t_prob_input.rendNodeInput.value = currentTProbability(t_x1_input.Value(), t_x2_input.Value(), t_df);

	} else if (t_cb_xvalue.Value()) {

		if(!isNaN(t_prob_input.Value())) {

			if (t_cb[LEFT].Value()) {
				var x = t_xval(jStat.studentt.inv(t_prob_input.Value(), t_df));
				t2.moveTo([x, 0]);
				t_x2_input.rendNodeInput.value = x;
			} else if (t_cb[RIGHT].Value()) {
				var x = t_xval(jStat.studentt.inv(1 - t_prob_input.Value(), t_df));
				t1.moveTo([x, 0]);
				t_x1_input.rendNodeInput.value = x;
			} else if (t_cb[BETWEEN].Value()) {
				var t = jStat.studentt.inv((1 - t_prob_input.Value()) / 2, t_df);
				t1.moveTo([t_xval(t), 0]);
				t_x1_input.rendNodeInput.value = t_xval(t);
				t2.moveTo([t_xval(-t), 0]);
				t_x2_input.rendNodeInput.value = t_xval(-t);
			}
		}

	}

	t_board.update();
}

function updateTAxisLabels() {

	for(var i = -3; i <= 3; i++) {
		t_ticks[i + 3].point1.moveTo([t_xval(i), 0.01]);
		t_ticks[i + 3].point2.moveTo([t_xval(i), -0.01]);
		t_labels[i + 3].setText(t_xval(i));
		t_labels[i + 3].setCoords([t_xval(i), -0.02]);
	}

}

function currentTProbability(x1, x2, df) {

	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	if(typeof(df) !== 'number') {
		df = Number(df);
	}

	if(t_cb[BETWEEN].Value()) {
		return Math.abs(jStat.studentt.cdf(tScore(x2), df) - jStat.studentt.cdf(tScore(x1), df)).toFixed(PRECISION);
	} else if(t_cb[LEFT].Value()) {
		return jStat.studentt.cdf(tScore(x2), df).toFixed(PRECISION);
	} else if(t_cb[RIGHT].Value()) {
		return (1 - jStat.studentt.cdf(tScore(x1), df)).toFixed(PRECISION);
	}

}

function set_t_cbtrue(box) {
	t_cb[BETWEEN].rendNodeCheckbox.checked = false;
	t_cb[LEFT].rendNodeCheckbox.checked = false;
	t_cb[RIGHT].rendNodeCheckbox.checked = false;
	t_cb[BETWEEN]._value = false;
	t_cb[LEFT]._value = false;
	t_cb[RIGHT]._value = false;
	t_cb[box].rendNodeCheckbox.checked = true;
	t_cb[box]._value = true;
}


</script>


<script type='text/javascript'>

var chi_board = JXG.JSXGraph.initBoard('chi-distribution', {
		boundingbox: [0,0.5,24,-0.5],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });

var chi_mean = 6;
var chi_stdev = Math.sqrt(jStat.chisquare.variance(6));
var chi_df = 6;


function chi_score(x) {
	return (x - chi_mean) / chi_stdev;
}

function chi_xval(t) {
	return chi_mean + t * chi_stdev;
}

var chi_curve = chi_board.create('functiongraph', [function(x) { return jStat.chisquare.pdf(x, chi_df); }],
	{ strokeWidth: 3, fixed: true, 	highlight: false });

var chi_axis = chi_board.create('line', [[0, 0], [1, 0]], { strokeColor: 'black', strokeWidth: 1, highlight: false, fixed: true, frozen: true });

var chi_1 = chi_board.create('glider', [2, 0, chi_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
chi_1.on('drag',
	function() {
		if(chi_1.X() < 0) {
			chi_1.moveTo([0, 0]);
		}
		chi_x1_input.rendNodeInput.value = chi_1.X().toFixed(2);
		chi_df = Number(chi_df_input.rendNodeInput.value);
		chi_prob_input.rendNodeInput.value = current_chi_probability(chi_1.X(), chi_2.X(), chi_df);
		chi_prob_disp.setText(') = ' + current_chi_probability(chi_1.X(), chi_2.X(), chi_df));
	}
);

var chi_2 = chi_board.create('glider', [10, 0, chi_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
chi_2.on('drag',
	function() {
		if(chi_2.X() < 0) {
			chi_2.moveTo([0, 0]);
		}
		chi_x2_input.rendNodeInput.value = chi_2.X().toFixed(2);
		chi_x2_disp.setText('< <i>X</i> < ' + chi_2.X().toFixed(2));
		chi_df = Number(chi_df_input.rendNodeInput.value);
		chi_prob_input.rendNodeInput.value = current_chi_probability(chi_1.X(), chi_2.X(), chi_df);
		chi_prob_disp.setText(') = ' + current_chi_probability(chi_1.X(), chi_2.X(), chi_df));
	}
);

// Initialize the tick marks and axis labels so they can be updated later
var chi_ticks = [];
var chi_labels = [];
for (var i = 0; i < 20; i++) {
	chi_ticks[i] = chi_board.create('segment', [[10, 10], [10, 11]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
}
for (var i = 1; i < 20; i++ ) {
    chi_labels[i-1] = chi_board.create('text', [10, 10, ''], { fixed: true, highlight: false });
}

var x_min = 0;
var x_max = 4 * chi_df;

var chi_tick_delta = 2;
var chi_n_ticks = 20;

chi_set_tick_metrics(chi_df);

var chi_tick_ratio = 50; // ticks are 1/50 the value of y-max
var y_val = chi_df > 2 ? jStat.chisquare.pdf(jStat.chisquare.mode(chi_df), chi_df) * 1.3 : 0.5;

chi_board.setBoundingBox([x_min, y_val, x_max, -y_val]);
var tick_height = y_val / chi_tick_ratio;

for (var i = 0; i < chi_n_ticks; i++) {
	chi_ticks[i].point1.moveTo([i * chi_tick_delta, tick_height]);
	chi_ticks[i].point2.moveTo([i * chi_tick_delta, -tick_height]);
}

for (var i = 1; i < chi_n_ticks; i++) {
	chi_labels[i-1].setText(i * chi_tick_delta);
	chi_labels[i-1].moveTo([i * chi_tick_delta, -2 * tick_height]);
}

// input variables

var chi_df_input = chi_board.create('input', [15, 0.15, chi_df, 'df = '], inputParam);
var chi_mean_disp = chi_board.create('text', [15, 0.125, function() { return '&mu; = ' + chi_mean; }], textParam);
var chi_stdev_disp = chi_board.create('text', [15, 0.1, function() { return '&sigma; = ' + chi_stdev.toFixed(4); }], textParam);

var chi_shadeleft = chi_board.create('integral',
	[[ 0 , function() { return chi_2.X(); }], chi_curve], shadeParam);
chi_shadeleft.setAttribute({ visible: false });

var chi_shaderight = chi_board.create('integral',
	[[ function() { return chi_1.X(); }, function() { return 4 * chi_df; }], chi_curve], shadeParam);
chi_shaderight.setAttribute({ visible: false });

var chi_shadebetween = chi_board.create('integral',
	[[ function() { return chi_1.X(); }, function() { return chi_2.X(); }], chi_curve], shadeParam);

var chi_x1_input = chi_board.create('input', [2, -0.11, '2', 'P( '], inputParam);

var chi_x2_input = chi_board.create('input', [9, -0.11, '10', ' < <i>X</i> < '], inputParam);

var chi_x2_disp = chi_board.create('text', [9, -0.11, '< <i>X</i> < 2'], textParam);
chi_x2_disp.setAttribute({ visible: false });

var chi_prob_input = chi_board.create('input', [17, -0.11, '0.7950', ') = '], inputParam);
chi_prob_input.setAttribute({ visible: false });

var chi_prob_disp = chi_board.create('text', [17, -0.11, ') = 0.7950'], textParam);

// Buttons

var chi_calc_button = chi_board.create('button', [15, -0.14, 'Calculate',
	function () {

		if(isChecked(chi_cb_area)) {
			if(!isNaN(chi_x1_input.Value())) {
				chi_1.moveTo([chi_x1_input.Value(), 0]);
			}

			if(!isNaN(chi_x2_input.Value())) {
				chi_2.moveTo([chi_x2_input.Value(), 0]);
			}
			chi_df = Number(chi_df_input.rendNodeInput.value);
			chi_prob_input.rendNodeInput.value = current_chi_probability(chi_x1_input.Value(), chi_x2_input.Value(), chi_df);
			chi_prob_disp.setText(') = ' + current_chi_probability(chi_x1_input.Value(), chi_x2_input.Value(), chi_df));

		} else {
			if(!isNaN(chi_prob_input.Value())) {

				chi_df = Number(chi_df_input.rendNodeInput.value);
				var chi = jStat.chisquare.inv(chi_prob_input.Value(), chi_df);
				chi_2.moveTo([chi, 0]);
				chi_x2_input.rendNodeInput.value = chi;
				chi_x2_disp.setText('< <i>X</i> < ' + chi.toFixed(8));

			}
		}
}], { frozen: true });

var chi_update = chi_board.create('button', [17, 0.075, 'Update', function() {

		var new_df = chi_df_input.rendNodeInput.value;

		if (new_df >= 1) {

			chi_df = new_df;

			chi_set_tick_metrics(chi_df);

			var y_val = chi_df > 2 ? jStat.chisquare.pdf(jStat.chisquare.mode(chi_df), chi_df) * 1.3 : 0.5;

			chi_board.setBoundingBox([x_min, y_val, x_max, -y_val]);
			var tick_height = y_val / chi_tick_ratio;

			// Move all ticks and labels off screen
			for (var i = 0; i < 20; i++) {
				chi_ticks[i].point1.moveTo([10, 10]);
				chi_ticks[i].point2.moveTo([10, 11]);
			}

			for (var i = 1; i < 20; i++) {
				chi_labels[i-1].setText('');
				chi_labels[i-1].moveTo([10, 10]);
			}

			if (chi_tick_delta != -1) {

				// Update the display for just the labels and ticks we want
				for (var i = 0; i < chi_n_ticks; i++) {
					chi_ticks[i].point1.moveTo([i * chi_tick_delta, tick_height]);
					chi_ticks[i].point2.moveTo([i * chi_tick_delta, -tick_height]);
				}

				for (var i = 1; i < chi_n_ticks; i++) {
					chi_labels[i-1].setText(i * chi_tick_delta);
					chi_labels[i-1].moveTo([i * chi_tick_delta, -2 * tick_height]);
				}
			}

			chi_mean = jStat.chisquare.mean(chi_df);
			chi_stdev = Math.sqrt(jStat.chisquare.variance(chi_df));


			var cur_x1 = chi_x1_input.rendNodeInput.value;
			var cur_x2 = chi_x2_input.rendNodeInput.value;

			if(cur_x2 > 4 * chi_df) {
				cur_x2 = 3 * chi_df;
			}

			chi_1.moveTo([cur_x1, 0]);
			chi_2.moveTo([cur_x2, 0]);

			chi_x1_input.rendNodeInput.value = cur_x1;
			chi_x2_input.rendNodeInput.value = cur_x2;
			chi_x2_disp.setText('< <i>X</i> < ' + Number(cur_x2).toFixed(8));

			chi_prob_input.rendNodeInput.value = current_chi_probability(cur_x1, cur_x2, chi_df);
			chi_prob_disp.setText(') = ' + current_chi_probability(cur_x1, cur_x2, chi_df));

		}

		chi_df_input.rendNodeInput.value = chi_df;

}], { frozen: true });

// Checkboxes

var chi_cb_area = JSXCheckbox(chi_board, 14, -0.025, 'Calculate Area', true,
	function() {
		setCheckbox(chi_cb_area, true);
		setCheckbox(chi_cb_xvalue, false);

		chi_cb[BETWEEN].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		chi_cb[LEFT].setAttribute( { disabled: false });
		chi_cb[RIGHT].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });

		chi_prob_input.setAttribute( { visible: false });
		chi_prob_disp.setAttribute( { visible: true });

		chi_x2_input.setAttribute( { disabled: false });
		chi_x2_input.setAttribute( { visible: true });
		chi_x2_disp.setAttribute({ visible: false });


	}, { fontSize: 18, frozen: true });

var chi_cb_xvalue = JSXCheckbox(chi_board, 14, -0.05, 'Calculate x-Value', false,
	function() {
		setCheckbox(chi_cb_xvalue, true);
		setCheckbox(chi_cb_area, false);

		chi_cb[BETWEEN].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		chi_cb[LEFT].setAttribute( { disabled: false });
		chi_cb[RIGHT].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		set_chi_cbtrue(LEFT);

		chi_1.setAttribute({ visible: false });
		chi_2.setAttribute({ visible: true });

		chi_shadeleft.setAttribute({ visible: true });
		chi_shaderight.setAttribute({ visible: false });
		chi_shadebetween.setAttribute({ visible: false });

		chi_x1_input.rendNodeInput.value = '0';
		chi_x1_input.setAttribute({ disabled: true });

		chi_x2_input.rendNodeInput.value = chi_2.X().toFixed(2);
		chi_x2_input.setAttribute({ visible: false });
		chi_x2_disp.setAttribute({ visible: true });

		chi_prob_input.setAttribute({ visible: true });
		chi_prob_disp.setAttribute({ visible: false });

		chi_2.moveTo([chi_x2_input.rendNodeInput.value, 0]);

	}, { fontSize: 18, frozen: true });

var chi_cb = [];

chi_cb[BETWEEN] = JSXCheckbox(chi_board, 2, -0.025, 'P(a < x < b)', true,
	function() {
		set_chi_cbtrue(BETWEEN);

		chi_shadeleft.setAttribute({ visible: false });
		chi_shaderight.setAttribute({ visible: false });
		chi_shadebetween.setAttribute({ visible: true });

		chi_1.setAttribute({ visible: true });
		chi_2.setAttribute({ visible: true });

		chi_x1_input.rendNodeInput.value = chi_1.X().toFixed(2);
		chi_x1_input.setAttribute({ disabled: false });

		chi_x2_input.rendNodeInput.value = chi_2.X().toFixed(2);
		chi_x2_input.setAttribute({ visible: true });
		chi_x2_input.setAttribute({ disabled: false });
		chi_x2_disp.setAttribute({ visible: false });

		chi_prob_input.setAttribute({ visible: false });
		chi_prob_disp.setAttribute({ visible: true });

	}, { fontSize: 18, frozen: true });

chi_cb[LEFT] = JSXCheckbox(chi_board, 2, -0.05, 'P(x < b)', false,
	function() {
		set_chi_cbtrue(LEFT);

		chi_1.setAttribute({ visible: false });
		chi_2.setAttribute({ visible: true });

		chi_shadeleft.setAttribute({ visible: true });
		chi_shaderight.setAttribute({ visible: false });
		chi_shadebetween.setAttribute({ visible: false });

		chi_x1_input.rendNodeInput.value = '0';
		chi_x1_input.setAttribute({ disabled: true });

		chi_x2_input.rendNodeInput.value = chi_2.X().toFixed(2);
		chi_x2_input.setAttribute({ visible: true });
		chi_x2_input.setAttribute({ disabled: false });
		chi_x2_disp.setAttribute({ visible: false });

		chi_prob_input.setAttribute({ visible: false });
		chi_prob_disp.setAttribute({ visible: true });

	}, { fontSize: 18, frozen: true });

chi_cb[RIGHT] = JSXCheckbox(chi_board, 2, -0.075, 'P(x > a)', false,
	function() {
		set_chi_cbtrue(RIGHT);

		chi_1.setAttribute({ visible: true });
		chi_2.setAttribute({ visible: false });

		chi_shadeleft.setAttribute({ visible: false });
		chi_shaderight.setAttribute({ visible: true });
		chi_shadebetween.setAttribute({ visible: false });

		chi_x1_input.rendNodeInput.value = chi_1.X().toFixed(2);
		chi_x1_input.setAttribute({ disabled: false });

		chi_x2_input.rendNodeInput.value = 'Infinity';
		chi_x2_input.setAttribute({ visible: true });
		chi_x2_input.setAttribute({ disabled: true });
		chi_x2_disp.setAttribute({ visible: false });

		chi_prob_input.setAttribute({ visible: false });
		chi_prob_disp.setAttribute({ visible: true });

	}, { fontSize: 18, frozen: true });

function current_chi_probability(x1, x2, df) {

	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	if(typeof(df) !== 'number') {
		df = Number(df);
	}

	if(chi_cb[BETWEEN].Value()) {

		var v1 = jStat.chisquare.cdf(x1, df);
		var v2 = jStat.chisquare.cdf(x2, df);

		return (v2 - v1).toFixed(4);

	} else if(chi_cb[LEFT].Value()) {

		return jStat.chisquare.cdf(x2, df).toFixed(4);

	} else if(chi_cb[RIGHT].Value()) {

		return (1 - jStat.chisquare.cdf(x1, df)).toFixed(4);

	}

}

function chi_set_tick_metrics(chi_df) {

	if (chi_df == 1) {
		chi_tick_delta = 0.25;
	} else if (chi_df == 2) {
		chi_tick_delta = 0.5;
	} else if (chi_df >= 3 && chi_df <= 5) {
		chi_tick_delta = 1;
	} else if (chi_df >= 6 && chi_df <= 10) {
		chi_tick_delta = 2;
	} else if (chi_df >= 11 && chi_df <= 20) {
		chi_tick_delta = 5;
	} else if (chi_df >= 21 && chi_df <= 50) {
		chi_tick_delta = 10;
	} else if (chi_df >= 51 && chi_df <= 100) {
		chi_tick_delta = 20;
	} else if (chi_df <= 1000) {
		chi_tick_delta = 50;
	} else chi_tick_delta = -1;


	x_min = 0;
	x_max = 4 * chi_df;
	if (chi_tick_delta != -1) {
		chi_n_ticks = (x_max - x_min) / chi_tick_delta;
	} else {
		chi_n_ticks = -1;
	}

}

function set_chi_cbtrue(box) {
	chi_cb[BETWEEN].rendNodeCheckbox.checked = false;
	chi_cb[LEFT].rendNodeCheckbox.checked = false;
	chi_cb[RIGHT].rendNodeCheckbox.checked = false;
	chi_cb[BETWEEN]._value = false;
	chi_cb[LEFT]._value = false;
	chi_cb[RIGHT]._value = false;
	chi_cb[box].rendNodeCheckbox.checked = true;
	chi_cb[box]._value = true;
}

</script>


<!--////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////// Binomial Distribution /////////
	////////////////////////////////////////////////////////////////////////-->

<script>

// Initial Values
var binom_n = 8;
var binom_p = 0.75;
var binom_mean = binom_n * binom_p;
var binom_stdev = sqrt(binom_n * binom_p * (1 - binom_p));

var binom_xmin = -1;
var binom_xmax = binom_n + 1;
var binom_ymin = -1;
var binom_ymax = 1;

var binom_x1 = 3;
var binom_x2 = 6;
var binom_ptype = BETWEEN;

var binom_decimals = 9;

var binom_defaultcolors = ['white', 'white', 'white', 'blue', 'blue', 'blue', 'blue', 'white', 'white'];

var binom_board = JXG.JSXGraph.initBoard('binomial-distribution', {
		boundingbox: [binom_xmin, binom_ymax, binom_xmax, binom_ymin],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
		zoom: {
			factorX: 1.25,
			factorY: 1.25,
			wheel: false,
			needshift: false,
			eps: 0.1,
				enabled: false
		  },
		pan: {
			enabled: false
		}
    });


/*var binom_curve = binom_board.create('functiongraph', [function(x) { return tpdf(tScore(x), binom_df); }],
	{ strokeWidth: 3, fixed: true, 	highlight: false });*/

var binom_axis = binom_board.create('line', [[0, 0], [1, 0]],
		{ strokeColor: 'black', strokeWidth: 1, highlight: false, fixed: true, frozen: true });

var binom_p1 = binom_board.create('glider', [binom_x1, 0, binom_axis],
		{ withLabel: false, showInfobox: false, color: 'black', snapToGrid: true, snapSizeX: 1 });
binom_p1.on('drag',
	function() {
		// Bounds check on the movable point
		if(binom_p1.X() < 0) { binom_p1.moveTo([0, 0]); }
		if(binom_p1.X() > binom_n) { binom_p1.moveTo([binom_n, 0]);	}
		binom_x1_input.rendNodeInput.value = binom_p1.X();
		binom_x1 = binom_p1.X();
		binom_prob_disp.setText(') = ' + binom_cprob(binom_x1, binom_x2, binom_n, binom_p, binom_ptype));
		binom_update_colors();
	}
);

var binom_p2 = binom_board.create('glider', [binom_x2, 0, binom_axis],
		{ withLabel: false, showInfobox: false, color: 'black', snapToGrid: true, snapSizeX: 1 });
binom_p2.on('drag',
	function() {
		// Bounds check on the movable point
		if(binom_p2.X() < 0) { binom_p2.moveTo([0, 0]); }
		if(binom_p2.X() > binom_n) { binom_p2.moveTo([binom_n, 0]);	}
		binom_x2_input.rendNodeInput.value = binom_p2.X();
		binom_x2 = binom_p2.X();
		binom_prob_disp.setText(') = ' + binom_cprob(binom_x1, binom_x2, binom_n, binom_p, binom_ptype));
		binom_update_colors();
	}
);

var binom_ticks = [];
var binom_labels = [];
for (var i = 0; i <= binom_n; i++) {
	binom_ticks[i] = binom_board.create('segment', [[i,.01], [i,-0.01]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
	binom_labels[i] = binom_board.create('text', [i-.05, -0.02, i], { fixed: true, highlight: false });
}

// input variables

var binom_mean_label = binom_board.create('text', [6.5, 0.9,
		function() {
			return '&mu; = ' + binom_mean.toFixed(4);
		}],	textParam);

var binom_stdev_label = binom_board.create('text', [6.5, 0.8,
		function() {
			return '&sigma; = ' + binom_stdev.toFixed(4);
		}],	textParam);

var binom_shadeleft = new Histogram(binom_board, binom_pdf(), binom_defaultcolors, [-0.5, 0], 1);

function binom_pdf() {
	var prob = [];
	for (var i = 0; i <= binom_n; i++) {
		prob.push(jStat.binomial.pdf(i, binom_n, binom_p));
	}
	return prob;
}

function binom_getcolors() {
	var colors = [];

	if (binom_cb[EQUAL].Value()) {
		for (var i = 0; i <= binom_n; i++) {
			colors[i] = i == binom_p2.X() ? 'blue' : 'white';
		}
	} else if (binom_cb[LEFT].Value()) {
		for (var i = 0; i <= binom_n; i++) {
			colors[i] = i <= binom_p2.X() ? 'blue' : 'white';
		}
	} else if (binom_cb[RIGHT].Value()) {
		for (var i = 0; i <= binom_n; i++) {
			colors[i] = i < binom_p1.X() ? 'white' : 'blue';
		}
	} else if (binom_cb[BETWEEN].Value()) {
		var p1 = binom_p1.X() >= binom_p2.X() ? binom_p2.X() : binom_p1.X();
		var p2 = binom_p1.X() >= binom_p2.X() ? binom_p1.X() : binom_p2.X();
		for (var i = 0; i <= binom_n; i++) {
			colors[i] = i < p1 || i > p2 ? 'white' : 'blue';
		}
	}

	return colors;
}

function binom_update_colors() {

	binom_board.suspendUpdate();
	var colors = binom_getcolors();

	for (var i = 0; i <= binom_n; i++) {
		if(typeof(binom_shadeleft.bars[i]) != 'undefined') {
			binom_shadeleft.bars[i].rect.setAttribute({ fillColor: colors[i] });
		}
	}
	binom_board.unsuspendUpdate();

}

// Checkboxes

var binom_cb = [];

binom_cb[BETWEEN] = JSXCheckbox(binom_board, -0.5, -0.1, 'P(a &le; x &le; b)', true,
	function() {
		binom_ptype = BETWEEN;
		set_binom_cbtrue(binom_ptype);

		// Make sure both points and input boxes are visible and enabled
		binom_p1.setAttribute({ visible: true });
		binom_p2.setAttribute({ visible: true });

		binom_x1_input.setAttribute({ disabled: false, visible: true });
		binom_x2_input.setAttribute({ disabled: false });

		// Make sure the points and input boxes show the same value
		binom_x1_input.rendNodeInput.value = binom_p1.X();
		binom_x2_input.rendNodeInput.value = binom_p2.X();

		binom_x2_input.rendNodeLabel.innerHTML = ' &le; <i>X</i> &le; ';

		// update the probability
		binom_x1 = binom_p1.X();
		binom_x2 = binom_p2.X();

		binom_p = Number(binom_p_input.rendNodeInput.value);
		binom_n = Number(binom_n_input.rendNodeInput.value);

		binom_prob_disp.setText(') = ' + binom_cprob(binom_x1, binom_x2, binom_n, binom_p, binom_ptype));
		binom_update_colors();

	}, { fontSize: 18, frozen: true });

binom_cb[LEFT] = JSXCheckbox(binom_board, -0.5, -0.22, 'P(x &le; b)', false,
	function() {
		binom_ptype = LEFT;
		set_binom_cbtrue(binom_ptype);

		// Make sure only p2 and x2 are visible and enabled
		binom_p1.setAttribute({ visible: false });
		binom_p2.setAttribute({ visible: true });

		binom_x1_input.setAttribute({ disabled: true, visible: true });
		binom_x2_input.setAttribute({ disabled: false });

		// Make sure the points and input boxes show the same value
		binom_x1_input.rendNodeInput.value = '0';
		binom_x2_input.rendNodeInput.value = binom_p2.X();

		binom_x2_input.rendNodeLabel.innerHTML = ' &le; <i>X</i> &le; ';

		// update the probability
		binom_x1 = binom_p1.X();
		binom_x2 = binom_p2.X();

		binom_p = Number(binom_p_input.rendNodeInput.value);
		binom_n = Number(binom_n_input.rendNodeInput.value);

		binom_prob_disp.setText(') = ' + binom_cprob(binom_x1, binom_x2, binom_n, binom_p, binom_ptype));
		binom_update_colors();

	}, { fontSize: 18, frozen: true });

binom_cb[RIGHT] = JSXCheckbox(binom_board, -0.5, -0.34, 'P(x &ge; a)', false,
	function() {
		binom_ptype = RIGHT;
		set_binom_cbtrue(binom_ptype);

		// Make sure only p1 and x1 are visible and enabled
		binom_p1.setAttribute({ visible: true });
		binom_p2.setAttribute({ visible: false });

		binom_x1_input.setAttribute({ disabled: false, visible: true });
		binom_x2_input.setAttribute({ disabled: true });

		// Make sure the points and input boxes show the same value
		binom_x1_input.rendNodeInput.value = binom_p1.X();
		binom_x2_input.rendNodeInput.value = binom_n;

		binom_x2_input.rendNodeLabel.innerHTML = ' &le; <i>X</i> &le; ';

		// update the probability
		binom_x1 = binom_p1.X();
		binom_x2 = binom_p2.X();

		binom_p = Number(binom_p_input.rendNodeInput.value);
		binom_n = Number(binom_n_input.rendNodeInput.value);

		binom_prob_disp.setText(') = ' + binom_cprob(binom_x1, binom_x2, binom_n, binom_p, binom_ptype));
		binom_update_colors();

	}, { fontSize: 18, frozen: true });

binom_cb[EQUAL] = JSXCheckbox(binom_board, -0.5, -0.46, 'P(x = a)', false,
	function() {
		binom_ptype = EQUAL;
		set_binom_cbtrue(binom_ptype);

		// Make sure only p2 and x2 are visible and enabled
		binom_p1.setAttribute({ visible: false });
		binom_p2.setAttribute({ visible: true });

		binom_x1_input.setAttribute({ disabled: true, visible: false });
		binom_x2_input.setAttribute({ disabled: false });

		// Make sure the points and input boxes show the same value
		binom_x2_input.rendNodeInput.value = binom_p2.X();

		binom_x2_input.rendNodeLabel.innerHTML = 'P( X = ';

		// update the probability
		binom_x2 = binom_p2.X();

		binom_p = Number(binom_p_input.rendNodeInput.value);
		binom_n = Number(binom_n_input.rendNodeInput.value);

		binom_prob_disp.setText(') = ' + binom_cprob(0, binom_x2, binom_n, binom_p, binom_ptype));
		binom_update_colors();

	}, { fontSize: 18, frozen: true });

var binom_n_input = binom_board.create('input',	[4.5, -0.15, binom_n, 'n = '], inputParam);
binom_n_input.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { binom_docalc(); } };

var binom_p_input = binom_board.create('input',	[4.5, -0.3, binom_p, 'p = '], inputParam);
binom_p_input.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { binom_docalc(); } };

var binom_x1_input = binom_board.create('input', [-0.5, -0.65, binom_x1, 'P( '], inputParam);
binom_x1_input.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { binom_docalc(); } };

var binom_x2_input = binom_board.create('input', [2.5, -0.65, binom_x2, ' &le; <i>X</i> &le; '], inputParam);
binom_x2_input.rendNodeInput.onkeypress = function(e) { if(e.which == 13) { binom_docalc(); } };

var binom_prob_disp = binom_board.create('text', [6, -0.65,
		') = ' + binom_cprob(binom_x1, binom_x2, binom_n, binom_p, binom_ptype)], textParam);

var binom_calc_button = binom_board.create('button', [7, -0.8, 'Calculate',
	function() { binom_docalc(); }], buttonParam);

function binom_docalc () {

	binom_board.suspendUpdate();

	if(binom_n != Number(binom_n_input.rendNodeInput.value)) {

		for(var i = 0; i <= binom_n; i++) {
			if(typeof(binom_shadeleft.bars[i]) != 'undefined') {
				binom_board.removeObject(binom_shadeleft.bars[i].rect);
			}
		}

		binom_n = Number(binom_n_input.rendNodeInput.value);
		binom_p = Number(binom_p_input.rendNodeInput.value);

		var binom_ymax = jStat.binomial.pdf(round(binom_n * binom_p, 0), binom_n, binom_p) * 1.5;
		binom_xmax = binom_n + 1;
		var binom_bounds = JSXGetBounds(binom_board);
		binom_bounds.ymax = binom_ymax;
		binom_bounds.ymin = -binom_ymax;
		binom_bounds.xmax = binom_xmax;

		JSXSetBounds(binom_board, binom_bounds);
		binom_updateAxis(binom_ymax);

		if(binom_x1_input.rendNodeInput.value > binom_xmax) {
			binom_x1_input.rendNodeInput.value = 0;
		}

		if(binom_x2_input.rendNodeInput.value > binom_xmax) {
			binom_x2_input.rendNodeInput.value = binom_xmax - 1;
		}

		binom_mean = binom_n * binom_p;
		binom_stdev = sqrt(binom_n * binom_p * (1 - binom_p));

		binom_x1 = Number(binom_x1_input.rendNodeInput.value);
		binom_x2 = Number(binom_x2_input.rendNodeInput.value);

		binom_p1.moveTo([binom_x1, 0]);
		binom_p2.moveTo([binom_x2, 0]);

		if(binom_n <= 60) {
			binom_shadeleft = new Histogram(binom_board, binom_pdf(), binom_getcolors(), [-0.5, 0], 1);
		}

	} else {
		binom_n = Number(binom_n_input.rendNodeInput.value);
		binom_p = Number(binom_p_input.rendNodeInput.value);

		binom_mean = binom_n * binom_p;
		binom_stdev = sqrt(binom_n * binom_p * (1 - binom_p));

		binom_x1 = Number(binom_x1_input.rendNodeInput.value);
		binom_x2 = Number(binom_x2_input.rendNodeInput.value);

		binom_p1.moveTo([binom_x1, 0]);
		binom_p2.moveTo([binom_x2, 0]);

		binom_update_colors();
		binom_shadeleft.setBarHeights(binom_pdf(), 0);

	}

	binom_prob_disp.setText(') = ' + binom_cprob(binom_x1, binom_x2, binom_n, binom_p, binom_ptype));

	binom_board.unsuspendUpdate();

}

function binom_updateAxis(y_max) {

	var step = 1;

	if (binom_n <= 20) {
		step = 1;
	} else if (binom_n > 20 && binom_n <= 50) {
		step = 2;
	} else if (binom_n > 50 && binom_n <= 100) {
		step = 5;
	} else if (binom_n > 100 && binom_n <= 200) {
		step = 10;
	} else if (binom_n <= 300) {
		step = 20;
	} else {
		step = -1;
	}

	for(var i = 0; i < binom_ticks.length; i++) {
		binom_board.removeObject(binom_ticks[i]);
		binom_board.removeObject(binom_labels[i]);
	}

	if(step > 0) {
		for(var i = 0; i <= (binom_n / step); i++) {
			binom_labels[i] = binom_board.create('text', [(i * step)- (0.05 * y_max), -(0.05 * y_max), i * step], { fixed: true, highlight: false });
			binom_ticks[i] = binom_board.create('segment', [[(i * step), (.01 * y_max)], [(i * step), -(0.01 * y_max)]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
		}
	}

}

function binom_cprob(x1, x2, n, p, type) {

	var prob = -1;

	if(type == BETWEEN) {
		prob = 0;
		if(x2 < x1) { [x1, x2] = swap(x1, x2); }
		for(var i = x1; i <= x2; i++) {
			prob += jStat.binomial.pdf(i, n, p);
		}
	} else if(type == LEFT) {
		prob = jStat.binomial.cdf(x2, n, p);
	} else if(type == RIGHT) {
		prob = 1 - jStat.binomial.cdf(x1 - 1, n, p);
	} else if(type == EQUAL) {
		prob = jStat.binomial.pdf(x2, n, p);
	}

	return round(prob, binom_decimals);

}

function set_binom_cbtrue(box) {
	for(i = 0; i < 4; i++) {
		setCheckbox(binom_cb[i], i == box);
	}
}

</script>

<!--////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////// F-Distribution //////
    ////////////////////////////////////////////////////////////////////////-->

<script type='text/javascript'>

// Initial Values
var f_df1 = 12;
var f_df2 = 10;
var f_mean = jStat.centralF.mean(f_df1, f_df2);
var f_stdev = Math.sqrt(jStat.centralF.variance(f_df1, f_df2));
var f_ymax = jStat.centralF.pdf(jStat.centralF.mode(f_df1, f_df2), f_df1, f_df2) * 1.3;
var f_xmax = 4;
var f_init_x1 = 0.5;
var f_init_x2 = 2;
var f_tick_delta = 0.5;
var f_n_ticks = f_xmax / f_tick_delta;
var f_tick_ratio = 50; // ticks are 1/50 the value of y-max
var f_prob_type = BETWEEN;

var f_board = JXG.JSXGraph.initBoard('f-distribution', {
		boundingbox: [0,f_ymax,f_xmax,-f_ymax],
      	showCopyright: false,
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });



var f_curve = f_board.create('functiongraph', [function(x) { return jStat.centralF.pdf(x, f_df1, f_df2); }],
	{ strokeWidth: 3, fixed: true, 	highlight: false });

var f_axis = f_board.create('line', [[0, 0], [1, 0]], { strokeColor: 'black', strokeWidth: 1, highlight: false, fixed: true, frozen: true });

var f_1 = f_board.create('glider', [f_init_x1, 0, f_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
f_1.on('drag',
	function() {
		if(f_1.X() < 0) {
			f_1.moveTo([0, 0]);
		}
		f_x1_input.rendNodeInput.value = f_1.X().toFixed(2);
		f_df1 = Number(f_df1_input.rendNodeInput.value);
		f_df2 = Number(f_df2_input.rendNodeInput.value);
		f_prob_input.rendNodeInput.value = current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2);
		f_prob_disp.setText(') = ' + current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2));
	}
);

var f_2 = f_board.create('glider', [f_init_x2, 0, f_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
f_2.on('drag',
	function() {
		if(f_2.X() < 0) {
			f_2.moveTo([0, 0]);
		}
		f_x2_input.rendNodeInput.value = f_2.X().toFixed(2);
		f_x2_disp.setText('< <i>X</i> < ' + f_2.X().toFixed(2));
		f_df1 = Number(f_df1_input.rendNodeInput.value);
		f_df2 = Number(f_df2_input.rendNodeInput.value);
		f_prob_input.rendNodeInput.value = current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2);
		f_prob_disp.setText(') = ' + current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2));
	}
);

// Set up the tick marks on the x-axis
var f_ticks = [];
var f_labels = [];

var tick_height = f_ymax / f_tick_ratio;
for (var i = 0; i < f_n_ticks; i++) {
	f_ticks[i] = f_board.create('segment',
			[[i * f_tick_delta, tick_height], [i * f_tick_delta, -tick_height]],
			{ color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
}

for (var i = 1; i < f_n_ticks; i++) {
	f_labels[i-1] = f_board.create('text',
			[i * f_tick_delta, -2 * tick_height, i * f_tick_delta ],
			{ fixed: true, highlight: false });

}

// input variables

var f_df1_input = f_board.create('input', [2.5, 0.9, f_df1, 'df 1 = '], inputParam);

var f_df2_input = f_board.create('input', [2.5, 0.75, f_df2, 'df 2 = '], inputParam);

// display for the mean and standard deviation

var f_mean_disp = f_board.create('text', [2.65, 0.6,
		function() { return '&mu; = ' + f_mean.toFixed(4); }], textParam);

var f_stdev_disp = f_board.create('text', [2.65, 0.45,
		function() { return '&sigma; = ' + f_stdev.toFixed(4); }], textParam);

var f_shadeleft = f_board.create('integral',
		[[ function() { return 0; } , function() { return f_2.X(); }], f_curve], shadeParam);
f_shadeleft.setAttribute({ visible: false });

var f_shaderight = f_board.create('integral',
		[[ function() { return f_1.X(); }, function() { return 100; }], f_curve], shadeParam);
f_shaderight.setAttribute({ visible: false });

var f_shadebetween = f_board.create('integral',
		[[ function() { return f_1.X(); }, function() { return f_2.X(); }], f_curve], shadeParam);

var f_x1_input = f_board.create('input', [0.2, -0.6, f_1.X(), 'P( '], inputParam);

var f_x2_input = f_board.create('input', [1.25, -0.6, f_2.X(), ' < <i>X</i> < '], inputParam);

var f_x2_disp = f_board.create('text', [1.25, -0.6, '< <i>X</i> < 2'], textParam);
f_x2_disp.setAttribute({ visible: false });

var f_prob_input = f_board.create('input', [2.5, -0.6, current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2), ') = '], inputParam);
f_prob_input.setAttribute({ visible: false });

var f_prob_disp = f_board.create('text', [2.5, -0.6, ') = ' + current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2)], textParam);

// Buttons

var f_calc_button = f_board.create('button', [2.75, -0.8, 'Calculate',
	function () {

		if(isChecked(f_cb_area)) {
			if(!isNaN(f_x1_input.Value())) {
				f_1.moveTo([f_x1_input.Value(), 0]);
			}

			if(!isNaN(f_x2_input.Value())) {
				f_2.moveTo([f_x2_input.Value(), 0]);
			}
			f_df1 = Number(f_df1_input.rendNodeInput.value);
			f_df2 = Number(f_df2_input.rendNodeInput.value);
			f_prob_input.rendNodeInput.value = current_f_probability(f_x1_input.Value(), f_x2_input.Value(), f_df1, f_df2);
			f_prob_disp.setText(') = ' + current_f_probability(f_x1_input.Value(), f_x2_input.Value(), f_df1, f_df2));

		} else {
			if(!isNaN(f_prob_input.Value())) {

				f_df1 = Number(f_df1_input.rendNodeInput.value);
				f_df2 = Number(f_df2_input.rendNodeInput.value);
				var f = jStat.centralF.inv(f_prob_input.Value(), f_df1, f_df2);
				f_2.moveTo([f, 0]);
				f_x2_input.rendNodeInput.value = f;
				f_x2_disp.setText('< <i>X</i> < ' + f.toFixed(8));

			}
		}
}], { frozen: true });

var f_update = f_board.create('button', [2.75, 0.3, 'Update', function() {

		var new_df1 = f_df1_input.rendNodeInput.value;
		var new_df2 = f_df2_input.rendNodeInput.value;

		if ((new_df1 >= 1) && (new_df2 >= 1)) {

			f_df1 = Number(new_df1);
			f_df2 = Number(new_df2);

			if ((f_df1 >= 1) && (f_df1 < 2)) {
				f_ymax = 2.5;
			} else if ((f_df1 >= 2) && (f_df1 < 3)) {
				f_ymax = 1.5;
			} else {
				f_ymax = jStat.centralF.pdf(jStat.centralF.mode(f_df1, f_df2), f_df1, f_df2) * 1.3;
			}

			f_board.setBoundingBox([0, f_ymax, f_xmax, -f_ymax]);
			var tick_height = f_ymax / f_tick_ratio;

			// Update the display for just the labels and ticks we want
			for (var i = 0; i < f_n_ticks; i++) {
				f_ticks[i].point1.moveTo([i * f_tick_delta, tick_height]);
				f_ticks[i].point2.moveTo([i * f_tick_delta, -tick_height]);
			}

			for (var i = 1; i < f_n_ticks; i++) {
				f_labels[i-1].setText(i * f_tick_delta);
				f_labels[i-1].moveTo([i * f_tick_delta, -2 * tick_height]);
			}

			if (f_df2 <= 2) {
				f_mean = NaN;
			} else {
				f_mean = jStat.centralF.mean(f_df1, f_df2);
				f_stdev = Math.sqrt(jStat.centralF.variance(f_df1, f_df2));
			}


			var cur_x1 = f_x1_input.rendNodeInput.value;
			var cur_x2 = f_x2_input.rendNodeInput.value;

			f_1.moveTo([cur_x1, 0]);
			f_2.moveTo([cur_x2, 0]);

			f_x1_input.rendNodeInput.value = cur_x1;
			f_x2_input.rendNodeInput.value = cur_x2;
			f_x2_disp.setText('< <i>X</i> < ' + Number(cur_x2).toFixed(8));

			f_prob_input.rendNodeInput.value = current_f_probability(cur_x1, cur_x2, f_df1, f_df2);
			f_prob_disp.setText(') = ' + current_f_probability(cur_x1, cur_x2, f_df1, f_df2));

		}

		//f_df_input.rendNodeInput.value = f_df;

}], { frozen: true });

// Checkboxes

var f_cb_area = JSXCheckbox(f_board, 2.25, -0.2, 'Calculate Area', true,
	function() {
		setCheckbox(f_cb_area, true);
		setCheckbox(f_cb_xvalue, false);

		f_cb[BETWEEN].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		f_cb[LEFT].setAttribute( { disabled: false });
		f_cb[RIGHT].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });

		f_prob_input.setAttribute( { visible: false });
		f_prob_disp.setAttribute( { visible: true });

		f_x2_input.setAttribute( { disabled: false });
		f_x2_input.setAttribute( { visible: true });
		f_x2_disp.setAttribute({ visible: false });

		f_prob_type = LEFT;

	}, { fontSize: 18, frozen: true });

var f_cb_xvalue = JSXCheckbox(f_board, 2.25, -0.325, 'Calculate x-Value', false,
	function() {
		setCheckbox(f_cb_xvalue, true);
		setCheckbox(f_cb_area, false);

		f_cb[BETWEEN].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		f_cb[LEFT].setAttribute( { disabled: false });
		f_cb[RIGHT].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		set_f_cbtrue(LEFT);
		f_prob_type = LEFT;

		f_1.setAttribute({ visible: false });
		f_2.setAttribute({ visible: true });

		f_shadeleft.setAttribute({ visible: true });
		f_shaderight.setAttribute({ visible: false });
		f_shadebetween.setAttribute({ visible: false });

		f_x1_input.rendNodeInput.value = '0';
		f_x1_input.setAttribute({ disabled: true });

		f_x2_input.rendNodeInput.value = f_2.X().toFixed(2);
		f_x2_input.setAttribute({ visible: false });
		f_x2_disp.setAttribute({ visible: true });

		f_prob_input.setAttribute({ visible: true });
		f_prob_disp.setAttribute({ visible: false });

		f_2.moveTo([f_x2_input.rendNodeInput.value, 0]);

	}, { fontSize: 18, frozen: true });

var f_cb = [];

f_cb[BETWEEN] = JSXCheckbox(f_board, 0.2, -0.2, 'P(a < x < b)', true,
	function() {
		set_f_cbtrue(BETWEEN);
		f_prob_type = BETWEEN;

		f_shadeleft.setAttribute({ visible: false });
		f_shaderight.setAttribute({ visible: false });
		f_shadebetween.setAttribute({ visible: true });

		f_1.setAttribute({ visible: true });
		f_2.setAttribute({ visible: true });

		f_x1_input.rendNodeInput.value = f_1.X().toFixed(2);
		f_x1_input.setAttribute({ disabled: false });

		f_x2_input.rendNodeInput.value = f_2.X().toFixed(2);
		f_x2_input.setAttribute({ visible: true });
		f_x2_input.setAttribute({ disabled: false });
		f_x2_disp.setAttribute({ visible: false });

		f_prob_input.setAttribute({ visible: false });
		f_prob_disp.setAttribute({ visible: true });

	}, { fontSize: 18, frozen: true });

f_cb[LEFT] = JSXCheckbox(f_board, 0.2, -0.325, 'P(x < b)', false,
	function() {
		set_f_cbtrue(LEFT);
		f_prob_type = LEFT;

		f_1.setAttribute({ visible: false });
		f_2.setAttribute({ visible: true });

		f_shadeleft.setAttribute({ visible: true });
		f_shaderight.setAttribute({ visible: false });
		f_shadebetween.setAttribute({ visible: false });

		f_x1_input.rendNodeInput.value = '0';
		f_x1_input.setAttribute({ disabled: true });

		f_x2_input.rendNodeInput.value = f_2.X().toFixed(2);
		f_x2_input.setAttribute({ visible: true });
		f_x2_input.setAttribute({ disabled: false });
		f_x2_disp.setAttribute({ visible: false });

		f_prob_input.setAttribute({ visible: false });
		f_prob_disp.setAttribute({ visible: true });

	}, { fontSize: 18, frozen: true });

f_cb[RIGHT] = JSXCheckbox(f_board, 0.2, -0.45, 'P(x > a)', false,
	function() {
		set_f_cbtrue(RIGHT);
		f_prob_type = RIGHT;

		f_1.setAttribute({ visible: true });
		f_2.setAttribute({ visible: false });

		f_shadeleft.setAttribute({ visible: false });
		f_shaderight.setAttribute({ visible: true });
		f_shadebetween.setAttribute({ visible: false });

		f_x1_input.rendNodeInput.value = f_1.X().toFixed(2);
		f_x1_input.setAttribute({ disabled: false });

		f_x2_input.rendNodeInput.value = 'Infinity';
		f_x2_input.setAttribute({ visible: true });
		f_x2_input.setAttribute({ disabled: true });
		f_x2_disp.setAttribute({ visible: false });

		f_prob_input.setAttribute({ visible: false });
		f_prob_disp.setAttribute({ visible: true });

	}, { fontSize: 18, frozen: true });

function current_f_probability(x1, x2, df1, df2) {

	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	if(typeof(df1) !== 'number') {
		df1 = Number(df1);
	}
	if(typeof(df2) !== 'number') {
		df2 = Number(df2);
	}

	if(f_prob_type == BETWEEN) {

		var v1 = jStat.centralF.cdf(x1, df1, df2);
		var v2 = jStat.centralF.cdf(x2, df1, df2);

		return (v2 - v1).toFixed(4);

	} else if(f_prob_type == LEFT) {

		return jStat.centralF.cdf(x2, df1, df2).toFixed(4);

	} else if(f_prob_type == RIGHT) {

		return (1 - jStat.centralF.cdf(x1, df1, df2)).toFixed(4);

	}

}

function set_f_cbtrue(box) {
	f_cb[BETWEEN].rendNodeCheckbox.checked = false;
	f_cb[LEFT].rendNodeCheckbox.checked = false;
	f_cb[RIGHT].rendNodeCheckbox.checked = false;
	f_cb[BETWEEN]._value = false;
	f_cb[LEFT]._value = false;
	f_cb[RIGHT]._value = false;
	f_cb[box].rendNodeCheckbox.checked = true;
	f_cb[box]._value = true;
}
</script>

</body>
</html>
