<!DOCTYPE html>
<html lang = "en-US">

<head>

	<title>Statistics Calculator</title>
	<meta charset="utf-8">  
	
	<link rel='stylesheet' type='text/css' href='./js/jsxgraph.css' />
	<script src='./js/jsxgraphcore.js' type='text/javascript'></script>
	<script src='./js/MathFunctions.js' type='text/javascript'></script>
	<script src='./js/helpers.js' type='text/javascript'></script>
	<script src="./js/jstat.min.js"></script>
	
	<style>
		body {
			font-family: Arial;
		}
		
		/* Style the tab */
		.tab {
			overflow: hidden;
			border: 1px solid #ccc;
			background-color: #f1f1f1;
			width: 540px;
		}
		
		/* Style the buttons that are used to open the tab content */
		.tab button {
			background-color: inherit;
			float: left;
			border: none;
			outline: none;
			cursor: pointer;
			padding: 14px 16px;
			transition: 0.3s;
		}
		
		/* Change background color of buttons on hover */
		.tab button:hover {
			background-color: #ddd;
		}
		
		/* Create an active/current tablink class */
		.tab button.active {
			background-color: #ccc;
		}
		
		/* Style the tab content */
		.tabcontent {
			display: none;
			padding: 6px 12px;
			border: 1px solid #ccc;
			border-top: none;
		}
		
	</style>
	
</head>

<body>

<h1>Statistics Calculator</h1>


<!-- Tab links -->
<div class="tab">
	<button class="tablinks" id="defaultOpen" onclick="openTool(event, 'standard_normal')">Normal</button>
	<button class="tablinks" onclick="openTool(event, 't-distribution')">T-Dist</button>
	<button class="tablinks" onclick="openTool(event, 'chi-distribution')">&Chi;<sup>2</sup></button>
	<button class="tablinks" onclick="openTool(event, 'f-distribution')">F</button>
</div>

<!-- Tab content -->
<div id="standard_normal" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="t-distribution" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="chi-distribution" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="f-distribution" class="jxgbox" style="width:540px; height:540px;"></div>


<script>
function openTool(evt, tool) {
	// Declare all variables
	var i, tabcontent, tablinks;

	// Get all elements with class="tabcontent" and hide them
	tabcontent = document.getElementsByClassName("jxgbox");
	for (i = 0; i < tabcontent.length; i++) {
		tabcontent[i].style.display = "none";
	}

	// Get all elements with class="tablinks" and remove the class "active"
	tablinks = document.getElementsByClassName("tablinks");
	for (i = 0; i < tablinks.length; i++) {
		tablinks[i].className = tablinks[i].className.replace(" active", "");
	}

	// Show the current tab, and add an "active" class to the button that opened the tab
	document.getElementById(tool).style.display = "block";
	evt.currentTarget.className += " active";
}
document.getElementById("defaultOpen").click();
</script>


<script>
	// Define global variables

	var shadeParam = { 
		color: '#0000FF', 
		fillOpacity: 0.4, 
		withLabel: false,
		fixed: true,
		highlight: false,
		curveLeft: { visible: false },
		curveRight: { visible: false },
	};
	
	var PTYPE = 'between';
	
	var BETWEEN = 0;
	var LEFT = 1;
	var RIGHT = 2;
	
</script>


<script>

var board_normal = JXG.JSXGraph.initBoard('standard_normal', {
		boundingbox: [-4,0.5,4,-0.5], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },	
		pan: {
			enabled: false
		}
    });

mean_n = 0;
stdev_n = 1;		
			
	
function zScore(x) {
	return (x - mean_n) / stdev_n;
}
			
function xValue(z) {
	return mean_n + z * stdev_n;
}				
			
normal_curve = board_normal.create('functiongraph', [function(x) { return normalpdf(zScore(x)); }], 
	{ strokeWidth: 3, fixed: true, 	highlight: false });
	
hidden_axis = board_normal.create('line', [[0, 0], [1, 0]], { visible: false });

x_axis = board_normal.create('axis', [[0, 0], [1, 0]], 
	{ ticks: { visible: false } });
	
z1 = board_normal.create('glider', [-2, 0, x_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
z1.on('drag', 
	function() { 
		x1_input.rendNodeInput.value = z1.X().toFixed(2);
		prob_input.rendNodeInput.value = currentProbability(zScore(z1.X()), zScore(z2.X()));
		prob_disp.setText(') = ' + currentProbability(zScore(z1.X()), zScore(z2.X())));
	}
);

z2 = board_normal.create('glider', [2, 0, x_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
z2.on('drag', 
	function() { 
		x2_input.rendNodeInput.value = z2.X().toFixed(2);
		x2_disp.setText('< <i>X</i> < ' + z2.X().toFixed(2));
		prob_input.rendNodeInput.value = currentProbability(zScore(z1.X()), zScore(z2.X()));
		prob_disp.setText(') = ' + currentProbability(zScore(z1.X()), zScore(z2.X())));
	}
);

ticks_n = [];
labels_n = [];
for (var i = -3; i <= 3; i++) {
	ticks_n[i + 3] = board_normal.create('segment', [[i,.01], [i,-0.01]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
	labels_n[i + 3] = board_normal.create('text', [i-.05, -0.02, i], { fixed: true, highlight: false });
}

// input variables

mean = board_normal.create('input', [1.3, 0.38, '0', '&mu; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });
stdev = board_normal.create('input', [1.3, 0.3, '1', '&sigma; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });

x1_input = board_normal.create('input', [-3.5, -0.32, '-2', 'P( '], { fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
x2_input = board_normal.create('input', 
		[-1.3, -0.32, '2', ' < <i>X</i> < '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
x2_disp = board_normal.create('text', [-1.3, -0.32, '< <i>X</i> < 2'],
		{ fontSize: 18, frozen: true, visible: false });		
		
prob_input = board_normal.create('input', [1.3, -0.32, '0.9500', ') = '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
prob_input.setAttribute( { visible: false } );

prob_disp = board_normal.create('text', [1.3, -0.32, ') = 0.9500'],
		{ fontSize: 18, frozen: true, fixed: true });


calc_normal = board_normal.create('button', [1.5, -0.42, 'Calculate',
	function () {
	
		if(isChecked(cb_area)) {
			if(!isNaN(x1_input.Value())) {
				z1.moveTo([x1_input.Value(), 0]);
			}
	
			if(!isNaN(x2_input.Value())) {
				z2.moveTo([x2_input.Value(), 0]);
			}
	
			prob_input.rendNodeInput.value = currentProbability(zScore(x1_input.Value()), zScore(x2_input.Value()));
			prob_disp.setText(') = ' + currentProbability(zScore(x1_input.Value()), zScore(x2_input.Value())));
		
		} else {
			if(!isNaN(prob_input.Value())) {
			
				var z = xValue(invnorm(prob_input.Value()));
				z2.moveTo([z, 0]);
				x2_input.rendNodeInput.value = z;
				x2_disp.setText('< <i>X</i> < ' + z.toFixed(8));
		
			}
		}
}], { frozen: true });


function updateAxisLabels() {
	
	for(var i = -3; i <= 3; i++) {
		ticks_n[i + 3].point1.moveTo([xValue(i), 0.01]);
		ticks_n[i + 3].point2.moveTo([xValue(i), -0.01]);
		labels_n[i + 3].setText(xValue(i));
		labels_n[i + 3].setCoords([xValue(i), -0.02]);
	}
	
}

update_normal = board_normal.create('button', [2.5, 0.22, 'Update', 
	
	// If a new mean and standard deviation are provided, then we need to:
	//   - change the bounds on the x-axis
	//   - set the global mean_n and stdev_n variables
	//   - reset the positions of z1 and z2 on the x-axis so that they are accessible again
	
	function() {
		var cur_z1 = zScore(z1.X());
		var cur_z2 = zScore(z2.X());
		mean_n = Number(mean.Value());
		stdev_n = Number(eval(stdev.Value()));
		var x_min = xValue(-4);
		var x_max = xValue(4);
		//JSXSetBounds(board_normal, { xmin: x_min, xmax: x_max }, false);
		board_normal.setBoundingBox([x_min, 0.5, x_max, -0.5]);
		z1.moveTo([xValue(cur_z1), 0]);
		z2.moveTo([xValue(cur_z2), 0]);
		x1_input.rendNodeInput.value = xValue(cur_z1);
		x2_input.rendNodeInput.value = xValue(cur_z2);
		x2_disp.setText('< <i>X</i> < ' + xValue(cur_z2).toFixed(8));
		prob_input.rendNodeInput.value = currentProbability(cur_z1, cur_z2);
		updateAxisLabels();
		
	}
	
], { frozen: true });


shadedregionleft = board_normal.create('integral', 
	[[ function() { return xValue(-10000); }, function() { return z2.X(); }], normal_curve], shadeParam);
shadedregionleft.setAttribute({ visible: false });

shadedregionright = board_normal.create('integral', 
	[[ function() { return z1.X(); }, function() { return xValue(10000); }], normal_curve], shadeParam);
shadedregionright.setAttribute({ visible: false });

shadedregionbetween = board_normal.create('integral', 
	[[ function() { return z1.X(); }, function() { return z2.X(); }], normal_curve], shadeParam);


cb_area = JSXCheckbox(board_normal, 1, -0.1, 'Calculate Area', true,
	function() {
		setCheckbox(cb_area, true);
		setCheckbox(cb_xvalue, false);
		
		cb_between.setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		cb_left.setAttribute( { disabled: false });
		cb_right.setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		
		prob_input.setAttribute( { visible: false });
		prob_disp.setAttribute( { visible: true });
		x2_input.setAttribute( { visible: true });
		x2_disp.setAttribute({ visible: false });
		
				
	}, { fontSize: 18, frozen: true });

cb_xvalue = JSXCheckbox(board_normal, 1, -0.16, 'Calculate x-Value', false,
	function() {
		setCheckbox(cb_xvalue, true);
		setCheckbox(cb_area, false);
		
		cb_between.setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		cb_left.setAttribute( { disabled: false });
		cb_right.setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		setCheckbox(cb_left, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_right, false);
		
		z1.setAttribute({ visible: false });
		z2.setAttribute({ visible: true });
		
		shadedregionleft.setAttribute({ visible: true });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1_input.rendNodeInput.value = '-Infinity';
		x1_input.setAttribute({ disabled: true });
	
		x2_input.rendNodeInput.value = z2.X().toFixed(2);
		x2_input.setAttribute({ visible: false });
		x2_disp.setAttribute({ visible: true });

		
		prob_input.setAttribute({ visible: true });
		prob_disp.setAttribute({ visible: false });
		
		PTYPE = 'left';
		
		
	}, { fontSize: 18, frozen: true });

cb_between = JSXCheckbox(board_normal, -3.6, -0.1, 'P(a < x < b)', true, 
	function() {
		setCheckbox(cb_between, true);
		setCheckbox(cb_left, false);
		setCheckbox(cb_right, false);

		shadedregionleft.setAttribute({ visible: false });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: true });
			
		z1.setAttribute({ visible: true });
		z2.setAttribute({ visible: true });
		
		x1_input.rendNodeInput.value = z1.X().toFixed(2);
		x1_input.setAttribute({ disabled: false });
		
		x2_input.rendNodeInput.value = z2.X().toFixed(2);
		x2_input.setAttribute({ visible: true });
		x2_disp.setAttribute({ visible: false });
		
		prob_input.setAttribute({ visible: false });
		prob_disp.setAttribute({ visible: true });
		
		PTYPE = 'between';
			
	}, { fontSize: 18, frozen: true });

cb_left = JSXCheckbox(board_normal, -3.6, -0.16, 'P(x < b)', false,
	function() {
		setCheckbox(cb_left, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_right, false);
		
		z1.setAttribute({ visible: false });
		z2.setAttribute({ visible: true });
		
		shadedregionleft.setAttribute({ visible: true });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1_input.rendNodeInput.value = '-Infinity';
		x1_input.setAttribute({ disabled: true });
	
		x2_input.rendNodeInput.value = z2.X().toFixed(2);
		x2_input.setAttribute({ visible: true });
		x2_disp.setAttribute({ visible: false });

		
		prob_input.setAttribute({ visible: false });
		prob_disp.setAttribute({ visible: true });
		
		PTYPE = 'left';
		
	}, { fontSize: 18, frozen: true });

cb_right = JSXCheckbox(board_normal, -3.6, -0.22, 'P(x > a)', false,
	function() {
		setCheckbox(cb_right, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_left, false);
		
		z1.setAttribute({ visible: true });
		z2.setAttribute({ visible: false });
		
		shadedregionleft.setAttribute({ visible: false });
		shadedregionright.setAttribute({ visible: true });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1_input.rendNodeInput.value = z1.X().toFixed(2);
		x1_input.setAttribute({ disabled: false });
		
		x2_input.rendNodeInput.value = 'Infinity';
		x2_input.setAttribute({ visible: true });
		x2_input.setAttribute({ disabled: true });
		x2_disp.setAttribute({ visible: false });
		
		prob_input.setAttribute({ visible: false });
		prob_disp.setAttribute({ visible: true });
		
		PTYPE = 'right';
	
	}, { fontSize: 18, frozen: true });


function currentProbability(x1, x2) { 
	
	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	
	if(cb_between.Value()) { 
		return Math.abs(normalcdf(x2) - normalcdf(x1)).toFixed(4);
	} else if(cb_left.Value()) {
		return normalcdf(x2).toFixed(4);
	} else if(cb_right.Value()) {
		return (1 - normalcdf(x1)).toFixed(4);
	} 

}


</script>


<script type='text/javascript'>
		
var t_board = JXG.JSXGraph.initBoard('t-distribution', {
		boundingbox: [-4,0.5,4,-0.5],
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });
		
var t_mean = 0;
var t_stdev = 1;
var t_df = 10;	
			
	
function tScore(x) {
	return (x - t_mean) / t_stdev;
}
			
function t_xval(t) {
	return t_mean + t * t_stdev;
}		
			
var t_curve = t_board.create('functiongraph', [function(x) { return tpdf(tScore(x), t_df); }], 
	{ strokeWidth: 3, fixed: true, 	highlight: false });
	
var t_axis = t_board.create('line', [[0, 0], [1, 0]], { strokeColor: 'black', strokeWidth: 1, highlight: false, fixed: true, frozen: true });
	
var t1 = t_board.create('glider', [-2, 0, t_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
t1.on('drag', 
	function() { 
		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_df = Number(t_df_input.rendNodeInput.value);
		t_prob_input.rendNodeInput.value = currentTProbability(tScore(t1.X()), tScore(t2.X()), t_df);
		t_prob_disp.setText(') = ' + currentTProbability(tScore(t1.X()), tScore(t2.X()), t_df));
	}
);

var t2 = t_board.create('glider', [2, 0, t_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
t2.on('drag', 
	function() { 
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_x2_disp.setText('< <i>X</i> < ' + t2.X().toFixed(2));
		t_df = Number(t_df_input.rendNodeInput.value);
		t_prob_input.rendNodeInput.value = currentTProbability(tScore(t1.X()), tScore(t2.X()), t_df);
		t_prob_disp.setText(') = ' + currentTProbability(tScore(t1.X()), tScore(t2.X()), t_df));
	}
);
		
var t_ticks = [];
var t_labels = [];
for (var i = -3; i <= 3; i++) {
	t_ticks[i + 3] = t_board.create('segment', [[i,.01], [i,-0.01]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
	t_labels[i + 3] = t_board.create('text', [i-.05, -0.02, i], { fixed: true, highlight: false });
}

// input variables

var t_df_input = t_board.create('input', [1.3, 0.45, t_df, 'df = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });	
var t_mean_input = t_board.create('input', [1.3, 0.38, '0', '&mu; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });
var t_stdev_input = t_board.create('input', [1.3, 0.3, '1', '&sigma; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });
		
var t_shadeleft = t_board.create('integral', 
	[[ function() { return t_xval(-10000); }, function() { return t2.X(); }], t_curve], shadeParam);
t_shadeleft.setAttribute({ visible: false });

var t_shaderight = t_board.create('integral', 
	[[ function() { return t1.X(); }, function() { return t_xval(10000); }], t_curve], shadeParam);
t_shaderight.setAttribute({ visible: false });

var t_shadebetween = t_board.create('integral', 
	[[ function() { return t1.X(); }, function() { return t2.X(); }], t_curve], shadeParam);
		
var t_x1_input = t_board.create('input', [-3.5, -0.32, '-2', 'P( '], { fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });

var t_x2_input = t_board.create('input', [-1.3, -0.32, '2', ' < <i>X</i> < '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
		
var t_x2_disp = t_board.create('text', [-1.3, -0.32, '< <i>X</i> < 2'],
		{ fontSize: 18, frozen: true, visible: false, fixed: true });		
		
var t_prob_input = t_board.create('input', [1.3, -0.32, '0.9500', ') = '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
t_prob_input.setAttribute({ visible: false });

var t_prob_disp = t_board.create('text', [1.3, -0.32, ') = 0.9500'],
		{ fontSize: 18, frozen: true, fixed: true });		
		
t_board.update();
		
// Buttons

var t_calc_button = t_board.create('button', [1.5, -0.42, 'Calculate',
	function () {
	
		if(isChecked(t_cb_area)) {
			if(!isNaN(t_x1_input.Value())) {
				t1.moveTo([t_x1_input.Value(), 0]);
			}
	
			if(!isNaN(t_x2_input.Value())) {
				t2.moveTo([t_x2_input.Value(), 0]);
			}
			t_df = Number(t_df_input.rendNodeInput.value);
			t_prob_input.rendNodeInput.value = currentTProbability(tScore(t_x1_input.Value()), tScore(t_x2_input.Value()), t_df);
			t_prob_disp.setText(') = ' + currentTProbability(tScore(t_x1_input.Value()), tScore(t_x2_input.Value()), t_df));
		
		} else {
			if(!isNaN(t_prob_input.Value())) {
			
				t_df = Number(t_df_input.rendNodeInput.value);
				var t = t_xval(tinv(t_prob_input.Value(), t_df));
				t2.moveTo([t, 0]);
				t_x2_input.rendNodeInput.value = t;
				t_x2_disp.setText('< <i>X</i> < ' + t.toFixed(8));
		
			}
		}
}], { frozen: true });		
		
var t_update = t_board.create('button', [2.5, 0.22, 'Update', 
		
	function() {
		var cur_z1 = tScore(t1.X());
		var cur_z2 = tScore(t2.X());
		t_mean = Number(t_mean_input.Value());
		t_stdev = Number(eval(t_stdev_input.Value()));
		var x_min = t_xval(-4);
		var x_max = t_xval(4);
		t_board.setBoundingBox([x_min, 0.5, x_max, -0.5]);
		t1.moveTo([t_xval(cur_z1), 0]);
		t2.moveTo([t_xval(cur_z2), 0]);
		t_x1_input.rendNodeInput.value = t_xval(cur_z1);
		t_x2_input.rendNodeInput.value = t_xval(cur_z2);
		t_x2_disp.setText('< <i>X</i> < ' + t_xval(cur_z2).toFixed(8));
		t_df = Number(t_df_input.rendNodeInput.value);
		t_prob_input.rendNodeInput.value = currentTProbability(cur_z1, cur_z2, t_df);
		updateTAxisLabels();
		
	}
	
], { frozen: true });		
		
// Checkboxes

var t_cb_area = JSXCheckbox(t_board, 1, -0.1, 'Calculate Area', true,
	function() {
		setCheckbox(t_cb_area, true);
		setCheckbox(t_cb_xvalue, false);
		
		t_cb[BETWEEN].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		t_cb[LEFT].setAttribute( { disabled: false });
		t_cb[RIGHT].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		
		t_prob_input.setAttribute( { visible: false });
		t_prob_disp.setAttribute( { visible: true });
		
		t_x2_input.setAttribute( { disabled: false });
		t_x2_input.setAttribute( { visible: true });
		t_x2_disp.setAttribute({ visible: false });
		
				
	}, { fontSize: 18, frozen: true });

var t_cb_xvalue = JSXCheckbox(t_board, 1, -0.16, 'Calculate x-Value', false,
	function() {
		setCheckbox(t_cb_xvalue, true);
		setCheckbox(t_cb_area, false);
		
		t_cb[BETWEEN].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		t_cb[LEFT].setAttribute( { disabled: false });
		t_cb[RIGHT].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		set_t_cbtrue(LEFT);
		
		t1.setAttribute({ visible: false });
		t2.setAttribute({ visible: true });
		
		t_shadeleft.setAttribute({ visible: true });
		t_shaderight.setAttribute({ visible: false });
		t_shadebetween.setAttribute({ visible: false });
		
		t_x1_input.rendNodeInput.value = '-Infinity';
		t_x1_input.setAttribute({ disabled: true });
	
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_x2_input.setAttribute({ visible: false });
		t_x2_disp.setAttribute({ visible: true });
		
		t_prob_input.setAttribute({ visible: true });
		t_prob_disp.setAttribute({ visible: false });
		
		t2.moveTo([t_x2_input.rendNodeInput.value, 0]);
		
	}, { fontSize: 18, frozen: true });

var t_cb = [];

t_cb[BETWEEN] = JSXCheckbox(t_board, -3.6, -0.1, 'P(a < x < b)', true, 
	function() {
		set_t_cbtrue(BETWEEN);

		t_shadeleft.setAttribute({ visible: false });
		t_shaderight.setAttribute({ visible: false });
		t_shadebetween.setAttribute({ visible: true });
			
		t1.setAttribute({ visible: true });
		t2.setAttribute({ visible: true });
		
		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_x1_input.setAttribute({ disabled: false });
		
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_x2_input.setAttribute({ visible: true });
		t_x2_input.setAttribute({ disabled: false });
		t_x2_disp.setAttribute({ visible: false });
		
		t_prob_input.setAttribute({ visible: false });
		t_prob_disp.setAttribute({ visible: true });
			
	}, { fontSize: 18, frozen: true });

t_cb[LEFT] = JSXCheckbox(t_board, -3.6, -0.16, 'P(x < b)', false,
	function() {
		set_t_cbtrue(LEFT);
		
		t1.setAttribute({ visible: false });
		t2.setAttribute({ visible: true });
		
		t_shadeleft.setAttribute({ visible: true });
		t_shaderight.setAttribute({ visible: false });
		t_shadebetween.setAttribute({ visible: false });
		
		t_x1_input.rendNodeInput.value = '-Infinity';
		t_x1_input.setAttribute({ disabled: true });
	
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_x2_input.setAttribute({ visible: true });
		t_x2_input.setAttribute({ disabled: false });
		t_x2_disp.setAttribute({ visible: false });
		
		t_prob_input.setAttribute({ visible: false });
		t_prob_disp.setAttribute({ visible: true });
		
	}, { fontSize: 18, frozen: true });

t_cb[RIGHT] = JSXCheckbox(t_board, -3.6, -0.22, 'P(x > a)', false,
	function() {
		set_t_cbtrue(RIGHT);
		
		t1.setAttribute({ visible: true });
		t2.setAttribute({ visible: false });
		
		t_shadeleft.setAttribute({ visible: false });
		t_shaderight.setAttribute({ visible: true });
		t_shadebetween.setAttribute({ visible: false });
		
		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_x1_input.setAttribute({ disabled: false });
		
		t_x2_input.rendNodeInput.value = 'Infinity';
		t_x2_input.setAttribute({ visible: true });
		t_x2_input.setAttribute({ disabled: true });
		t_x2_disp.setAttribute({ visible: false });
		
		t_prob_input.setAttribute({ visible: false });
		t_prob_disp.setAttribute({ visible: true });
	
	}, { fontSize: 18, frozen: true });

function updateTAxisLabels() {
	
	for(var i = -3; i <= 3; i++) {
		t_ticks[i + 3].point1.moveTo([t_xval(i), 0.01]);
		t_ticks[i + 3].point2.moveTo([t_xval(i), -0.01]);
		t_labels[i + 3].setText(t_xval(i));
		t_labels[i + 3].setCoords([t_xval(i), -0.02]);
	}
	
}

function currentTProbability(x1, x2, df) { 
	
	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	if(typeof(df) !== 'number') {
		df = Number(df);
	}
	
	if(t_cb[BETWEEN].Value()) { 
		return Math.abs(tcdf(x2, df) - tcdf(x1, df)).toFixed(4);
	} else if(t_cb[LEFT].Value()) {
		return tcdf(x2, df).toFixed(4);
	} else if(t_cb[RIGHT].Value()) {
		return (1 - tcdf(x1, df)).toFixed(4);
	} 

}

function set_t_cbtrue(box) {
	t_cb[BETWEEN].rendNodeCheckbox.checked = false;
	t_cb[LEFT].rendNodeCheckbox.checked = false;
	t_cb[RIGHT].rendNodeCheckbox.checked = false;
	t_cb[BETWEEN]._value = false;
	t_cb[LEFT]._value = false;
	t_cb[RIGHT]._value = false;
	t_cb[box].rendNodeCheckbox.checked = true;
	t_cb[box]._value = true;
}

	
</script>


<script type='text/javascript'>
		
var chi_board = JXG.JSXGraph.initBoard('chi-distribution', {
		boundingbox: [0,0.5,24,-0.5],
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });
		
var chi_mean = 6;
var chi_stdev = Math.sqrt(jStat.chisquare.variance(6));
var chi_df = 6;	
			
	
function chi_score(x) {
	return (x - chi_mean) / chi_stdev;
}
			
function chi_xval(t) {
	return chi_mean + t * chi_stdev;
}		
			
var chi_curve = chi_board.create('functiongraph', [function(x) { return jStat.chisquare.pdf(x, chi_df); }], 
	{ strokeWidth: 3, fixed: true, 	highlight: false });
	
var chi_axis = chi_board.create('line', [[0, 0], [1, 0]], { strokeColor: 'black', strokeWidth: 1, highlight: false, fixed: true, frozen: true });
	
var chi_1 = chi_board.create('glider', [2, 0, chi_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
chi_1.on('drag', 
	function() { 
		if(chi_1.X() < 0) {
			chi_1.moveTo([0, 0]);
		}
		chi_x1_input.rendNodeInput.value = chi_1.X().toFixed(2);
		chi_df = Number(chi_df_input.rendNodeInput.value);
		chi_prob_input.rendNodeInput.value = current_chi_probability(chi_1.X(), chi_2.X(), chi_df);
		chi_prob_disp.setText(') = ' + current_chi_probability(chi_1.X(), chi_2.X(), chi_df));
	}
);

var chi_2 = chi_board.create('glider', [10, 0, chi_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
chi_2.on('drag', 
	function() { 
		if(chi_2.X() < 0) {
			chi_2.moveTo([0, 0]);
		}
		chi_x2_input.rendNodeInput.value = chi_2.X().toFixed(2);
		chi_x2_disp.setText('< <i>X</i> < ' + chi_2.X().toFixed(2));
		chi_df = Number(chi_df_input.rendNodeInput.value);
		chi_prob_input.rendNodeInput.value = current_chi_probability(chi_1.X(), chi_2.X(), chi_df);
		chi_prob_disp.setText(') = ' + current_chi_probability(chi_1.X(), chi_2.X(), chi_df));
	}
);

// Initialize the tick marks and axis labels so they can be updated later		
var chi_ticks = [];
var chi_labels = [];
for (var i = 0; i < 20; i++) {
	chi_ticks[i] = chi_board.create('segment', [[10, 10], [10, 11]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
}
for (var i = 1; i < 20; i++ ) {
    chi_labels[i-1] = chi_board.create('text', [10, 10, ''], { fixed: true, highlight: false });
}

var x_min = 0;
var x_max = 4 * chi_df;

var chi_tick_delta = 2;
var chi_n_ticks = 20;

chi_set_tick_metrics(chi_df);

var chi_tick_ratio = 50; // ticks are 1/50 the value of y-max
var y_val = chi_df > 2 ? jStat.chisquare.pdf(jStat.chisquare.mode(chi_df), chi_df) * 1.3 : 0.5;

chi_board.setBoundingBox([x_min, y_val, x_max, -y_val]);
var tick_height = y_val / chi_tick_ratio;

for (var i = 0; i < chi_n_ticks; i++) {
	chi_ticks[i].point1.moveTo([i * chi_tick_delta, tick_height]);
	chi_ticks[i].point2.moveTo([i * chi_tick_delta, -tick_height]);
}

for (var i = 1; i < chi_n_ticks; i++) {
	chi_labels[i-1].setText(i * chi_tick_delta);
	chi_labels[i-1].moveTo([i * chi_tick_delta, -2 * tick_height]);				
}

// input variables

var chi_df_input = chi_board.create('input', [15, 0.15, chi_df, 'df = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });	
var chi_mean_disp = chi_board.create('text', [15, 0.125, function() { return '&mu; = ' + chi_mean; }], { fontSize: 18, frozen: true, highlight: false, fixed: true });
var chi_stdev_disp = chi_board.create('text', [15, 0.1, function() { return '&sigma; = ' + chi_stdev.toFixed(4); }], { fontSize: 18, frozen: true, highlight: false, fixed: true });
		
var chi_shadeleft = chi_board.create('integral', 
	[[ 0 , function() { return chi_2.X(); }], chi_curve], shadeParam);
chi_shadeleft.setAttribute({ visible: false });

var chi_shaderight = chi_board.create('integral', 
	[[ function() { return chi_1.X(); }, function() { return 4 * chi_df; }], chi_curve], shadeParam);
chi_shaderight.setAttribute({ visible: false });

var chi_shadebetween = chi_board.create('integral', 
	[[ function() { return chi_1.X(); }, function() { return chi_2.X(); }], chi_curve], shadeParam);
		
var chi_x1_input = chi_board.create('input', [2, -0.11, '2', 'P( '], { fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });

var chi_x2_input = chi_board.create('input', [9, -0.11, '10', ' < <i>X</i> < '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
		
var chi_x2_disp = chi_board.create('text', [9, -0.11, '< <i>X</i> < 2'],
		{ fontSize: 18, frozen: true, visible: false, fixed: true });		
		
var chi_prob_input = chi_board.create('input', [17, -0.11, '0.7950', ') = '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
chi_prob_input.setAttribute({ visible: false });

var chi_prob_disp = chi_board.create('text', [17, -0.11, ') = 0.7950'],
		{ fontSize: 18, frozen: true, fixed: true });		

// Buttons

var chi_calc_button = chi_board.create('button', [15, -0.14, 'Calculate',
	function () {
	
		if(isChecked(chi_cb_area)) {
			if(!isNaN(chi_x1_input.Value())) {
				chi_1.moveTo([chi_x1_input.Value(), 0]);
			}
	
			if(!isNaN(chi_x2_input.Value())) {
				chi_2.moveTo([chi_x2_input.Value(), 0]);
			}
			chi_df = Number(chi_df_input.rendNodeInput.value);
			chi_prob_input.rendNodeInput.value = current_chi_probability(chi_x1_input.Value(), chi_x2_input.Value(), chi_df);
			chi_prob_disp.setText(') = ' + current_chi_probability(chi_x1_input.Value(), chi_x2_input.Value(), chi_df));
		
		} else {
			if(!isNaN(chi_prob_input.Value())) {
			
				chi_df = Number(chi_df_input.rendNodeInput.value);
				var chi = jStat.chisquare.inv(chi_prob_input.Value(), chi_df);
				chi_2.moveTo([chi, 0]);
				chi_x2_input.rendNodeInput.value = chi;
				chi_x2_disp.setText('< <i>X</i> < ' + chi.toFixed(8));
		
			}
		}
}], { frozen: true });		
		
var chi_update = chi_board.create('button', [17, 0.075, 'Update', function() {
		
		var new_df = chi_df_input.rendNodeInput.value;
		
		if (new_df >= 1) {
			
			chi_df = new_df;		
			
			chi_set_tick_metrics(chi_df);
			
			var y_val = chi_df > 2 ? jStat.chisquare.pdf(jStat.chisquare.mode(chi_df), chi_df) * 1.3 : 0.5;

			chi_board.setBoundingBox([x_min, y_val, x_max, -y_val]);
			var tick_height = y_val / chi_tick_ratio;
	
			// Move all ticks and labels off screen
			for (var i = 0; i < 20; i++) {
				chi_ticks[i].point1.moveTo([10, 10]);
				chi_ticks[i].point2.moveTo([10, 11]);
			}
			
			for (var i = 1; i < 20; i++) {
				chi_labels[i-1].setText('');
				chi_labels[i-1].moveTo([10, 10]);				
			}
	
			if (chi_tick_delta != -1) {
	
				// Update the display for just the labels and ticks we want
				for (var i = 0; i < chi_n_ticks; i++) {
					chi_ticks[i].point1.moveTo([i * chi_tick_delta, tick_height]);
					chi_ticks[i].point2.moveTo([i * chi_tick_delta, -tick_height]);
				}
			
				for (var i = 1; i < chi_n_ticks; i++) {
					chi_labels[i-1].setText(i * chi_tick_delta);
					chi_labels[i-1].moveTo([i * chi_tick_delta, -2 * tick_height]);				
				}
			}
			
			chi_mean = jStat.chisquare.mean(chi_df);
			chi_stdev = Math.sqrt(jStat.chisquare.variance(chi_df));

			
			var cur_x1 = chi_x1_input.rendNodeInput.value;
			var cur_x2 = chi_x2_input.rendNodeInput.value;
			
			if(cur_x2 > 4 * chi_df) {
				cur_x2 = 3 * chi_df;
			}
			
			chi_1.moveTo([cur_x1, 0]);
			chi_2.moveTo([cur_x2, 0]);
			
			chi_x1_input.rendNodeInput.value = cur_x1;
			chi_x2_input.rendNodeInput.value = cur_x2;
			chi_x2_disp.setText('< <i>X</i> < ' + Number(cur_x2).toFixed(8));
			
			chi_prob_input.rendNodeInput.value = current_chi_probability(cur_x1, cur_x2, chi_df);
			chi_prob_disp.setText(') = ' + current_chi_probability(cur_x1, cur_x2, chi_df));

		}
		
		chi_df_input.rendNodeInput.value = chi_df;	
		
}], { frozen: true });		
		
// Checkboxes

var chi_cb_area = JSXCheckbox(chi_board, 14, -0.025, 'Calculate Area', true,
	function() {
		setCheckbox(chi_cb_area, true);
		setCheckbox(chi_cb_xvalue, false);
		
		chi_cb[BETWEEN].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		chi_cb[LEFT].setAttribute( { disabled: false });
		chi_cb[RIGHT].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		
		chi_prob_input.setAttribute( { visible: false });
		chi_prob_disp.setAttribute( { visible: true });
		
		chi_x2_input.setAttribute( { disabled: false });
		chi_x2_input.setAttribute( { visible: true });
		chi_x2_disp.setAttribute({ visible: false });
		
				
	}, { fontSize: 18, frozen: true });

var chi_cb_xvalue = JSXCheckbox(chi_board, 14, -0.05, 'Calculate x-Value', false,
	function() {
		setCheckbox(chi_cb_xvalue, true);
		setCheckbox(chi_cb_area, false);
		
		chi_cb[BETWEEN].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		chi_cb[LEFT].setAttribute( { disabled: false });
		chi_cb[RIGHT].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		set_chi_cbtrue(LEFT);
		
		chi_1.setAttribute({ visible: false });
		chi_2.setAttribute({ visible: true });
		
		chi_shadeleft.setAttribute({ visible: true });
		chi_shaderight.setAttribute({ visible: false });
		chi_shadebetween.setAttribute({ visible: false });
		
		chi_x1_input.rendNodeInput.value = '0';
		chi_x1_input.setAttribute({ disabled: true });
	
		chi_x2_input.rendNodeInput.value = chi_2.X().toFixed(2);
		chi_x2_input.setAttribute({ visible: false });
		chi_x2_disp.setAttribute({ visible: true });
		
		chi_prob_input.setAttribute({ visible: true });
		chi_prob_disp.setAttribute({ visible: false });
		
		chi_2.moveTo([chi_x2_input.rendNodeInput.value, 0]);
		
	}, { fontSize: 18, frozen: true });

var chi_cb = [];

chi_cb[BETWEEN] = JSXCheckbox(chi_board, 2, -0.025, 'P(a < x < b)', true, 
	function() {
		set_chi_cbtrue(BETWEEN);

		chi_shadeleft.setAttribute({ visible: false });
		chi_shaderight.setAttribute({ visible: false });
		chi_shadebetween.setAttribute({ visible: true });
			
		chi_1.setAttribute({ visible: true });
		chi_2.setAttribute({ visible: true });
		
		chi_x1_input.rendNodeInput.value = chi_1.X().toFixed(2);
		chi_x1_input.setAttribute({ disabled: false });
		
		chi_x2_input.rendNodeInput.value = chi_2.X().toFixed(2);
		chi_x2_input.setAttribute({ visible: true });
		chi_x2_input.setAttribute({ disabled: false });
		chi_x2_disp.setAttribute({ visible: false });
		
		chi_prob_input.setAttribute({ visible: false });
		chi_prob_disp.setAttribute({ visible: true });
			
	}, { fontSize: 18, frozen: true });

chi_cb[LEFT] = JSXCheckbox(chi_board, 2, -0.05, 'P(x < b)', false,
	function() {
		set_chi_cbtrue(LEFT);
		
		chi_1.setAttribute({ visible: false });
		chi_2.setAttribute({ visible: true });
		
		chi_shadeleft.setAttribute({ visible: true });
		chi_shaderight.setAttribute({ visible: false });
		chi_shadebetween.setAttribute({ visible: false });
		
		chi_x1_input.rendNodeInput.value = '0';
		chi_x1_input.setAttribute({ disabled: true });
	
		chi_x2_input.rendNodeInput.value = chi_2.X().toFixed(2);
		chi_x2_input.setAttribute({ visible: true });
		chi_x2_input.setAttribute({ disabled: false });
		chi_x2_disp.setAttribute({ visible: false });
		
		chi_prob_input.setAttribute({ visible: false });
		chi_prob_disp.setAttribute({ visible: true });
		
	}, { fontSize: 18, frozen: true });

chi_cb[RIGHT] = JSXCheckbox(chi_board, 2, -0.075, 'P(x > a)', false,
	function() {
		set_chi_cbtrue(RIGHT);
		
		chi_1.setAttribute({ visible: true });
		chi_2.setAttribute({ visible: false });
		
		chi_shadeleft.setAttribute({ visible: false });
		chi_shaderight.setAttribute({ visible: true });
		chi_shadebetween.setAttribute({ visible: false });
		
		chi_x1_input.rendNodeInput.value = chi_1.X().toFixed(2);
		chi_x1_input.setAttribute({ disabled: false });
		
		chi_x2_input.rendNodeInput.value = 'Infinity';
		chi_x2_input.setAttribute({ visible: true });
		chi_x2_input.setAttribute({ disabled: true });
		chi_x2_disp.setAttribute({ visible: false });
		
		chi_prob_input.setAttribute({ visible: false });
		chi_prob_disp.setAttribute({ visible: true });
	
	}, { fontSize: 18, frozen: true });

function current_chi_probability(x1, x2, df) { 
	
	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	if(typeof(df) !== 'number') {
		df = Number(df);
	}
	
	if(chi_cb[BETWEEN].Value()) { 
		
		var v1 = jStat.chisquare.cdf(x1, df);
		var v2 = jStat.chisquare.cdf(x2, df);
		
		return (v2 - v1).toFixed(4);
		
	} else if(chi_cb[LEFT].Value()) {
		
		return jStat.chisquare.cdf(x2, df).toFixed(4);
		
	} else if(chi_cb[RIGHT].Value()) {
		
		return (1 - jStat.chisquare.cdf(x1, df)).toFixed(4);
		
	} 

}

function chi_set_tick_metrics(chi_df) {
	
	if (chi_df == 1) {
		chi_tick_delta = 0.25;
	} else if (chi_df == 2) {
		chi_tick_delta = 0.5;
	} else if (chi_df >= 3 && chi_df <= 5) {
		chi_tick_delta = 1;
	} else if (chi_df >= 6 && chi_df <= 10) {
		chi_tick_delta = 2;
	} else if (chi_df >= 11 && chi_df <= 20) {
		chi_tick_delta = 5;
	} else if (chi_df >= 21 && chi_df <= 50) {
		chi_tick_delta = 10;
	} else if (chi_df >= 51 && chi_df <= 100) {
		chi_tick_delta = 20;
	} else if (chi_df <= 1000) {
		chi_tick_delta = 50;
	} else chi_tick_delta = -1;
	
	
	x_min = 0;
	x_max = 4 * chi_df;
	if (chi_tick_delta != -1) {
		chi_n_ticks = (x_max - x_min) / chi_tick_delta;
	} else {
		chi_n_ticks = -1;
	}
	
}

function set_chi_cbtrue(box) {
	chi_cb[BETWEEN].rendNodeCheckbox.checked = false;
	chi_cb[LEFT].rendNodeCheckbox.checked = false;
	chi_cb[RIGHT].rendNodeCheckbox.checked = false;
	chi_cb[BETWEEN]._value = false;
	chi_cb[LEFT]._value = false;
	chi_cb[RIGHT]._value = false;
	chi_cb[box].rendNodeCheckbox.checked = true;
	chi_cb[box]._value = true;
}
	
</script>

<!--////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////// F-Distribution //////
    ////////////////////////////////////////////////////////////////////////-->

<script type='text/javascript'>

// Initial Values
var f_df1 = 12;
var f_df2 = 10;		
var f_mean = jStat.centralF.mean(f_df1, f_df2);
var f_stdev = Math.sqrt(jStat.centralF.variance(f_df1, f_df2));
var f_ymax = jStat.centralF.pdf(jStat.centralF.mode(f_df1, f_df2), f_df1, f_df2) * 1.3;
var f_xmax = 4;
var f_init_x1 = 0.5;
var f_init_x2 = 2;
var f_tick_delta = 0.5;
var f_n_ticks = f_xmax / f_tick_delta;
var f_tick_ratio = 50; // ticks are 1/50 the value of y-max
var f_prob_type = BETWEEN;
	
var f_board = JXG.JSXGraph.initBoard('f-distribution', {
		boundingbox: [0,f_ymax,f_xmax,-f_ymax],
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });


			
var f_curve = f_board.create('functiongraph', [function(x) { return jStat.centralF.pdf(x, f_df1, f_df2); }], 
	{ strokeWidth: 3, fixed: true, 	highlight: false });
	
var f_axis = f_board.create('line', [[0, 0], [1, 0]], { strokeColor: 'black', strokeWidth: 1, highlight: false, fixed: true, frozen: true });
	
var f_1 = f_board.create('glider', [f_init_x1, 0, f_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
f_1.on('drag', 
	function() { 
		if(f_1.X() < 0) {
			f_1.moveTo([0, 0]);
		}
		f_x1_input.rendNodeInput.value = f_1.X().toFixed(2);
		f_df1 = Number(f_df1_input.rendNodeInput.value);
		f_df2 = Number(f_df2_input.rendNodeInput.value);
		f_prob_input.rendNodeInput.value = current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2);
		f_prob_disp.setText(') = ' + current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2));
	}
);

var f_2 = f_board.create('glider', [f_init_x2, 0, f_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
f_2.on('drag', 
	function() { 
		if(f_2.X() < 0) {
			f_2.moveTo([0, 0]);
		}
		f_x2_input.rendNodeInput.value = f_2.X().toFixed(2);
		f_x2_disp.setText('< <i>X</i> < ' + f_2.X().toFixed(2));
		f_df1 = Number(f_df1_input.rendNodeInput.value);
		f_df2 = Number(f_df2_input.rendNodeInput.value);
		f_prob_input.rendNodeInput.value = current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2);
		f_prob_disp.setText(') = ' + current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2));
	}
);

// Set up the tick marks on the x-axis		
var f_ticks = [];
var f_labels = [];

var tick_height = f_ymax / f_tick_ratio;
for (var i = 0; i < f_n_ticks; i++) {
	f_ticks[i] = f_board.create('segment', 
			[[i * f_tick_delta, tick_height], [i * f_tick_delta, -tick_height]], 
			{ color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
}

for (var i = 1; i < f_n_ticks; i++) {
	f_labels[i-1] = f_board.create('text', 
			[i * f_tick_delta, -2 * tick_height, i * f_tick_delta ], 
			{ fixed: true, highlight: false });
		
}

// input variables

var f_df1_input = f_board.create('input', [2.5, 0.9, f_df1, 'df 1 = '], 
		{ fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });
		
var f_df2_input = f_board.create('input', [2.5, 0.75, f_df2, 'df 2 = '], 
		{ fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });

// display for the mean and standard deviation

var f_mean_disp = f_board.create('text', [2.65, 0.6, 
		function() { return '&mu; = ' + f_mean.toFixed(4); }], 
		{ fontSize: 18, frozen: true, highlight: false, fixed: true });
		
var f_stdev_disp = f_board.create('text', [2.65, 0.45, 
		function() { return '&sigma; = ' + f_stdev.toFixed(4); }], 
		{ fontSize: 18, frozen: true, highlight: false, fixed: true });
		
var f_shadeleft = f_board.create('integral', 
		[[ function() { return 0; } , function() { return f_2.X(); }], f_curve], shadeParam);
f_shadeleft.setAttribute({ visible: false });

var f_shaderight = f_board.create('integral', 
		[[ function() { return f_1.X(); }, function() { return 100; }], f_curve], shadeParam);
f_shaderight.setAttribute({ visible: false });

var f_shadebetween = f_board.create('integral', 
		[[ function() { return f_1.X(); }, function() { return f_2.X(); }], f_curve], shadeParam);
		
var f_x1_input = f_board.create('input', [0.2, -0.6, f_1.X(), 'P( '], { fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });

var f_x2_input = f_board.create('input', [1.25, -0.6, f_2.X(), ' < <i>X</i> < '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
		
var f_x2_disp = f_board.create('text', [1.25, -0.6, '< <i>X</i> < 2'],
		{ fontSize: 18, frozen: true, visible: false, fixed: true });		
		
var f_prob_input = f_board.create('input', [2.5, -0.6, current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2), ') = '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
f_prob_input.setAttribute({ visible: false });

var f_prob_disp = f_board.create('text', [2.5, -0.6, ') = ' + current_f_probability(f_1.X(), f_2.X(), f_df1, f_df2)],
		{ fontSize: 18, frozen: true, fixed: true });		

// Buttons

var f_calc_button = f_board.create('button', [2.75, -0.8, 'Calculate',
	function () {
	
		if(isChecked(f_cb_area)) {
			if(!isNaN(f_x1_input.Value())) {
				f_1.moveTo([f_x1_input.Value(), 0]);
			}
	
			if(!isNaN(f_x2_input.Value())) {
				f_2.moveTo([f_x2_input.Value(), 0]);
			}
			f_df1 = Number(f_df1_input.rendNodeInput.value);
			f_df2 = Number(f_df2_input.rendNodeInput.value);
			f_prob_input.rendNodeInput.value = current_f_probability(f_x1_input.Value(), f_x2_input.Value(), f_df1, f_df2);
			f_prob_disp.setText(') = ' + current_f_probability(f_x1_input.Value(), f_x2_input.Value(), f_df1, f_df2));
		
		} else {
			if(!isNaN(f_prob_input.Value())) {
			
				f_df1 = Number(f_df1_input.rendNodeInput.value);
				f_df2 = Number(f_df2_input.rendNodeInput.value);
				var f = jStat.centralF.inv(f_prob_input.Value(), f_df1, f_df2);
				f_2.moveTo([f, 0]);
				f_x2_input.rendNodeInput.value = f;
				f_x2_disp.setText('< <i>X</i> < ' + f.toFixed(8));
		
			}
		}
}], { frozen: true });		
		
var f_update = f_board.create('button', [2.75, 0.3, 'Update', function() {
		
		var new_df1 = f_df1_input.rendNodeInput.value;
		var new_df2 = f_df2_input.rendNodeInput.value;
		
		if ((new_df1 >= 1) && (new_df2 >= 1)) {
			
			f_df1 = Number(new_df1);
			f_df2 = Number(new_df2);	
			
			if ((f_df1 >= 1) && (f_df1 < 2)) {
				f_ymax = 2.5;
			} else if ((f_df1 >= 2) && (f_df1 < 3)) {
				f_ymax = 1.5;
			} else {
				f_ymax = jStat.centralF.pdf(jStat.centralF.mode(f_df1, f_df2), f_df1, f_df2) * 1.3;
			}

			f_board.setBoundingBox([0, f_ymax, f_xmax, -f_ymax]);
			var tick_height = f_ymax / f_tick_ratio;
	
			// Update the display for just the labels and ticks we want
			for (var i = 0; i < f_n_ticks; i++) {
				f_ticks[i].point1.moveTo([i * f_tick_delta, tick_height]);
				f_ticks[i].point2.moveTo([i * f_tick_delta, -tick_height]);
			}
			
			for (var i = 1; i < f_n_ticks; i++) {
				f_labels[i-1].setText(i * f_tick_delta);
				f_labels[i-1].moveTo([i * f_tick_delta, -2 * tick_height]);				
			}
			
			if (f_df2 <= 2) {
				f_mean = NaN;
			} else {
				f_mean = jStat.centralF.mean(f_df1, f_df2);
				f_stdev = Math.sqrt(jStat.centralF.variance(f_df1, f_df2));
			}

			
			var cur_x1 = f_x1_input.rendNodeInput.value;
			var cur_x2 = f_x2_input.rendNodeInput.value;
			
			f_1.moveTo([cur_x1, 0]);
			f_2.moveTo([cur_x2, 0]);
			
			f_x1_input.rendNodeInput.value = cur_x1;
			f_x2_input.rendNodeInput.value = cur_x2;
			f_x2_disp.setText('< <i>X</i> < ' + Number(cur_x2).toFixed(8));
			
			f_prob_input.rendNodeInput.value = current_f_probability(cur_x1, cur_x2, f_df1, f_df2);
			f_prob_disp.setText(') = ' + current_f_probability(cur_x1, cur_x2, f_df1, f_df2));

		}
		
		//f_df_input.rendNodeInput.value = f_df;	
		
}], { frozen: true });		
		
// Checkboxes

var f_cb_area = JSXCheckbox(f_board, 2.25, -0.2, 'Calculate Area', true,
	function() {
		setCheckbox(f_cb_area, true);
		setCheckbox(f_cb_xvalue, false);
		
		f_cb[BETWEEN].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		f_cb[LEFT].setAttribute( { disabled: false });
		f_cb[RIGHT].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		
		f_prob_input.setAttribute( { visible: false });
		f_prob_disp.setAttribute( { visible: true });
		
		f_x2_input.setAttribute( { disabled: false });
		f_x2_input.setAttribute( { visible: true });
		f_x2_disp.setAttribute({ visible: false });
		
		f_prob_type = LEFT;
				
	}, { fontSize: 18, frozen: true });

var f_cb_xvalue = JSXCheckbox(f_board, 2.25, -0.325, 'Calculate x-Value', false,
	function() {
		setCheckbox(f_cb_xvalue, true);
		setCheckbox(f_cb_area, false);
		
		f_cb[BETWEEN].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		f_cb[LEFT].setAttribute( { disabled: false });
		f_cb[RIGHT].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		set_f_cbtrue(LEFT);
		f_prob_type = LEFT;
		
		f_1.setAttribute({ visible: false });
		f_2.setAttribute({ visible: true });
		
		f_shadeleft.setAttribute({ visible: true });
		f_shaderight.setAttribute({ visible: false });
		f_shadebetween.setAttribute({ visible: false });
		
		f_x1_input.rendNodeInput.value = '0';
		f_x1_input.setAttribute({ disabled: true });
	
		f_x2_input.rendNodeInput.value = f_2.X().toFixed(2);
		f_x2_input.setAttribute({ visible: false });
		f_x2_disp.setAttribute({ visible: true });
		
		f_prob_input.setAttribute({ visible: true });
		f_prob_disp.setAttribute({ visible: false });
		
		f_2.moveTo([f_x2_input.rendNodeInput.value, 0]);
		
	}, { fontSize: 18, frozen: true });

var f_cb = [];

f_cb[BETWEEN] = JSXCheckbox(f_board, 0.2, -0.2, 'P(a < x < b)', true, 
	function() {
		set_f_cbtrue(BETWEEN);
		f_prob_type = BETWEEN;
		
		f_shadeleft.setAttribute({ visible: false });
		f_shaderight.setAttribute({ visible: false });
		f_shadebetween.setAttribute({ visible: true });
			
		f_1.setAttribute({ visible: true });
		f_2.setAttribute({ visible: true });
		
		f_x1_input.rendNodeInput.value = f_1.X().toFixed(2);
		f_x1_input.setAttribute({ disabled: false });
		
		f_x2_input.rendNodeInput.value = f_2.X().toFixed(2);
		f_x2_input.setAttribute({ visible: true });
		f_x2_input.setAttribute({ disabled: false });
		f_x2_disp.setAttribute({ visible: false });
		
		f_prob_input.setAttribute({ visible: false });
		f_prob_disp.setAttribute({ visible: true });
			
	}, { fontSize: 18, frozen: true });

f_cb[LEFT] = JSXCheckbox(f_board, 0.2, -0.325, 'P(x < b)', false,
	function() {
		set_f_cbtrue(LEFT);
		f_prob_type = LEFT;
		
		f_1.setAttribute({ visible: false });
		f_2.setAttribute({ visible: true });
		
		f_shadeleft.setAttribute({ visible: true });
		f_shaderight.setAttribute({ visible: false });
		f_shadebetween.setAttribute({ visible: false });
		
		f_x1_input.rendNodeInput.value = '0';
		f_x1_input.setAttribute({ disabled: true });
	
		f_x2_input.rendNodeInput.value = f_2.X().toFixed(2);
		f_x2_input.setAttribute({ visible: true });
		f_x2_input.setAttribute({ disabled: false });
		f_x2_disp.setAttribute({ visible: false });
		
		f_prob_input.setAttribute({ visible: false });
		f_prob_disp.setAttribute({ visible: true });
		
	}, { fontSize: 18, frozen: true });

f_cb[RIGHT] = JSXCheckbox(f_board, 0.2, -0.45, 'P(x > a)', false,
	function() {
		set_f_cbtrue(RIGHT);
		f_prob_type = RIGHT;
		
		f_1.setAttribute({ visible: true });
		f_2.setAttribute({ visible: false });
		
		f_shadeleft.setAttribute({ visible: false });
		f_shaderight.setAttribute({ visible: true });
		f_shadebetween.setAttribute({ visible: false });
		
		f_x1_input.rendNodeInput.value = f_1.X().toFixed(2);
		f_x1_input.setAttribute({ disabled: false });
		
		f_x2_input.rendNodeInput.value = 'Infinity';
		f_x2_input.setAttribute({ visible: true });
		f_x2_input.setAttribute({ disabled: true });
		f_x2_disp.setAttribute({ visible: false });
		
		f_prob_input.setAttribute({ visible: false });
		f_prob_disp.setAttribute({ visible: true });
	
	}, { fontSize: 18, frozen: true });

function current_f_probability(x1, x2, df1, df2) { 
	
	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	if(typeof(df1) !== 'number') {
		df1 = Number(df1);
	}
	if(typeof(df2) !== 'number') {
		df2 = Number(df2);
	}
	
	if(f_prob_type == BETWEEN) { 
		
		var v1 = jStat.centralF.cdf(x1, df1, df2);
		var v2 = jStat.centralF.cdf(x2, df1, df2);
		
		return (v2 - v1).toFixed(4);
		
	} else if(f_prob_type == LEFT) {
		
		return jStat.centralF.cdf(x2, df1, df2).toFixed(4);
		
	} else if(f_prob_type == RIGHT) {
		
		return (1 - jStat.centralF.cdf(x1, df1, df2)).toFixed(4);
		
	} 

}

function set_f_cbtrue(box) {
	f_cb[BETWEEN].rendNodeCheckbox.checked = false;
	f_cb[LEFT].rendNodeCheckbox.checked = false;
	f_cb[RIGHT].rendNodeCheckbox.checked = false;
	f_cb[BETWEEN]._value = false;
	f_cb[LEFT]._value = false;
	f_cb[RIGHT]._value = false;
	f_cb[box].rendNodeCheckbox.checked = true;
	f_cb[box]._value = true;
}
</script>

</body>
</html>