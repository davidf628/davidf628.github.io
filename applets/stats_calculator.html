<!DOCTYPE html>
<html lang = "en-US">

<head>

	<title>Statistics Calculator</title>
	<meta charset="utf-8">  
	
	<link rel='stylesheet' type='text/css' href='./js/jsxgraph.css' />
	<script src='./js/jsxgraphcore.js' type='text/javascript'></script>
	<script src='./js/MathFunctions.js' type='text/javascript'></script>
	<script src='./js/helpers.js' type='text/javascript'></script>
	
	<style>
		body {
			font-family: Arial;
		}
		
		/* Style the tab */
		.tab {
			overflow: hidden;
			border: 1px solid #ccc;
			background-color: #f1f1f1;
		}
		
		/* Style the buttons that are used to open the tab content */
		.tab button {
			background-color: inherit;
			float: left;
			border: none;
			outline: none;
			cursor: pointer;
			padding: 14px 16px;
			transition: 0.3s;
		}
		
		/* Change background color of buttons on hover */
		.tab button:hover {
			background-color: #ddd;
		}
		
		/* Create an active/current tablink class */
		.tab button.active {
			background-color: #ccc;
		}
		
		/* Style the tab content */
		.tabcontent {
			display: none;
			padding: 6px 12px;
			border: 1px solid #ccc;
			border-top: none;
		}
		
	</style>
	
</head>

<body>

<h1>Statistics Calculator</h1>


<!-- Tab links -->
<div class="tab">
	<button class="tablinks" id="defaultOpen" onclick="openTool(event, 'standard_normal')">Normal</button>
	<button class="tablinks" onclick="openTool(event, 't-distribution')">T-Dist</button>
</div>

<!-- Tab content -->
<div id="standard_normal" class="jxgbox" style="width:540px; height:540px;"></div>
<div id="t-distribution" class="jxgbox" style="width:540px; height:540px;"></div>

<script>
function openTool(evt, tool) {
	// Declare all variables
	var i, tabcontent, tablinks;

	// Get all elements with class="tabcontent" and hide them
	tabcontent = document.getElementsByClassName("jxgbox");
	for (i = 0; i < tabcontent.length; i++) {
		tabcontent[i].style.display = "none";
	}

	// Get all elements with class="tablinks" and remove the class "active"
	tablinks = document.getElementsByClassName("tablinks");
	for (i = 0; i < tablinks.length; i++) {
		tablinks[i].className = tablinks[i].className.replace(" active", "");
	}

	// Show the current tab, and add an "active" class to the button that opened the tab
	document.getElementById(tool).style.display = "block";
	evt.currentTarget.className += " active";
}
document.getElementById("defaultOpen").click();
</script>


<script>
	// Define global variables

	var shadeParam = { 
		color: '#0000FF', 
		fillOpacity: 0.4, 
		withLabel: false,
		fixed: true,
		highlight: false,
		curveLeft: { visible: false },
		curveRight: { visible: false },
	};
	
	var PTYPE = 'between';
	
	var BETWEEN = 0;
	var LEFT = 1;
	var RIGHT = 2;
	
</script>


<script>

var board_normal = JXG.JSXGraph.initBoard('standard_normal', {
		boundingbox: [-4,0.5,4,-0.5], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },	
		pan: {
			enabled: false
		}
    });

mean_n = 0;
stdev_n = 1;		
			
	
function zScore(x) {
	return (x - mean_n) / stdev_n;
}
			
function xValue(z) {
	return mean_n + z * stdev_n;
}				
			
normal_curve = board_normal.create('functiongraph', [function(x) { return normalpdf(zScore(x)); }], 
	{ strokeWidth: 3, fixed: true, 	highlight: false });
	
hidden_axis = board_normal.create('line', [[0, 0], [1, 0]], { visible: false });

x_axis = board_normal.create('axis', [[0, 0], [1, 0]], 
	{ ticks: { visible: false } });
	
z1 = board_normal.create('glider', [-2, 0, x_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
z1.on('drag', 
	function() { 
		x1_input.rendNodeInput.value = z1.X().toFixed(2);
		prob_input.rendNodeInput.value = currentProbability(zScore(z1.X()), zScore(z2.X()));
		prob_disp.setText(') = ' + currentProbability(zScore(z1.X()), zScore(z2.X())));
	}
);

z2 = board_normal.create('glider', [2, 0, x_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
z2.on('drag', 
	function() { 
		x2_input.rendNodeInput.value = z2.X().toFixed(2);
		x2_disp.setText('< <i>X</i> < ' + z2.X().toFixed(2));
		prob_input.rendNodeInput.value = currentProbability(zScore(z1.X()), zScore(z2.X()));
		prob_disp.setText(') = ' + currentProbability(zScore(z1.X()), zScore(z2.X())));
	}
);

ticks_n = [];
labels_n = [];
for (var i = -3; i <= 3; i++) {
	ticks_n[i + 3] = board_normal.create('segment', [[i,.01], [i,-0.01]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
	labels_n[i + 3] = board_normal.create('text', [i-.05, -0.02, i], { fixed: true, highlight: false });
}

// input variables

mean = board_normal.create('input', [1.3, 0.38, '0', '&mu; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });
stdev = board_normal.create('input', [1.3, 0.3, '1', '&sigma; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });

x1_input = board_normal.create('input', [-3.5, -0.32, '-2', 'P( '], { fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
x2_input = board_normal.create('input', 
		[-1.3, -0.32, '2', ' < <i>X</i> < '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
x2_disp = board_normal.create('text', [-1.3, -0.32, '< <i>X</i> < 2'],
		{ fontSize: 18, frozen: true, visible: false });		
		
prob_input = board_normal.create('input', [1.3, -0.32, '0.9500', ') = '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
prob_input.setAttribute( { visible: false } );

prob_disp = board_normal.create('text', [1.3, -0.32, ') = 0.9500'],
		{ fontSize: 18, frozen: true, fixed: true });


calc_normal = board_normal.create('button', [1.5, -0.42, 'Calculate',
	function () {
	
		if(isChecked(cb_area)) {
			if(!isNaN(x1_input.Value())) {
				z1.moveTo([x1_input.Value(), 0]);
			}
	
			if(!isNaN(x2_input.Value())) {
				z2.moveTo([x2_input.Value(), 0]);
			}
	
			prob_input.rendNodeInput.value = currentProbability(zScore(x1_input.Value()), zScore(x2_input.Value()));
			prob_disp.setText(') = ' + currentProbability(zScore(x1_input.Value()), zScore(x2_input.Value())));
		
		} else {
			if(!isNaN(prob_input.Value())) {
			
				var z = xValue(invnorm(prob_input.Value()));
				z2.moveTo([z, 0]);
				x2_input.rendNodeInput.value = z;
				x2_disp.setText('< <i>X</i> < ' + z.toFixed(8));
		
			}
		}
}], { frozen: true });


function updateAxisLabels() {
	
	for(var i = -3; i <= 3; i++) {
		ticks_n[i + 3].point1.moveTo([xValue(i), 0.01]);
		ticks_n[i + 3].point2.moveTo([xValue(i), -0.01]);
		labels_n[i + 3].setText(xValue(i));
		labels_n[i + 3].setCoords([xValue(i), -0.02]);
	}
	
}

update_normal = board_normal.create('button', [2.5, 0.22, 'Update', 
	
	// If a new mean and standard deviation are provided, then we need to:
	//   - change the bounds on the x-axis
	//   - set the global mean_n and stdev_n variables
	//   - reset the positions of z1 and z2 on the x-axis so that they are accessible again
	
	function() {
		var cur_z1 = zScore(z1.X());
		var cur_z2 = zScore(z2.X());
		mean_n = Number(mean.Value());
		stdev_n = Number(eval(stdev.Value()));
		var x_min = xValue(-4);
		var x_max = xValue(4);
		//JSXSetBounds(board_normal, { xmin: x_min, xmax: x_max }, false);
		board_normal.setBoundingBox([x_min, 0.5, x_max, -0.5]);
		z1.moveTo([xValue(cur_z1), 0]);
		z2.moveTo([xValue(cur_z2), 0]);
		x1_input.rendNodeInput.value = xValue(cur_z1);
		x2_input.rendNodeInput.value = xValue(cur_z2);
		x2_disp.setText('< <i>X</i> < ' + xValue(cur_z2).toFixed(8));
		prob_input.rendNodeInput.value = currentProbability(cur_z1, cur_z2);
		updateAxisLabels();
		
	}
	
], { frozen: true });


shadedregionleft = board_normal.create('integral', 
	[[ function() { return xValue(-10000); }, function() { return z2.X(); }], normal_curve], shadeParam);
shadedregionleft.setAttribute({ visible: false });

shadedregionright = board_normal.create('integral', 
	[[ function() { return z1.X(); }, function() { return xValue(10000); }], normal_curve], shadeParam);
shadedregionright.setAttribute({ visible: false });

shadedregionbetween = board_normal.create('integral', 
	[[ function() { return z1.X(); }, function() { return z2.X(); }], normal_curve], shadeParam);


cb_area = JSXCheckbox(board_normal, 1, -0.1, 'Calculate Area', true,
	function() {
		setCheckbox(cb_area, true);
		setCheckbox(cb_xvalue, false);
		
		cb_between.setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		cb_left.setAttribute( { disabled: false });
		cb_right.setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		
		prob_input.setAttribute( { visible: false });
		prob_disp.setAttribute( { visible: true });
		x2_input.setAttribute( { visible: true });
		x2_disp.setAttribute({ visible: false });
		
				
	}, { fontSize: 18, frozen: true });

cb_xvalue = JSXCheckbox(board_normal, 1, -0.16, 'Calculate x-Value', false,
	function() {
		setCheckbox(cb_xvalue, true);
		setCheckbox(cb_area, false);
		
		cb_between.setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		cb_left.setAttribute( { disabled: false });
		cb_right.setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		setCheckbox(cb_left, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_right, false);
		
		z1.setAttribute({ visible: false });
		z2.setAttribute({ visible: true });
		
		shadedregionleft.setAttribute({ visible: true });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1_input.rendNodeInput.value = '-Infinity';
		x1_input.setAttribute({ disabled: true });
	
		x2_input.rendNodeInput.value = z2.X().toFixed(2);
		x2_input.setAttribute({ visible: false });
		x2_disp.setAttribute({ visible: true });

		
		prob_input.setAttribute({ visible: true });
		prob_disp.setAttribute({ visible: false });
		
		PTYPE = 'left';
		
		
	}, { fontSize: 18, frozen: true });

cb_between = JSXCheckbox(board_normal, -3.6, -0.1, 'P(a < x < b)', true, 
	function() {
		setCheckbox(cb_between, true);
		setCheckbox(cb_left, false);
		setCheckbox(cb_right, false);

		shadedregionleft.setAttribute({ visible: false });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: true });
			
		z1.setAttribute({ visible: true });
		z2.setAttribute({ visible: true });
		
		x1_input.rendNodeInput.value = z1.X().toFixed(2);
		x1_input.setAttribute({ disabled: false });
		
		x2_input.rendNodeInput.value = z2.X().toFixed(2);
		x2_input.setAttribute({ visible: true });
		x2_disp.setAttribute({ visible: false });
		
		prob_input.setAttribute({ visible: false });
		prob_disp.setAttribute({ visible: true });
		
		PTYPE = 'between';
			
	}, { fontSize: 18, frozen: true });

cb_left = JSXCheckbox(board_normal, -3.6, -0.16, 'P(x < b)', false,
	function() {
		setCheckbox(cb_left, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_right, false);
		
		z1.setAttribute({ visible: false });
		z2.setAttribute({ visible: true });
		
		shadedregionleft.setAttribute({ visible: true });
		shadedregionright.setAttribute({ visible: false });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1_input.rendNodeInput.value = '-Infinity';
		x1_input.setAttribute({ disabled: true });
	
		x2_input.rendNodeInput.value = z2.X().toFixed(2);
		x2_input.setAttribute({ visible: true });
		x2_disp.setAttribute({ visible: false });

		
		prob_input.setAttribute({ visible: false });
		prob_disp.setAttribute({ visible: true });
		
		PTYPE = 'left';
		
	}, { fontSize: 18, frozen: true });

cb_right = JSXCheckbox(board_normal, -3.6, -0.22, 'P(x > a)', false,
	function() {
		setCheckbox(cb_right, true);
		setCheckbox(cb_between, false);
		setCheckbox(cb_left, false);
		
		z1.setAttribute({ visible: true });
		z2.setAttribute({ visible: false });
		
		shadedregionleft.setAttribute({ visible: false });
		shadedregionright.setAttribute({ visible: true });
		shadedregionbetween.setAttribute({ visible: false });
		
		x1_input.rendNodeInput.value = z1.X().toFixed(2);
		x1_input.setAttribute({ disabled: false });
		
		x2_input.rendNodeInput.value = 'Infinity';
		x2_input.setAttribute({ visible: true });
		x2_input.setAttribute({ disabled: true });
		x2_disp.setAttribute({ visible: false });
		
		prob_input.setAttribute({ visible: false });
		prob_disp.setAttribute({ visible: true });
		
		PTYPE = 'right';
	
	}, { fontSize: 18, frozen: true });


function currentProbability(x1, x2) { 
	
	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	
	if(cb_between.Value()) { 
		return Math.abs(normalcdf(x2) - normalcdf(x1)).toFixed(4);
	} else if(cb_left.Value()) {
		return normalcdf(x2).toFixed(4);
	} else if(cb_right.Value()) {
		return (1 - normalcdf(x1)).toFixed(4);
	} 

}


</script>


<script type='text/javascript'>
		
var t_board = JXG.JSXGraph.initBoard('t-distribution', {
		boundingbox: [-4,0.5,4,-0.5],
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1,
			enabled: false
        },
		pan: {
			enabled: false
		}
    });
		
var t_mean = 0;
var t_stdev = 1;
var t_df = 10;	
			
	
function tScore(x) {
	return (x - t_mean) / t_stdev;
}
			
function t_xval(t) {
	return t_mean + t * t_stdev;
}		
			
var t_curve = t_board.create('functiongraph', [function(x) { return tpdf(tScore(x), t_df); }], 
	{ strokeWidth: 3, fixed: true, 	highlight: false });
	
var t_axis = t_board.create('line', [[0, 0], [1, 0]], { strokeColor: 'black', strokeWidth: 1, highlight: false, fixed: true, frozen: true });
	
var t1 = t_board.create('glider', [-2, 0, t_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
t1.on('drag', 
	function() { 
		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_df = Number(t_df_input.rendNodeInput.value);
		t_prob_input.rendNodeInput.value = currentTProbability(tScore(t1.X()), tScore(t2.X()), t_df);
		t_prob_disp.setText(') = ' + currentTProbability(tScore(t1.X()), tScore(t2.X()), t_df));
	}
);

var t2 = t_board.create('glider', [2, 0, t_axis], { withLabel: false, color: 'black', snapToGrid: true, snapSizeX: 0.01 });
t2.on('drag', 
	function() { 
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_x2_disp.setText('< <i>X</i> < ' + t2.X().toFixed(2));
		t_df = Number(t_df_input.rendNodeInput.value);
		t_prob_input.rendNodeInput.value = currentTProbability(tScore(t1.X()), tScore(t2.X()), t_df);
		t_prob_disp.setText(') = ' + currentTProbability(tScore(t1.X()), tScore(t2.X()), t_df));
	}
);
		
var t_ticks = [];
var t_labels = [];
for (var i = -3; i <= 3; i++) {
	t_ticks[i + 3] = t_board.create('segment', [[i,.01], [i,-0.01]], { color: 'grey', strokeWidth: 1, fixed: true, highlight: false });
	t_labels[i + 3] = t_board.create('text', [i-.05, -0.02, i], { fixed: true, highlight: false });
}

// input variables

var t_df_input = t_board.create('input', [1.3, 0.45, t_df, 'df = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });	
var t_mean_input = t_board.create('input', [1.3, 0.38, '0', '&mu; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });
var t_stdev_input = t_board.create('input', [1.3, 0.3, '1', '&sigma; = '], { fontSize: 18, cssStyle: 'width: 100px', frozen: true, fixed: true });
		
var t_shadeleft = t_board.create('integral', 
	[[ function() { return t_xval(-10000); }, function() { return t2.X(); }], t_curve], shadeParam);
t_shadeleft.setAttribute({ visible: false });

var t_shaderight = t_board.create('integral', 
	[[ function() { return t1.X(); }, function() { return t_xval(10000); }], t_curve], shadeParam);
t_shaderight.setAttribute({ visible: false });

var t_shadebetween = t_board.create('integral', 
	[[ function() { return t1.X(); }, function() { return t2.X(); }], t_curve], shadeParam);
		
var t_x1_input = t_board.create('input', [-3.5, -0.32, '-2', 'P( '], { fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });

var t_x2_input = t_board.create('input', [-1.3, -0.32, '2', ' < <i>X</i> < '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
		
var t_x2_disp = t_board.create('text', [-1.3, -0.32, '< <i>X</i> < 2'],
		{ fontSize: 18, frozen: true, visible: false, fixed: true });		
		
var t_prob_input = t_board.create('input', [1.3, -0.32, '0.9500', ') = '], 
		{ fontSize: 18, cssStyle: 'width: 100px ', frozen: true, fixed: true });
t_prob_input.setAttribute({ visible: false });

var t_prob_disp = t_board.create('text', [1.3, -0.32, ') = 0.9500'],
		{ fontSize: 18, frozen: true, fixed: true });		
		
t_board.update();
		
// Buttons

var t_calc_button = t_board.create('button', [1.5, -0.42, 'Calculate',
	function () {
	
		if(isChecked(t_cb_area)) {
			if(!isNaN(t_x1_input.Value())) {
				t1.moveTo([t_x1_input.Value(), 0]);
			}
	
			if(!isNaN(t_x2_input.Value())) {
				t2.moveTo([t_x2_input.Value(), 0]);
			}
			t_df = Number(t_df_input.rendNodeInput.value);
			t_prob_input.rendNodeInput.value = currentTProbability(tScore(t_x1_input.Value()), tScore(t_x2_input.Value()), t_df);
			t_prob_disp.setText(') = ' + currentTProbability(tScore(t_x1_input.Value()), tScore(t_x2_input.Value()), t_df));
		
		} else {
			if(!isNaN(t_prob_input.Value())) {
			
				t_df = Number(t_df_input.rendNodeInput.value);
				var t = t_xval(tinv(t_prob_input.Value(), t_df));
				t2.moveTo([t, 0]);
				t_x2_input.rendNodeInput.value = t;
				t_x2_disp.setText('< <i>X</i> < ' + t.toFixed(8));
		
			}
		}
}], { frozen: true });		
		
var t_update = t_board.create('button', [2.5, 0.22, 'Update', 
		
	function() {
		var cur_z1 = tScore(t1.X());
		var cur_z2 = tScore(t2.X());
		t_mean = Number(t_mean_input.Value());
		t_stdev = Number(eval(t_stdev_input.Value()));
		var x_min = t_xval(-4);
		var x_max = t_xval(4);
		t_board.setBoundingBox([x_min, 0.5, x_max, -0.5]);
		t1.moveTo([t_xval(cur_z1), 0]);
		t2.moveTo([t_xval(cur_z2), 0]);
		t_x1_input.rendNodeInput.value = t_xval(cur_z1);
		t_x2_input.rendNodeInput.value = t_xval(cur_z2);
		t_x2_disp.setText('< <i>X</i> < ' + t_xval(cur_z2).toFixed(8));
		t_df = Number(t_df_input.rendNodeInput.value);
		t_prob_input.rendNodeInput.value = currentTProbability(cur_z1, cur_z2, t_df);
		updateTAxisLabels();
		
	}
	
], { frozen: true });		
		
// Checkboxes

var t_cb_area = JSXCheckbox(t_board, 1, -0.1, 'Calculate Area', true,
	function() {
		setCheckbox(t_cb_area, true);
		setCheckbox(t_cb_xvalue, false);
		
		t_cb[BETWEEN].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		t_cb[LEFT].setAttribute( { disabled: false });
		t_cb[RIGHT].setAttribute( { disabled: false, strokeColor: 'black', highlight: true  });
		
		t_prob_input.setAttribute( { visible: false });
		t_prob_disp.setAttribute( { visible: true });
		
		t_x2_input.setAttribute( { disabled: false });
		t_x2_input.setAttribute( { visible: true });
		t_x2_disp.setAttribute({ visible: false });
		
				
	}, { fontSize: 18, frozen: true });

var t_cb_xvalue = JSXCheckbox(t_board, 1, -0.16, 'Calculate x-Value', false,
	function() {
		setCheckbox(t_cb_xvalue, true);
		setCheckbox(t_cb_area, false);
		
		t_cb[BETWEEN].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		t_cb[LEFT].setAttribute( { disabled: false });
		t_cb[RIGHT].setAttribute( { disabled: true, strokeColor: 'lightgray', highlight: false });
		set_t_cbtrue(LEFT);
		
		t1.setAttribute({ visible: false });
		t2.setAttribute({ visible: true });
		
		t_shadeleft.setAttribute({ visible: true });
		t_shaderight.setAttribute({ visible: false });
		t_shadebetween.setAttribute({ visible: false });
		
		t_x1_input.rendNodeInput.value = '-Infinity';
		t_x1_input.setAttribute({ disabled: true });
	
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_x2_input.setAttribute({ visible: false });
		t_x2_disp.setAttribute({ visible: true });
		
		t_prob_input.setAttribute({ visible: true });
		t_prob_disp.setAttribute({ visible: false });
		
		t2.moveTo([t_x2_input.rendNodeInput.value, 0]);
		
	}, { fontSize: 18, frozen: true });

var t_cb = [];

t_cb[BETWEEN] = JSXCheckbox(t_board, -3.6, -0.1, 'P(a < x < b)', true, 
	function() {
		set_t_cbtrue(BETWEEN);

		t_shadeleft.setAttribute({ visible: false });
		t_shaderight.setAttribute({ visible: false });
		t_shadebetween.setAttribute({ visible: true });
			
		t1.setAttribute({ visible: true });
		t2.setAttribute({ visible: true });
		
		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_x1_input.setAttribute({ disabled: false });
		
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_x2_input.setAttribute({ visible: true });
		t_x2_input.setAttribute({ disabled: false });
		t_x2_disp.setAttribute({ visible: false });
		
		t_prob_input.setAttribute({ visible: false });
		t_prob_disp.setAttribute({ visible: true });
			
	}, { fontSize: 18, frozen: true });

t_cb[LEFT] = JSXCheckbox(t_board, -3.6, -0.16, 'P(x < b)', false,
	function() {
		set_t_cbtrue(LEFT);
		
		t1.setAttribute({ visible: false });
		t2.setAttribute({ visible: true });
		
		t_shadeleft.setAttribute({ visible: true });
		t_shaderight.setAttribute({ visible: false });
		t_shadebetween.setAttribute({ visible: false });
		
		t_x1_input.rendNodeInput.value = '-Infinity';
		t_x1_input.setAttribute({ disabled: true });
	
		t_x2_input.rendNodeInput.value = t2.X().toFixed(2);
		t_x2_input.setAttribute({ visible: true });
		t_x2_input.setAttribute({ disabled: false });
		t_x2_disp.setAttribute({ visible: false });
		
		t_prob_input.setAttribute({ visible: false });
		t_prob_disp.setAttribute({ visible: true });
		
	}, { fontSize: 18, frozen: true });

t_cb[RIGHT] = JSXCheckbox(t_board, -3.6, -0.22, 'P(x > a)', false,
	function() {
		set_t_cbtrue(RIGHT);
		
		t1.setAttribute({ visible: true });
		t2.setAttribute({ visible: false });
		
		t_shadeleft.setAttribute({ visible: false });
		t_shaderight.setAttribute({ visible: true });
		t_shadebetween.setAttribute({ visible: false });
		
		t_x1_input.rendNodeInput.value = t1.X().toFixed(2);
		t_x1_input.setAttribute({ disabled: false });
		
		t_x2_input.rendNodeInput.value = 'Infinity';
		t_x2_input.setAttribute({ visible: true });
		t_x2_input.setAttribute({ disabled: true });
		t_x2_disp.setAttribute({ visible: false });
		
		t_prob_input.setAttribute({ visible: false });
		t_prob_disp.setAttribute({ visible: true });
	
	}, { fontSize: 18, frozen: true });

function updateTAxisLabels() {
	
	for(var i = -3; i <= 3; i++) {
		t_ticks[i + 3].point1.moveTo([t_xval(i), 0.01]);
		t_ticks[i + 3].point2.moveTo([t_xval(i), -0.01]);
		t_labels[i + 3].setText(t_xval(i));
		t_labels[i + 3].setCoords([t_xval(i), -0.02]);
	}
	
}

function currentTProbability(x1, x2, df) { 
	
	if(typeof(x1) !== 'number') {
		x1 = Number(x1);
	}
	if(typeof(x2) !== 'number') {
		x2 = Number(x2);
	}
	if(typeof(df) !== 'number') {
		df = Number(df);
	}
	
	if(t_cb[BETWEEN].Value()) { 
		return Math.abs(tcdf(x2, df) - tcdf(x1, df)).toFixed(4);
	} else if(t_cb[LEFT].Value()) {
		return tcdf(x2, df).toFixed(4);
	} else if(t_cb[RIGHT].Value()) {
		return (1 - tcdf(x1, df)).toFixed(4);
	} 

}

function set_t_cbtrue(box) {
	t_cb[BETWEEN].rendNodeCheckbox.checked = false;
	t_cb[LEFT].rendNodeCheckbox.checked = false;
	t_cb[RIGHT].rendNodeCheckbox.checked = false;
	t_cb[BETWEEN]._value = false;
	t_cb[LEFT]._value = false;
	t_cb[RIGHT]._value = false;
	t_cb[box].rendNodeCheckbox.checked = true;
	t_cb[box]._value = true;
}

	
</script>


</body>
</html>