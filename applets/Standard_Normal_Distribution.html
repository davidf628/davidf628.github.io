<!--
	- Get Zoom Square functionality working
	- Set up z1 and z2 so that when hidden, the value of the original varaibles are not lost
	- Get shading of outer probabilities setup
-->

<html>
<head>
	<meta charset="utf-8">  
		<link rel='stylesheet' type='text/css' href='https://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css' />
		<script src='https://jsxgraph.uni-bayreuth.de/distrib/jsxgraphcore.js' type='text/javascript'></script>
		<script src='https://jsxgraph.uni-bayreuth.de/distrib/GeonextReader.js' type='text/javascript'></script>
		<script src='./js/MathFunctions.js' type='text/javascript'></script>
	</meta>
</head>

<body>

<h1>Standard Normal Distribtuion</h1>
<input type="button" value="Change Bounds" onClick="update()">
</br></br>

<div>
	<div id="jxgbox" class="jxgbox" style="width:720px; height:640px; float:left; resize: both"></div>
	<div id="display" class="jxgbox" style="width:320px; height:640px; float:left"></div>
</div>

<script type='text/javascript'>
		
var board = JXG.JSXGraph.initBoard('jxgbox', {
		boundingbox: [-4,0.6,4,-0.2], 
      	showCopyright: false, 
      	showNavigation: true,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: false,
            needshift: false,
            eps: 0.1
        }		
    });
		
var displayboard = JXG.JSXGraph.initBoard('display', {
		boundingbox: [0,10,12,0], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false	
    });		
		
JXG.Options.board.minimizeReflow = 'all';		

BETWEEN = 0;  LEFT = 1;  RIGHT = 2;   TWOTAIL = 3;
		
normal_curve = board.create('functiongraph', [ 
	function(x) { 
		return normalpdf(x); 
	} ], 
	{ 
		strokeWidth: 3, 
		fixed: true, 
		highlight: false 
	});
	
hidden_axis = board.create('line', [[0, 0], [1, 0]], { visible: false });
x_axis = board.create('axis', [[0, 0], [1, 0]], 
	{ ticks: { majorHeight: 10, drawZero: true }});

cb = [];

cb[BETWEEN] = displayboard.create('checkbox', [1, 6, 'Between']);
cb[LEFT] = displayboard.create('checkbox', [1, 5.5, 'Left tailed']);
cb[RIGHT] = displayboard.create('checkbox', [1, 5, 'Right tailed']);
cb[TWOTAIL] = displayboard.create('checkbox', [1, 4.5, 'Two tailed']);

// Set the calculation to find the area between two z-scores by default
cb[BETWEEN].rendNodeCheckbox.checked = true;
cb[BETWEEN]._value = true;

// Just default stuff
probability = board.create('point', [0, 0], { visible: false });
area = board.create('point', [0, 0], { visible: false });
z1_txt = board.create('point', [0, 0], { visible: false });
z2_txt = board.create('point', [0, 0], { visible: false });

function setupstuff() {

	board.removeObject(probability);
	displayboard.removeObject(area);
	displayboard.removeObject(z1_txt);
	displayboard.removeObject(z2_txt);


	probability = board.create('integral', [[
		function() { return z1.X(); }, 
		function() { return z2.X(); }], 
		normal_curve], 
		{ 
			color: '#00ff00', 
			fillOpacity: 0.3, 
			withLabel: false,
			fixed: true,
			highlight: false 
		});
	probability.curveLeft.setAttribute( { visible: false } );
	probability.curveRight.setAttribute( { visible: false } );

	area = displayboard.create('text', [1, 8, 
		function() { 
			return 'Area = ' + currentProbability(z1.X(), z2.X()); 
		}], { fontSize: 18 });
		
	z1_txt = displayboard.create('text', [1, 7.5, 
		function() { 
			if(z1.X() < -9.9) {
				return 'z1 = -&#x221e;';
			} else if(z1.X() > 9.9) {
				return 'z1 = +&#x221e;';
			} else return 'z1 = ' + z1.X().toFixed(2); 
		}], { fontSize: 18 });

	z2_txt = displayboard.create('text', [1, 7, 
		function() { 
			if(z2.X() < -9.9) {
				return 'z2 = -&#x221e;';
			} else if(z2.X() > 9.9) {
				return 'z2 = +&#x221e;';
			} else
			return 'z2 = ' + z2.X().toFixed(2); 
		}], { fontSize: 18 });

}

z1 = board.create('glider', [-2, 0, hidden_axis], { name: 'z1' });
z1.on('drag', 
	function() { 
		displayboard.update(); 
	});

z2 = board.create('glider', [2, 0, hidden_axis], { name: 'z2' });
z2.on('drag', 
	function() { 
		displayboard.update(); 
	}); 
	
setupstuff();

function currentProbability(x1, x2) { 
	if(cb[BETWEEN].Value()) { 
		return Math.abs(normalcdf(x2) - normalcdf(x1)).toFixed(4);
	} else if(cb[LEFT].Value()) {
		return normalcdf(x2).toFixed(4);
	} else if(cb[RIGHT].Value()) {
		return (1 - normalcdf(x1)).toFixed(4);
	} else if(cb[TWOTAIL].Value()) {
	return (1 - Math.abs(normalcdf(x2) - normalcdf(x1))).toFixed(4);
	}
}

function update() {

	var orgbounds = board.getBoundingBox();
	var width = document.getElementById('jxgbox').clientWidth;
	var height = document.getElementById('jxgbox').clientHeight;

	board.resizeContainer(width, height);
	board.setBoundingBox(orgbounds, false);

	board.update();	
		
}

cb_ZoomSquare = displayboard.create('checkbox', [1, 9, 'Zoom Square']);

slider_horiz_zoom = displayboard.create('slider', [[1, 2], [7, 2], [-10, 1, 10]]);
horiz_zoom_label = displayboard.create('text', [9, 2, 'x zoom']);
horiz_zoom_level = 1;
slider_horiz_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_horiz_zoom.Value();
		if(horiz_zoom_level > newfactor) {
			orgbounds[0] = orgbounds[0] * 1.1;
			orgbounds[2] = orgbounds[2] * 1.1;
		} else {
			orgbounds[0] = orgbounds[0] / 1.1;
			orgbounds[2] = orgbounds[2] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		horiz_zoom_level = newfactor;
	});

slider_vert_zoom = displayboard.create('slider', [[1, 1.5], [7, 1.5], [-10, 1, 10]]);
vert_zoom_label = displayboard.create('text', [9, 1.5, 'y zoom']);
vert_zoom_level = 1;
slider_vert_zoom.on('drag', 
	function() {
		var orgbounds = board.getBoundingBox();
		var newfactor = slider_vert_zoom.Value();
		if(vert_zoom_level > newfactor) {
			orgbounds[1] = orgbounds[1] * 1.1;
			orgbounds[3] = orgbounds[3] * 1.1;
		} else {
			orgbounds[1] = orgbounds[1] / 1.1;
			orgbounds[3] = orgbounds[3] / 1.1;
		}
		board.setBoundingBox(orgbounds, false);
		vert_zoom_level = newfactor;
	});	

// All the things that have to do with checkboxes

function setcbtrue(box) {
	cb[BETWEEN].rendNodeCheckbox.checked = false;
	cb[LEFT].rendNodeCheckbox.checked = false;
	cb[RIGHT].rendNodeCheckbox.checked = false;
	cb[TWOTAIL].rendNodeCheckbox.checked = false;
	cb[BETWEEN]._value = false;
	cb[LEFT]._value = false;
	cb[RIGHT]._value = false;
	cb[TWOTAIL]._value = false;
	cb[box].rendNodeCheckbox.checked = true;
	cb[box]._value = true;
}

JXG.addEvent(cb[BETWEEN].rendNodeCheckbox, 'change', 
	function() {
		setcbtrue(BETWEEN);
		
		board.removeObject(z1);
		board.removeObject(z2);
		
		z1 = board.create('glider', [-2, 0, hidden_axis], { name: 'z1' });
		z1.on('drag', function() { displayboard.update(); });

		z2 = board.create('glider', [2, 0, hidden_axis], { name: 'z2' });
		z2.on('drag', function() { displayboard.update(); }); 
		
		setupstuff();
		
		board.update();
		displayboard.update();
		
    }, cb[BETWEEN]);
	
JXG.addEvent(cb[LEFT].rendNodeCheckbox, 'change', 
	function() {
		setcbtrue(LEFT);

		board.removeObject(z1);
		board.removeObject(z2);

		z1 = board.create('glider', [-10, 0, hidden_axis], { name: 'z1', visible: false });
		z1.on('drag', function() { displayboard.update(); });

		z2 = board.create('glider', [2, 0, hidden_axis], { name: 'z2' });
		z2.on('drag', function() { displayboard.update(); }); 
		
		setupstuff();

		board.update();
		displayboard.update();
    }, cb[LEFT]);	

JXG.addEvent(cb[RIGHT].rendNodeCheckbox, 'change', 
	function() {
		setcbtrue(RIGHT);

		board.removeObject(z1);
		board.removeObject(z2);

		z1 = board.create('glider', [-2, 0, hidden_axis], { name: 'z1' });
		z1.on('drag', function() { displayboard.update(); });

		z2 = board.create('glider', [10, 0, hidden_axis], { name: 'z2', visible: false });
		z2.on('drag', function() { displayboard.update(); }); 
		
		setupstuff();

		board.update();
		displayboard.update();
    }, cb[RIGHT]);	

JXG.addEvent(cb[TWOTAIL].rendNodeCheckbox, 'change', 
	function() {
		setcbtrue(TWOTAIL);

		board.removeObject(z1);
		board.removeObject(z2);

		z1 = board.create('glider', [-2, 0, hidden_axis], { name: 'z1' });
		z1.on('drag', function() { displayboard.update(); });

		z2 = board.create('glider', [2, 0, hidden_axis], { name: 'z2' });
		z2.on('drag', function() { displayboard.update(); }); 
		
		setupstuff();

		board.update();
		displayboard.update();
    }, cb[TWOTAIL]);		
	
</script>
</body>
</html>