<!DOCTYPE html>
<html lang="en-US">

<head>

	<title>Curvature</title>
	<meta charset="utf-8">  

		<!-- JSX Graph -->
		<script type="text/javascript" charset="UTF-8" src="https://cdn.jsdelivr.net/npm/jsxgraph@1.4.6/distrib/jsxgraphcore.js"></script>
		<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/jsxgraph@1.4.6/distrib/jsxgraph.css" />

		<!-- Math.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.2.1/math.min.js"></script>

		<!-- Mine -->
		<script src='./js/MathFunctions.js' type='text/javascript'></script>
		<script src='./js/helpers.js' type='text/javascript'></script>

	</meta>
</head>

<body>

<h1>Curvature</h1>

f(x) = <input type="text" id="input_function" value="3*exp(-x^2)">
&emsp;&emsp;<input type="button" value="Update" onClick="update()">
&emsp;&emsp;<input type="button" value="Toggle Fullscreen" onClick="fullscreen()">
&emsp;&emsp;<input type="button" value="Toggle Zoom Panel" onClick="toggle_zoomPanel()">
</br></br>

<div>
	<div id="jxgbox" class="jxgbox" style="width:1000px; height:720px; float:left; resize: both"></div>
	<div id="display" class="jxgbox" style="width:320px; height:720px; float:left; resize: both"></div>
</div>

<script type='text/javascript'>
		
var board = JXG.JSXGraph.initBoard('jxgbox', {
		boundingbox: [-5,5,5,-5], 
      	showCopyright: false, 
      	showNavigation: true,
		keepaspectratio: true,
		axis: true,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: true,
            needshift: false,
            eps: 0.1
        }		
    });

var displayboard = JXG.JSXGraph.initBoard('display', {
		boundingbox: [0,10,10,0], 
      	showCopyright: false, 
      	showNavigation: false,
		keepaspectratio: false,
		axis: false,
      	zoom: {
            factorX: 1.25,
            factorY: 1.25,
            wheel: true,
            needshift: false,
            eps: 0.1
        }		
    });

// Set up x-zoom and y-zoom sliders
setupZoomPanel(board, { visible: false, xinit: 14, yinit: 10 });

// curve - the curve drawn for the input function f
// a - the center of where the circle should be
// p - the point where the calculation is done
// circle - the circle

// p_label - the coordinates of point p
// k_label - the value of K which is the curvature value
// r_label - the radius of the circle drawn

let curve, a, p, circle;

let p_label = displayboard.create('text', [0.5, 9.5, ''], { fontSize: 18 });
let k_label = displayboard.create('text', [0.5, 8.75, ''], { fontSize: 18 });
let r_label = displayboard.create('text', [0.5, 8, ''], { fontSize: 18 });

update();

function update() {

	// Retrieve the input function and find its first and second derivatives
	let f = document.getElementById('input_function').value;
	
	let relation = makeJSFunction(board, f);
	let d = JXG.Math.Numerics.D(relation);
	let d2 = JXG.Math.Numerics.D(d);

	board.removeObject(curve);
	board.removeObject(circle);
	board.removeObject(a);
	board.removeObject(p);
	
	// Calculate the radius of curvature function: r = (1 + (y')^2)^(3/2) / |y''|
	let r = function() { return Math.pow(1 + Math.pow(d(p.X()), 2), 3/2) / Math.abs(d2(p.X())); }

	curve = board.create('functiongraph', [relation], { strokeWidth: 2 });
	p = board.create('glider', [-2, 0, curve], { name: 'P' });
	a = board.create('point', [
		function() { 
			let m_perp = -1 / d( p.X() );
			let concavity = sgn( d2( p.X() ) );
			let quad = quadrant(p.X(), p.Y());
			let radius = r( p.X() );
			let unit = concavity * sqrt( 1 + sqr( m_perp ));
			if (quad == 1 || quad == 3) {
				return p.X() + radius / unit;
			} else {
				return p.X() - radius / unit;
			}
		}, 
		function() {
			let m_perp = -1 / d( p.X() );
			let concavity = sgn( d2( p.X() ) );
			let quad = quadrant(p.X(), p.Y());
			let radius = r( p.X() );
			let unit = concavity * sqrt( 1 + sqr( m_perp ));
			if (quad == 1 || quad == 3) {
				return p.Y() + (radius * m_perp) / unit;
			} else {
				return p.Y() - (radius * m_perp) / unit;
			}
		}], { visible: false, name: 'C' });

	circle = board.create('circle', [a, p]);

	p.on('drag', 
		function() { 	
			displayboard.update();
		});	
		
	p_label.setText(function() { return 'p = (' + p.X().toFixed(2) + ', ' + p.Y().toFixed(2) + ')'; });
	k_label.setText(function() { return 'K = ' + (1 / r(p.X())).toFixed(5); });
	r_label.setText(function() { return 'r = ' + r(p.X()).toFixed(2); });
		
	board.update();	
	displayboard.update();
		
}

</script>
</body>
</html>